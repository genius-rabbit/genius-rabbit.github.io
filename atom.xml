<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Delta1037</title>
  
  <subtitle>技术是纯净的</subtitle>
  <link href="https://www.delta1037.cn/atom.xml" rel="self"/>
  
  <link href="https://www.delta1037.cn/"/>
  <updated>2021-02-06T08:48:33.538Z</updated>
  <id>https://www.delta1037.cn/</id>
  
  <author>
    <name>delta1037</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>程序的执行</title>
    <link href="https://www.delta1037.cn/2021/C_C++/%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%89%A7%E8%A1%8C/"/>
    <id>https://www.delta1037.cn/2021/C_C++/%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%89%A7%E8%A1%8C/</id>
    <published>2021-02-04T15:19:45.000Z</published>
    <updated>2021-02-06T08:48:33.538Z</updated>
    
    <content type="html"><![CDATA[<h1 id="程序的执行"><a href="#程序的执行" class="headerlink" title="程序的执行"></a>程序的执行</h1><h2 id="一、exec库函数"><a href="#一、exec库函数" class="headerlink" title="一、exec库函数"></a>一、exec库函数</h2><p>基于系统调用<code>execve()</code>，提供了一系列冠以exec来命名的上层库函数，虽然<strong>接口方式各异</strong>，但<strong>功能一致</strong>。</p><h3 id="1-1-执行新程序：execve"><a href="#1-1-执行新程序：execve" class="headerlink" title="1.1 执行新程序：execve()"></a>1.1 执行新程序：execve()</h3><p>系统调用<code>execve()</code>可以将新的程序加载到调用者进程的内存空间。这一操作过程中，进程的栈、数据以及堆段会被新的程序相应部件替换。一般由<code>fork()</code>生成的子进程对<code>execve()</code>的调用最常见。</p><p><code>execve()</code>系统调用定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execve</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">char</span> *<span class="keyword">const</span> argv[], <span class="keyword">char</span> *<span class="keyword">const</span> envp[])</span></span>;</span><br><span class="line"><span class="comment">/* 成功不返回，失败返回-1 */</span></span><br></pre></td></tr></table></figure><p><code>execve()</code>系统调用参数说明：</p><ul><li>pathname是准备载入当前进程空间的新程序的路径名。pathname可以是绝对路径，也可以是相对调用进程当前工作目录（current working directory）的相对路径</li><li>argv指定了传递给新进程的命令行参数。argv是由字符串指针组成的列表，并且<strong>以NULL值结尾</strong>。其中argv[0]的值对应于命令名，通常来说与pathname中的basename（路径的最后部分）值相同。</li><li>envp指定了新程序的环境列表。对应于新程序的environ数组，也是由字符串指针组成的列表，格式为<code>name=value</code>，并且<strong>以NULL值结尾</strong>。</li></ul><p>调用execve()之后,因为同一进程依然存在，所以<strong>进程ID不变</strong>。</p><h3 id="1-2-exec-库函数"><a href="#1-2-exec-库函数" class="headerlink" title="1.2 exec()库函数"></a>1.2 exec()库函数</h3><p>基于系统调用，库函数提供了多种API选择，这些API都构建于<code>execve()</code>之上，只是在为新程序指定程序名，参数列表以及环境变量的方式上有所不同。</p><p>exec()库函数API如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execle</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">const</span> <span class="keyword">char</span> * arg, ... <span class="comment">/*, (char*)NULL, char *const envp[] */</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execlp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *filename, <span class="keyword">const</span> <span class="keyword">char</span> * arg, ... <span class="comment">/*, (char*)NULL */</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execvp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *filename, <span class="keyword">char</span> *<span class="keyword">const</span> argv[])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execv</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">char</span> *<span class="keyword">const</span> argv[])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execl</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">const</span> <span class="keyword">char</span> * arg, ... <span class="comment">/*, (char*)NULL */</span>)</span></span>;</span><br><span class="line"><span class="comment">/* 成功不返回，失败返回-1 */</span></span><br></pre></td></tr></table></figure><p><code>exec()</code>库函数之间的差异总结</p><div class="table-container"><table><thead><tr><th>函数</th><th>对程序文件的描述（-,p）</th><th>对参数的描述（v,l）</th><th>环境变量来源（e,-）</th></tr></thead><tbody><tr><td>execve()</td><td>路径名</td><td>数组</td><td>envp参数</td></tr><tr><td>execle()</td><td>路径名</td><td>列表</td><td>envp参数</td></tr><tr><td>execlp()</td><td>文件名+PATH</td><td>列表</td><td>调用者的environ</td></tr><tr><td>execvp()</td><td>文件名+PATH</td><td>数据</td><td>调用者的environ</td></tr><tr><td>execv()</td><td>路径名</td><td>数组</td><td>调用者的environ</td></tr><tr><td>execl()</td><td>路径名</td><td>列表</td><td>调用者的environ</td></tr></tbody></table></div><p><code>fexecve()</code>执行由文件描述符指定的程序。有些应用程序需要打开某个文件，通过执行校验和之后再运行该程序，这一场景就比较适合使用<code>fexecve()</code>，该接口定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fexecve</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">char</span> *<span class="keyword">const</span> argv[], <span class="keyword">char</span> *<span class="keyword">const</span> envp[])</span></span>;</span><br><span class="line"><span class="comment">/* 成功不返回，失败返回-1 */</span></span><br></pre></td></tr></table></figure><h3 id="1-3-解释器脚本"><a href="#1-3-解释器脚本" class="headerlink" title="1.3 解释器脚本"></a>1.3 解释器脚本</h3><p>解释器(interpreter)是能够读取并执行文本格式命令的程序。（相形之下，编译器是将源代码译为可在真实或者虚拟机上执行的机器语言）解释器通常可以从被称为脚本的文件中读取和执行命令。</p><p>UNIX内核运行解释器脚本的方式与二进制程序无异，前提是：1、必须赋予脚本可执行权限；2、文件的起始行必须执行运行脚本的解释器路径名，格式如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! interpreter</span></span><br><span class="line"><span class="comment"># 其中 </span></span><br><span class="line"><span class="comment"># 1、#!必须置于改行起始处，这两个字符可以与解释器的路径名使用空格分割</span></span><br><span class="line"><span class="comment"># 2、在解释解释器路径名时不会使用环境变量PATH，所以解释器路径一般使用绝对路径</span></span><br><span class="line"><span class="comment"># 3、解释器路径名后可以跟随可选参数，二者以空格分隔，但是可选参数中不应包含空格（Linux系统不会将对可选参数中的中的空格做特殊解释，从参数起始到行尾视为一个单词，并且要求脚本的#!起始行不超过127个字节，包括换行符）</span></span><br></pre></td></tr></table></figure><p>当调用<code>execve()</code>来运行脚本时，<code>execve()</code>如果检测到传入的文件以两字节序列开始，就会析取该行剩余的部分（路径名和参数）。然后按照如下格式执行解释器程序：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">interpreter-path [optional-arg] script-path arg</span><br></pre></td></tr></table></figure><p>interpreter-path(解释器路径)和optional-arg(可选参数)都取自脚本的<code>#!</code>行，script-path时传递给<code>execve()</code>的路径名，arg是通过argv传递给<code>execve()</code>的参数列表（argv[0]排除在外）。</p><h2 id="二、执行shell命令：system"><a href="#二、执行shell命令：system" class="headerlink" title="二、执行shell命令：system"></a>二、执行shell命令：system</h2><p>程序可以通过调用<code>system()</code>函数来执行任意的shell命令，函数定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">system</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>*command)</span></span>;</span><br><span class="line"></span><br><span class="line"># 返回值定义如下</span><br><span class="line"># <span class="number">1</span>、当command命令为<span class="literal">NULL</span>指针时，如果shell可用则system()返回非<span class="number">0</span>值，如果不可用则返回<span class="number">0</span></span><br><span class="line"># <span class="number">2</span>、如果无法创建子进程或者无法获取其终止状态，system返回<span class="number">-1</span></span><br><span class="line"># <span class="number">3</span>、如果子进程不能执行shell，则system返回值与子shell调用_exit(<span class="number">127</span>)终止时一样</span><br><span class="line"># <span class="number">4</span>、如果所有的系统调用都成功，system返回执行command的子shell的终止状态。shell的终止状态是执行最后一条命令时的退出状态；如果命令被信号所杀，大多数shell会以<span class="number">128</span>+n的值退出，其中n为信号编号</span><br></pre></td></tr></table></figure><p>函数<code>system()</code>创建一个子进程来运行shell，并以之执行命令command。所以使用<code>system()</code>函数运行命令至少会创建两个进程，一个用于运行shell，另一个或者多个用于运行shell所执行的命令（如果对效率或者速度有要求，最好直接调用<code>fork()</code>和<code>exec()</code>来执行既定程序）。</p><h2 id="三、通过管道与shell命令通信popen"><a href="#三、通过管道与shell命令通信popen" class="headerlink" title="三、通过管道与shell命令通信popen"></a>三、通过管道与shell命令通信popen</h2><p>管道的一个常见的用途是执行shell命令并读取或向其发送一些输入。<code>popen()</code>和<code>pclose()</code>简化了这个任务，函数定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">FILE *<span class="title">popen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *command, <span class="keyword">const</span> <span class="keyword">char</span> *mode)</span></span>;</span><br><span class="line"><span class="comment">/* 成功时返回文件流指针，失败时返回NULL并设置errno */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pclose</span><span class="params">(FILE *stream)</span></span>;</span><br><span class="line"><span class="comment">/* 成功时返回子进程结束状态，失败返回-1 */</span></span><br></pre></td></tr></table></figure><p><code>popen()</code>函数创建了一个管道，然后创建了一个子进程来执行shell，而shell又创建了一个子进程来执行command字符串。其中mode是一个<strong>字符串</strong>，它确定调用进程是从管道中读取数据（mode是r）或者是写入到管道中（mode是w），由于管道是单向的，所以<strong>无法在执行的command中进行双向通信</strong>。</p><p>与使用pipe()创建的管道一样，当从管道中读取数据时，调用进程在command关闭管道的写入端之后会看到文件结束；当向管道写入数据时，如果command已经关闭了管道的读取端，那么调用进程会收到SIGPIPE并的到EPIPE错误。</p><p>当IO结束之后可以使用<code>pclose()</code>函数关闭管道并等待子进程中的shell终止（不应该使用<code>fclose()</code>函数，因为它不会等待子进程）。<code>pclose()</code>在成功时会返回子进程中shell的终止状态（即shell命令执行最后一条命令的终止状态，除非是被信号杀死的）。与<code>system()</code>一样，如果无法执行shell，<code>pclose()</code>会返回一个值就像是子进程中的shell调用_exit(127)来终止一样。如果发生了其它错误，那么<code>pclose()</code>返回-1。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>【0】Linux/UNIX系统编程手册</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;程序的执行&quot;&gt;&lt;a href=&quot;#程序的执行&quot; class=&quot;headerlink&quot; title=&quot;程序的执行&quot;&gt;&lt;/a&gt;程序的执行&lt;/h1&gt;&lt;h2 id=&quot;一、exec库函数&quot;&gt;&lt;a href=&quot;#一、exec库函数&quot; class=&quot;headerlink&quot; ti</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>计算机系统</title>
    <link href="https://www.delta1037.cn/2021/APUE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    <id>https://www.delta1037.cn/2021/APUE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/</id>
    <published>2021-01-31T13:19:45.000Z</published>
    <updated>2021-01-31T12:39:18.515Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计算机系统"><a href="#计算机系统" class="headerlink" title="计算机系统"></a>计算机系统</h1><h2 id="一、硬件组织"><a href="#一、硬件组织" class="headerlink" title="一、硬件组织"></a>一、硬件组织</h2><h3 id="1-1-总线"><a href="#1-1-总线" class="headerlink" title="1.1 总线"></a>1.1 总线</h3><p>总线被设计成传送定长的字节块，也就是<strong>字</strong>（word）。现在大多数机器要么是4个字节（32位），要么是8个字节（64位）。</p><h3 id="1-2-I-O设备"><a href="#1-2-I-O设备" class="headerlink" title="1.2 I/O设备"></a>1.2 I/O设备</h3><p>I/O设备是是系统与外部的联系通道。基本的I/O设备包括：作为用户输入的鼠标和键盘、作为用户输出的显示器和用于长期存储数据和程序的磁盘驱动器（磁盘）。</p><p>每一个I/O设备都通过一个控制器<strong>或</strong>适配器与I/O总线相连。<strong>控制器</strong>是IO设备本身或者系统的主印制电路板（主板）上的芯片组。<strong>适配器</strong>是插在主板插槽上的卡。</p><h3 id="1-3-主存"><a href="#1-3-主存" class="headerlink" title="1.3 主存"></a>1.3 主存</h3><p>主存是一个<strong>临时</strong>存储设备。在处理器执行程序时，用来存放程序和程序处理的数据。从物理上来讲，主存是一组动态随机存取存储器（DRAM）组成的；从逻辑上来说，存储器是一个线性的字节数组，每个字节有<strong>唯一的地址</strong>。</p><h3 id="1-4-处理器"><a href="#1-4-处理器" class="headerlink" title="1.4 处理器"></a>1.4 处理器</h3><p>中央处理单元（CPU），简称处理器，是解释（执行）存储在主存中指令的引擎。处理器的核心是一个大小为一个字的存储设备（或寄存器），称为<strong>程序计数器</strong>（PC）。</p><p>从系统通电开始，直到系统断电，处理器一直在不断地执行程序计数器指向的指令，再更新计数器，使之指向下一条指令。</p><h2 id="二、操作系统"><a href="#二、操作系统" class="headerlink" title="二、操作系统"></a>二、操作系统</h2><p>操作系统的两个基本功能：（1）防止硬件被失控的应用程序滥用；（2）向应用程序提供简单一致的机制来控制复杂而又通常不同的低级硬件设备。</p><h3 id="2-1-进程"><a href="#2-1-进程" class="headerlink" title="2.1 进程"></a>2.1 进程</h3><p>进程是操作系统对一个正在运行的程序的一种抽象。在一个系统上可以同时运行多个进程，每个进程像是独占地使用硬件。</p><p>一个CPU看上去在并发地执行多个进程，这是通过进程间的切换实现的。操作系统实现这种交错执行的机制称为<strong>上下文切换</strong>，操作系统保持跟踪进程运行所需的所有的状态信息，这些状态信息就是<strong>上下文</strong>。</p><h3 id="2-2-线程"><a href="#2-2-线程" class="headerlink" title="2.2 线程"></a>2.2 线程</h3><p>在现代操作系统中，一个进程实际上是可以由多个称为线程的执行单元组成，每个线程运行在进程的上下文中，并共享同样的<strong>代码</strong>和<strong>全局数据</strong>。</p><h3 id="2-3-虚拟内存"><a href="#2-3-虚拟内存" class="headerlink" title="2.3 虚拟内存"></a>2.3 虚拟内存</h3><p>虚拟内存是一个抽象概念，为每一个进程提供了一个假象——每个进程在独占地使用主存。每个进程看到地内存都是一致地，称为<strong>虚拟地址空间</strong>。</p><p>Linux进程地虚拟地址空间是由大量准确定义地区域组成的。从低地址到高地址主要有：</p><ul><li>只读的代码和数据、读/写数据：对所有的进程来说，代码是从一个固定的地址开始的。代码区和数据区是直接按照可执行目标文件的内容初始化的。</li><li>运行时堆：堆可以在运行时进行动态地扩展和收缩</li><li>共享库：大约在地址空间的中间部分。</li><li>用户栈：编译器用它来实现函数调用。每调用一个函数，栈就会增长；从一个函数返回时，栈会收缩。</li><li>内核虚拟内存：为内核保留，不允许应用程序读写这个区域的内容或者直接调用内核代码定义的函数。相反，必须调用内核来执行这些操作。</li></ul><h3 id="2-4-文件"><a href="#2-4-文件" class="headerlink" title="2.4 文件"></a>2.4 文件</h3><p>文件就是字节序列。每一个IO设备甚至是网络，都可以看成是文件。系统中的所有输入输出都是通过一组Unix I/O的系统函数调用读写文件来实现的。</p><h2 id="三、计算机系统中的抽象"><a href="#三、计算机系统中的抽象" class="headerlink" title="三、计算机系统中的抽象"></a>三、计算机系统中的抽象</h2><ul><li>文件是对I/O设备的抽象</li><li>虚拟内存是是对程序存储器的抽象（主存和磁盘的抽象）</li><li>进程是对一个正在运行的程序的抽象（处理器、主存和I/O设备的抽象）</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>【0】深入理解计算机系统</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;计算机系统&quot;&gt;&lt;a href=&quot;#计算机系统&quot; class=&quot;headerlink&quot; title=&quot;计算机系统&quot;&gt;&lt;/a&gt;计算机系统&lt;/h1&gt;&lt;h2 id=&quot;一、硬件组织&quot;&gt;&lt;a href=&quot;#一、硬件组织&quot; class=&quot;headerlink&quot; title=&quot;一</summary>
      
    
    
    
    
    <category term="OS" scheme="https://www.delta1037.cn/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>圣诞树彩灯曲线方程</title>
    <link href="https://www.delta1037.cn/2020/Math/%E5%9C%A3%E8%AF%9E%E6%A0%91%E5%BD%A9%E7%81%AF%E6%9B%B2%E7%BA%BF%E6%96%B9%E7%A8%8B/"/>
    <id>https://www.delta1037.cn/2020/Math/%E5%9C%A3%E8%AF%9E%E6%A0%91%E5%BD%A9%E7%81%AF%E6%9B%B2%E7%BA%BF%E6%96%B9%E7%A8%8B/</id>
    <published>2020-12-19T14:18:31.000Z</published>
    <updated>2021-01-17T08:41:59.576Z</updated>
    
    <content type="html"><![CDATA[<h1 id="圣诞树彩灯曲线方程"><a href="#圣诞树彩灯曲线方程" class="headerlink" title="圣诞树彩灯曲线方程"></a>圣诞树彩灯曲线方程</h1><p>马上就要圣诞节了，圣诞树上会绕一圈彩灯，以表对圣诞节的敬意，淦！</p><p>对于一个圣诞树，绕的一圈的彩灯的曲线是什么样的呢？侧面看起来是什么样的？如果彩灯曲线上彩灯分布式均匀的，那么彩灯的位置该怎么计算？</p><p>本文假设圣诞树是一个圆锥体，彩灯从顶端开始等梯度绕线，并绕了整数圈，如下图所示：</p><p><img src="https://delta1037.oss-cn-beijing.aliyuncs.com/hexo-blog/christmas_tree_equation/view.png" alt=""></p><p>本文主要固定值：</p><ul><li>H：圆锥体高</li><li>W：圆锥体底面直径</li><li>A：圆锥顶点</li><li>O：圆锥底面圆心</li><li>M：绕线与底面的交点</li><li>Q：绕线的圈数</li><li>T：彩灯的间隔距离</li></ul><h2 id="一、建立三维的彩灯曲线方程"><a href="#一、建立三维的彩灯曲线方程" class="headerlink" title="一、建立三维的彩灯曲线方程"></a>一、建立三维的彩灯曲线方程</h2><p>以圆锥的底面圆心O为基准，在底面上建立极坐标系；以从圆锥顶点A到圆锥底面圆心O方向为$Z$轴；建立坐标系，如下图所示</p><p><img src="https://delta1037.oss-cn-beijing.aliyuncs.com/hexo-blog/christmas_tree_equation/view_axi_draw.png" alt=""></p><p>绕线的圈数是Q，所以绕线的总角度是 $2{\pi}Q$，由于绕线是均匀的，所以$Z$轴方向的$h$和极坐标平面上的曲线半径$l$都是均匀变化的，所以曲线方程如下：</p><script type="math/tex; mode=display">f(\theta, l, h)\begin{cases}\theta=\theta , &0 \le \theta \le 2{\pi}Q \\l = { {W\theta}\over{4{\pi}Q} }, \\h = { {H\theta}\over{2{\pi}Q} }, \end{cases}</script><p>其中：</p><p>曲线半径最大是$W\over2$，在$\theta \in[0, 2{\pi}Q]$的范围内均匀变化所以$l = { { W\over2 }\over{2{\pi}Q}  }\theta = { {W\theta}\over{4{\pi}Q} }$</p><p>圆锥高为$H$，在$\theta \in[0, 2{\pi}Q]$的范围内均匀变化所以$l = { { H }\over{2{\pi}Q}  }\theta = { {H\theta}\over{2{\pi}Q} }$</p><h2 id="二、俯视图的彩灯曲线"><a href="#二、俯视图的彩灯曲线" class="headerlink" title="二、俯视图的彩灯曲线"></a>二、俯视图的彩灯曲线</h2><p>圣诞树上彩灯从树的俯视图方向看如下：</p><p><img src="https://delta1037.oss-cn-beijing.aliyuncs.com/hexo-blog/christmas_tree_equation/top_view.png" alt="俯视图效果"></p><p>为什么俯视图（像）是螺旋线呢？俯视图去掉了三维视图中高的特征，所以可以在俯视图上建立极坐标系，如下如所示：</p><p><img src="https://delta1037.oss-cn-beijing.aliyuncs.com/hexo-blog/christmas_tree_equation/top_view-axi-draw.png" alt="俯视图坐标系"></p><p>从三维坐标系中抽出极坐标平面相关的变量，由于三维坐标系中的曲线方程$f(\theta, l, h)$组成的方程中与极坐标平面相关的变量$\theta,l$与$h$没有关系，所以俯视图彩灯曲线方程如下：</p><script type="math/tex; mode=display">l = f(\theta) = { {W\theta}\over{4{\pi}Q} }  \ \ \ \ \ \ \ 0 \le \theta \le 2{\pi}Q \\</script><p>其中：</p><p>$l$是随$\theta$均匀变化的，所以俯视图是平面上的螺旋线。</p><h2 id="三、主视图的彩灯曲线"><a href="#三、主视图的彩灯曲线" class="headerlink" title="三、主视图的彩灯曲线"></a>三、主视图的彩灯曲线</h2><p>圣诞树上的彩灯从树的主视图方向看如下：</p><p><img src="https://delta1037.oss-cn-beijing.aliyuncs.com/hexo-blog/christmas_tree_equation/main_view.png" alt=""></p><p>主视图为什么长这个样子呢？主视图上关于三维坐标系中的$h$相关的特征是没有损失的，那么关于螺旋线在主视图上的投影是什么样的呢？</p><p>我们可以在俯视图的螺旋线上看（如下图所示），我们对于螺旋线的任何一个位置，向极坐标的起始位置作垂线（起始位置是与主视图方向平行的），也就是在$\theta$处，我们在主视图方向看到的偏离圆锥中轴线方向的长度是$l*cos(\theta)$。</p><p><img src="https://delta1037.oss-cn-beijing.aliyuncs.com/hexo-blog/christmas_tree_equation/top_view-axi-draw-fuzhu.png" alt=""></p><p>我们在主视图上建立如下坐标系：</p><p><img src="https://delta1037.oss-cn-beijing.aliyuncs.com/hexo-blog/christmas_tree_equation/main_view-axi-draw.png" alt=""></p><p>所以根据以上的分析，在$h$方向是随$\theta$均匀变化的，在$w$方向，坐标长度是$l*cos(\theta)$，但是在主视图的坐标系中不存在$\theta$变量，所以我们使用h变量来替换掉$\theta$，根据彩灯的三维曲线方程，我们知道$h = { {H\theta}\over{2{\pi}Q} }$，所以$\theta$使用$h$来表示则是$\theta = { {2{\pi}Qh}\over{H} }$，$l$使用$\theta$替换可得$l = { {W\theta}\over{4{\pi}Q} }$。所以在$w$方向，$w = l\ cos(\theta) = { {W\theta}\over{4{\pi}Q} } \ cos(\theta) = {Wh\over2H}\ cos({ {2{\pi}Qh}\over{H} })$ 。所以主视图上的方程如下：</p><script type="math/tex; mode=display">w = f(h) = {Wh\over2H}\ cos({ {2{\pi}Qh}\over{H} })  \ \ \ \ \ \ \ 0 \le h \le H \\</script><p>其中：</p><p>$w$的核心为$h \ cos(h)$，该函数是一次函数$h$和三角函数$cos(h)$的乘积，即使用一次函数$h$对三角函数$cos(h)$的范围进行了限制。</p><h2 id="四、主视图上彩灯位置方程"><a href="#四、主视图上彩灯位置方程" class="headerlink" title="四、主视图上彩灯位置方程"></a>四、主视图上彩灯位置方程</h2><p>俯视图上来看彩灯的间隔距离是不相等的（由于俯视图上将曲线等梯度下降这一特性抹掉了，彩灯实际的距离应该是$\sqrt{ 彩灯间隔对应梯度^2 + 俯视图彩灯间隔^2 }$，联想到小时候见到的一个三角形纸片卷在铅笔上从而类似盘山公路，将螺旋线展开<strong>可能</strong>也是一个直角三角形，将盘山公路这一想法对应到螺旋线中，从三维方程中可知，$h = { {H \theta}\over{2{\pi}Q} } $，即$h$是随着$\theta$线性变化的，即盘上公路展开的图形的高是随着$\theta$线性变化的；盘山公路展开的图形对应的底边是$l*\Delta \theta$的和式，由于$l = { {W\theta}\over{4{\pi}Q} }$，所以底边对应增量$d_{v} = { {W\theta}\over{4{\pi}Q} } d_{\theta}$，求积分得$V = { {W\theta^{2} }\over{8{\pi}Q} } $，所以展开图形的底边不是随着$\theta$线性变化的，所以螺旋线展开不是一个直角三角形，其中斜边向下弯曲，因为斜率随着$\theta$的增大而减小）</p><p>但我们为了简化计算，认为螺旋线的展开是一个三角形，并且从$\theta$的范围得出底边的总长度是${\pi wQ}\over{2}$。</p><p>为了计算彩灯间隔T对应的$\Delta h$，有了$\Delta h$才能计算每一个彩灯相对于上一个$h$位置的$w$值。</p><p>假设彩灯在俯视图上的间隔是T，假设间隔T对应的角度变化量为$\Delta \theta$，所以T和$\Delta \theta$的对应关系是</p><script type="math/tex; mode=display">T = l\Delta \theta = { {W\theta}\over{4{\pi}Q} }  \Delta \theta</script><p>代入$\theta = { {2{\pi}Qh}\over{H} }$可得</p><script type="math/tex; mode=display">\Delta \theta = { 4{ {\pi}QT}\over{W\theta} } = { 2HT \over { Wh } }</script><p>由$\theta = { {2{\pi}Qh}\over{H} }$可得</p><script type="math/tex; mode=display">\Delta \theta = { {2{\pi}Q\Delta h}\over{H} }</script><p>联立方程(5)(6)消去$\Delta \theta$可得</p><script type="math/tex; mode=display">\Delta h = { TH^2 \over {\pi WQh} }</script><p>所以每一次彩灯的变化量与当前的h值有关（假设当前为$h$，则下一次位置是$h + \Delta h$，以此自以为是的将方程7进行修正，将$h$值取为当前$h$和下一次位置$h + \Delta h$的平均值$h + { \Delta h \over 2 }$，从而得到如下方程）</p><script type="math/tex; mode=display">\Delta h = { TH^2 \over {\pi WQ(h + {\Delta h\over2}) } }</script><p>从而得到一元二次方程</p><script type="math/tex; mode=display">{\pi WQ \over 2}·\Delta h^2 + {\pi WQh}·\Delta h - TH^2 = 0</script><p>由$x_1,x_2 = {-b \pm \sqrt{b^2-4ac} \over 2 }$得</p><script type="math/tex; mode=display">\Delta h_1 = -h + { \sqrt{ h^2 + {2TH^2\over{ \pi WQ } } }  }\\ \Delta h_2 = -h - { \sqrt{ h^2 + {2TH^2\over{ \pi WQ } } }  } （负值舍去）</script><p>JS语言代码示例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> h_start = <span class="number">0.001</span>;</span><br><span class="line"><span class="keyword">var</span> h_max = <span class="number">300</span>;</span><br><span class="line"><span class="keyword">for</span>(double h = h_start; h &lt; h_max;)&#123;</span><br><span class="line">    <span class="comment">// 计算灯位置的x坐标和y坐标</span></span><br><span class="line">    <span class="keyword">var</span> light_x = h;</span><br><span class="line">    <span class="keyword">var</span> light_y = (W*h)/(<span class="number">2</span>*H) * <span class="built_in">Math</span>.sin(<span class="number">2</span>*<span class="built_in">Math</span>.PI*Q*h/H)</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 更新h的值</span></span><br><span class="line">    <span class="keyword">var</span> equation_A = <span class="built_in">Math</span>.PI * W * Q / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">var</span> equation_B =  <span class="built_in">Math</span>.PI * W * Q * h;</span><br><span class="line">    <span class="keyword">var</span> equation_C = -(T * H * H);</span><br><span class="line">    h = <span class="built_in">Math</span>.sqrt(equation_B * equation_B - <span class="number">4</span> * equation_A * equation_C) / (<span class="number">2</span> * equation_A);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>渲染出来的图：</p><p><img src="https://delta1037.oss-cn-beijing.aliyuncs.com/hexo-blog/christmas_tree_equation/tree_light.png" alt=""></p><p>备注：</p><p>如果想固定彩灯的总数$N$，需要求得彩灯间隔T的值，俯视图上的线的总长度是${\pi wQ}\over{2}$，所以该长度除以$N$得$T = { {\pi wQ}\over{2N} } $ 。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;圣诞树彩灯曲线方程&quot;&gt;&lt;a href=&quot;#圣诞树彩灯曲线方程&quot; class=&quot;headerlink&quot; title=&quot;圣诞树彩灯曲线方程&quot;&gt;&lt;/a&gt;圣诞树彩灯曲线方程&lt;/h1&gt;&lt;p&gt;马上就要圣诞节了，圣诞树上会绕一圈彩灯，以表对圣诞节的敬意，淦！&lt;/p&gt;
&lt;p&gt;对于</summary>
      
    
    
    
    <category term="Math" scheme="https://www.delta1037.cn/categories/Math/"/>
    
    
    <category term="Math" scheme="https://www.delta1037.cn/tags/Math/"/>
    
  </entry>
  
  <entry>
    <title>常用环境配置</title>
    <link href="https://www.delta1037.cn/2020/Mirror/%E5%B8%B8%E7%94%A8%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    <id>https://www.delta1037.cn/2020/Mirror/%E5%B8%B8%E7%94%A8%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</id>
    <published>2020-12-11T17:29:31.000Z</published>
    <updated>2020-12-11T17:31:07.612Z</updated>
    
    <content type="html"><![CDATA[<h1 id="常用环境配置"><a href="#常用环境配置" class="headerlink" title="常用环境配置"></a>常用环境配置</h1><h2 id="一、node"><a href="#一、node" class="headerlink" title="一、node"></a>一、node</h2><ul><li><p>安装包下载：</p><p><a href="https://npm.taobao.org/mirrors/node/v14.15.1/">nodejs淘宝源</a></p></li><li><p>更新方法</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下载二进制包</span></span><br><span class="line">wget https://nodejs.org/dist/v12.19.1/node-v12.19.1-linux-x64.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解压包</span></span><br><span class="line">tar -xzvf node-v12.19.1-linux-x64.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 移动到系统目录</span></span><br><span class="line">mv node-v12.19.1-linux-x64 /usr/<span class="built_in">local</span>/lib/nodejs</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加环境变量</span></span><br><span class="line"><span class="built_in">export</span> PATH=/usr/<span class="built_in">local</span>/lib/nodejs/bin:<span class="variable">$PATH</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看是否更新成功</span></span><br><span class="line">node -v</span><br></pre></td></tr></table></figure><h2 id="二、npm"><a href="#二、npm" class="headerlink" title="二、npm"></a>二、npm</h2><p>npm安装包太慢，配置淘宝npm镜像</p><h3 id="2-1-临时配置"><a href="#2-1-临时配置" class="headerlink" title="2.1 临时配置"></a>2.1 临时配置</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm --registry https://registry.npm.taobao.org install express</span><br></pre></td></tr></table></figure><h3 id="2-2-永久配置"><a href="#2-2-永久配置" class="headerlink" title="2.2 永久配置"></a>2.2 永久配置</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 配置</span></span><br><span class="line">npm config <span class="built_in">set</span> registry https://registry.npm.taobao.org</span><br><span class="line"></span><br><span class="line"><span class="comment"># 验证</span></span><br><span class="line">npm config get registry</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">npm info express</span><br></pre></td></tr></table></figure><h3 id="2-3-通过cnpm使用"><a href="#2-3-通过cnpm使用" class="headerlink" title="2.3 通过cnpm使用"></a>2.3 通过cnpm使用</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">npm install -g cnpm --registry=https://registry.npm.taobao.org</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用</span></span><br><span class="line">cnpm install express</span><br></pre></td></tr></table></figure><h3 id="2-4-恢复原源"><a href="#2-4-恢复原源" class="headerlink" title="2.4 恢复原源"></a>2.4 恢复原源</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config <span class="built_in">set</span> registry https://registry.npmjs.org</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>【0】<a href="https://blog.csdn.net/quuqu/article/details/64121812">npm太慢， 淘宝npm镜像使用方法</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;常用环境配置&quot;&gt;&lt;a href=&quot;#常用环境配置&quot; class=&quot;headerlink&quot; title=&quot;常用环境配置&quot;&gt;&lt;/a&gt;常用环境配置&lt;/h1&gt;&lt;h2 id=&quot;一、node&quot;&gt;&lt;a href=&quot;#一、node&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="Mirror" scheme="https://www.delta1037.cn/categories/Mirror/"/>
    
    
    <category term="Mirror" scheme="https://www.delta1037.cn/tags/Mirror/"/>
    
  </entry>
  
  <entry>
    <title>布隆过滤器</title>
    <link href="https://www.delta1037.cn/2020/Math/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/"/>
    <id>https://www.delta1037.cn/2020/Math/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/</id>
    <published>2020-12-11T14:16:31.000Z</published>
    <updated>2020-12-21T15:12:35.998Z</updated>
    
    <content type="html"><![CDATA[<h1 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h1><h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><p>布隆过滤器是由伯顿·布隆于1970年提出的。布隆过滤器实际上是一个很长的二进制向量和一系列随机映射函数。布隆过滤器用于判断一个元素是否在一个集合中，它只有插入元素和查询元素是否存在两种操作。</p><p>哈希表也有与布隆过滤器同样的功能，但是布隆过滤器只需要哈希表的$1/8$到$1/4$的大小就可以解决相同的问题，但是布隆过滤器可能存在误识别的问题，后续给出误识别的概率计算。</p><h2 id="二、应用"><a href="#二、应用" class="headerlink" title="二、应用"></a>二、应用</h2><ul><li>建立初始环境：假设存储一亿个电子邮件地址，建立16亿个比特位，即一个两亿字节的向量，将16亿个比特位清零。</li><li>插入元素：对于要插入的每一个电子邮件地址，使用8个不同的随机数生成器（$F_1$，$F_2$，…，$F_8$），生成8个信息指纹（$f_1$，$f_2$，…，$f_8$），再使用一个随机数产成器G将8个信息指纹映射到1-16亿中的八个自然数（$g_1$，$g_2$，…，$g_8$）。在16亿个比特位中将这8个自然数位置的比特位置为1。</li><li>查询元素：对于一个需要查询的邮件地址，使用相同的八个随机数生成器和随机数产生器得到八个自然数（$t_1$，$t_2$，…，$t_8$），如果在16亿个比特位向量中对应的比特值为1，则判断为元素存在。</li></ul><p><img src="https://delta1037.oss-cn-beijing.aliyuncs.com/hexo-blog/bloom/bloom.png" alt="布隆过滤器映射方法"></p><p>问题：有极小的概率误判元素存在，因为有可能某个邮件地址在布隆过滤器中的对应的8个位置恰巧被设置为1。</p><h2 id="三、误识别概率计算"><a href="#三、误识别概率计算" class="headerlink" title="三、误识别概率计算"></a>三、误识别概率计算</h2><p>假设布隆过滤器有m个比特位，已经插入了n个元素，每个元素使用k个散列函数。</p><p>在布隆过滤器中插入一个新的元素时，元素的第一个散列函数会将布隆过滤器中的某一位设置为1，因此某一位被设置为1的概率是${ {1}\over{m} }$（因为一共有m个比特位，每一个比特位被设置为1的概率是相同的，都是${ {1}\over{m} }$），某一位没有被设置为1的概率是$1-{ {1}\over{m} }$。</p><p>对于布隆过滤器中的一个特定的位置，插入一个元素，k个散列函数都没有将它置为1的概率是$(1-{ {1}\over{m} })^k$。插入第二个元素，该位置仍然没有被设置为1的概率是$(1-{ {1}\over{m} })^{2k}$。如果插入了n个元素，该位置仍然没有被置为1的概率是$(1-{ {1}\over{m} })^{nk}$。反过来，该位置被置为1的概率是$1-(1-{ {1}\over{m} })^{nk}$。</p><p>假定n个元素都已经插入到了布隆过滤器中，新来一个不在集合（即n个元素组成的集合）中的元素，新元素的第一个散列函数正好命中一个被置为1的位置的概率是上述计算的概率是$1-(1-{ {1}\over{m} })^{nk}$，如果新元素被误识别为在集合中，那么k个散列函数都命中了被置为1的位置，其概率为</p><script type="math/tex; mode=display">(1-(1-{ {1}\over{m} })^{nk})^k \approx (1-e^{ {-nk}\over{m} })^k</script><p>化简后为</p><script type="math/tex; mode=display">p = (1-e^{ {-ln({ {m}\over{n} }ln2)n}\over{m} })^{ln({ {m}\over{n} }ln2)}</script><p>如果n值比较大，可以近似为</p><script type="math/tex; mode=display">(1-e^{ {-k(n+0.5)}\over{m-1} })^k \approx (1-e^{ {-kn}\over{m} })^k</script><p>误识别率参考表，来源于<a href="http://pages.cs.wisc.edu/~cao/papers/summary-cache/node8.html">Bloom Filters - the math</a></p><div class="table-container"><table><thead><tr><th><em>m</em>/<em>n</em></th><th><em>k</em></th><th><em>k</em>=1</th><th><em>k</em>=2</th><th><em>k</em>=3</th><th><em>k</em>=4</th><th><em>k</em>=5</th><th><em>k</em>=6</th><th><em>k</em>=7</th><th><em>k</em>=8</th></tr></thead><tbody><tr><td>2</td><td>1.39</td><td>0.393</td><td>0.400</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>3</td><td>2.08</td><td>0.283</td><td>0.237</td><td>0.253</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>4</td><td>2.77</td><td>0.221</td><td>0.155</td><td>0.147</td><td>0.160</td><td></td><td></td><td></td><td></td></tr><tr><td>5</td><td>3.46</td><td>0.181</td><td>0.109</td><td>0.092</td><td>0.092</td><td>0.101</td><td></td><td></td><td></td></tr><tr><td>6</td><td>4.16</td><td>0.154</td><td>0.0804</td><td>0.0609</td><td>0.0561</td><td>0.0578</td><td>0.0638</td><td></td><td></td></tr><tr><td>7</td><td>4.85</td><td>0.133</td><td>0.0618</td><td>0.0423</td><td>0.0359</td><td>0.0347</td><td>0.0364</td><td></td><td></td></tr><tr><td>8</td><td>5.55</td><td>0.118</td><td>0.0489</td><td>0.0306</td><td>0.024</td><td>0.0217</td><td>0.0216</td><td>0.0229</td><td></td></tr><tr><td>9</td><td>6.24</td><td>0.105</td><td>0.0397</td><td>0.0228</td><td>0.0166</td><td>0.0141</td><td>0.0133</td><td>0.0135</td><td>0.0145</td></tr><tr><td>10</td><td>6.93</td><td>0.0952</td><td>0.0329</td><td>0.0174</td><td>0.0118</td><td>0.00943</td><td>0.00844</td><td>0.00819</td><td>0.00846</td></tr><tr><td>11</td><td>7.62</td><td>0.0869</td><td>0.0276</td><td>0.0136</td><td>0.00864</td><td>0.0065</td><td>0.00552</td><td>0.00513</td><td>0.00509</td></tr><tr><td>12</td><td>8.32</td><td>0.08</td><td>0.0236</td><td>0.0108</td><td>0.00646</td><td>0.00459</td><td>0.00371</td><td>0.00329</td><td>0.00314</td></tr><tr><td>13</td><td>9.01</td><td>0.074</td><td>0.0203</td><td>0.00875</td><td>0.00492</td><td>0.00332</td><td>0.00255</td><td>0.00217</td><td>0.00199</td></tr><tr><td>14</td><td>9.7</td><td>0.0689</td><td>0.0177</td><td>0.00718</td><td>0.00381</td><td>0.00244</td><td>0.00179</td><td>0.00146</td><td>0.00129</td></tr><tr><td>15</td><td>10.4</td><td>0.0645</td><td>0.0156</td><td>0.00596</td><td>0.003</td><td>0.00183</td><td>0.00128</td><td>0.001</td><td>0.000852</td></tr><tr><td>16</td><td>11.1</td><td>0.0606</td><td>0.0138</td><td>0.005</td><td>0.00239</td><td>0.00139</td><td>0.000935</td><td>0.000702</td><td>0.000574</td></tr><tr><td>17</td><td>11.8</td><td>0.0571</td><td>0.0123</td><td>0.00423</td><td>0.00193</td><td>0.00107</td><td>0.000692</td><td>0.000499</td><td>0.000394</td></tr><tr><td>18</td><td>12.5</td><td>0.054</td><td>0.0111</td><td>0.00362</td><td>0.00158</td><td>0.000839</td><td>0.000519</td><td>0.00036</td><td>0.000275</td></tr><tr><td>19</td><td>13.2</td><td>0.0513</td><td>0.00998</td><td>0.00312</td><td>0.0013</td><td>0.000663</td><td>0.000394</td><td>0.000264</td><td>0.000194</td></tr><tr><td>20</td><td>13.9</td><td>0.0488</td><td>0.00906</td><td>0.0027</td><td>0.00108</td><td>0.00053</td><td>0.000303</td><td>0.000196</td><td>0.00014</td></tr><tr><td>21</td><td>14.6</td><td>0.0465</td><td>0.00825</td><td>0.00236</td><td>0.000905</td><td>0.000427</td><td>0.000236</td><td>0.000147</td><td>0.000101</td></tr><tr><td>22</td><td>15.2</td><td>0.0444</td><td>0.00755</td><td>0.00207</td><td>0.000764</td><td>0.000347</td><td>0.000185</td><td>0.000112</td><td>7.46e-05</td></tr><tr><td>23</td><td>15.9</td><td>0.0425</td><td>0.00694</td><td>0.00183</td><td>0.000649</td><td>0.000285</td><td>0.000147</td><td>8.56e-05</td><td>5.55e-05</td></tr><tr><td>24</td><td>16.6</td><td>0.0408</td><td>0.00639</td><td>0.00162</td><td>0.000555</td><td>0.000235</td><td>0.000117</td><td>6.63e-05</td><td>4.17e-05</td></tr><tr><td>25</td><td>17.3</td><td>0.0392</td><td>0.00591</td><td>0.00145</td><td>0.000478</td><td>0.000196</td><td>9.44e-05</td><td>5.18e-05</td><td>3.16e-05</td></tr><tr><td>26</td><td>18</td><td>0.0377</td><td>0.00548</td><td>0.00129</td><td>0.000413</td><td>0.000164</td><td>7.66e-05</td><td>4.08e-05</td><td>2.42e-05</td></tr><tr><td>27</td><td>18.7</td><td>0.0364</td><td>0.0051</td><td>0.00116</td><td>0.000359</td><td>0.000138</td><td>6.26e-05</td><td>3.24e-05</td><td>1.87e-05</td></tr><tr><td>28</td><td>19.4</td><td>0.0351</td><td>0.00475</td><td>0.00105</td><td>0.000314</td><td>0.000117</td><td>5.15e-05</td><td>2.59e-05</td><td>1.46e-05</td></tr><tr><td>29</td><td>20.1</td><td>0.0339</td><td>0.00444</td><td>0.000949</td><td>0.000276</td><td>9.96e-05</td><td>4.26e-05</td><td>2.09e-05</td><td>1.14e-05</td></tr><tr><td>30</td><td>20.8</td><td>0.0328</td><td>0.00416</td><td>0.000862</td><td>0.000243</td><td>8.53e-05</td><td>3.55e-05</td><td>1.69e-05</td><td>9.01e-06</td></tr><tr><td>31</td><td>21.5</td><td>0.0317</td><td>0.0039</td><td>0.000785</td><td>0.000215</td><td>7.33e-05</td><td>2.97e-05</td><td>1.38e-05</td><td>7.16e-06</td></tr><tr><td>32</td><td>22.2</td><td>0.0308</td><td>0.00367</td><td>0.000717</td><td>0.000191</td><td>6.33e-05</td><td>2.5e-05</td><td>1.13e-05</td><td>5.73e-06</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th><em>m</em>/<em>n</em></th><th><em>k</em></th><th><em>k</em>=9</th><th><em>k</em>=10</th><th><em>k</em>=11</th><th><em>k</em>=12</th><th><em>k</em>=13</th><th><em>k</em>=14</th><th><em>k</em>=15</th><th><em>k</em>=16</th></tr></thead><tbody><tr><td>11</td><td>7.62</td><td>0.00531</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>12</td><td>8.32</td><td>0.00317</td><td>0.00334</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>13</td><td>9.01</td><td>0.00194</td><td>0.00198</td><td>0.0021</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>14</td><td>9.7</td><td>0.00121</td><td>0.0012</td><td>0.00124</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>15</td><td>10.4</td><td>0.000775</td><td>0.000744</td><td>0.000747</td><td>0.000778</td><td></td><td></td><td></td><td></td></tr><tr><td>16</td><td>11.1</td><td>0.000505</td><td>0.00047</td><td>0.000459</td><td>0.000466</td><td>0.000488</td><td></td><td></td><td></td></tr><tr><td>17</td><td>11.8</td><td>0.000335</td><td>0.000302</td><td>0.000287</td><td>0.000284</td><td>0.000291</td><td></td><td></td><td></td></tr><tr><td>18</td><td>12.5</td><td>0.000226</td><td>0.000198</td><td>0.000183</td><td>0.000176</td><td>0.000176</td><td>0.000182</td><td></td><td></td></tr><tr><td>19</td><td>13.2</td><td>0.000155</td><td>0.000132</td><td>0.000118</td><td>0.000111</td><td>0.000109</td><td>0.00011</td><td>0.000114</td><td></td></tr><tr><td>20</td><td>13.9</td><td>0.000108</td><td>8.89e-05</td><td>7.77e-05</td><td>7.12e-05</td><td>6.79e-05</td><td>6.71e-05</td><td>6.84e-05</td><td></td></tr><tr><td>21</td><td>14.6</td><td>7.59e-05</td><td>6.09e-05</td><td>5.18e-05</td><td>4.63e-05</td><td>4.31e-05</td><td>4.17e-05</td><td>4.16e-05</td><td>4.27e-05</td></tr><tr><td>22</td><td>15.2</td><td>5.42e-05</td><td>4.23e-05</td><td>3.5e-05</td><td>3.05e-05</td><td>2.78e-05</td><td>2.63e-05</td><td>2.57e-05</td><td>2.59e-05</td></tr><tr><td>23</td><td>15.9</td><td>3.92e-05</td><td>2.97e-05</td><td>2.4e-05</td><td>2.04e-05</td><td>1.81e-05</td><td>1.68e-05</td><td>1.61e-05</td><td>1.59e-05</td></tr><tr><td>24</td><td>16.6</td><td>2.86e-05</td><td>2.11e-05</td><td>1.66e-05</td><td>1.38e-05</td><td>1.2e-05</td><td>1.08e-05</td><td>1.02e-05</td><td>9.87e-06</td></tr><tr><td>25</td><td>17.3</td><td>2.11e-05</td><td>1.52e-05</td><td>1.16e-05</td><td>9.42e-06</td><td>8.01e-06</td><td>7.1e-06</td><td>6.54e-06</td><td>6.22e-06</td></tr><tr><td>26</td><td>18</td><td>1.57e-05</td><td>1.1e-05</td><td>8.23e-06</td><td>6.52e-06</td><td>5.42e-06</td><td>4.7e-06</td><td>4.24e-06</td><td>3.96e-06</td></tr><tr><td>27</td><td>18.7</td><td>1.18e-05</td><td>8.07e-06</td><td>5.89e-06</td><td>4.56e-06</td><td>3.7e-06</td><td>3.15e-06</td><td>2.79e-06</td><td>2.55e-06</td></tr><tr><td>28</td><td>19.4</td><td>8.96e-06</td><td>5.97e-06</td><td>4.25e-06</td><td>3.22e-06</td><td>2.56e-06</td><td>2.13e-06</td><td>1.85e-06</td><td>1.66e-06</td></tr><tr><td>29</td><td>20.1</td><td>6.85e-06</td><td>4.45e-06</td><td>3.1e-06</td><td>2.29e-06</td><td>1.79e-06</td><td>1.46e-06</td><td>1.24e-06</td><td>1.09e-06</td></tr><tr><td>30</td><td>20.8</td><td>5.28e-06</td><td>3.35e-06</td><td>2.28e-06</td><td>1.65e-06</td><td>1.26e-06</td><td>1.01e-06</td><td>8.39e-06</td><td>7.26e-06</td></tr><tr><td>31</td><td>21.5</td><td>4.1e-06</td><td>2.54e-06</td><td>1.69e-06</td><td>1.2e-06</td><td>8.93e-07</td><td>7e-07</td><td>5.73e-07</td><td>4.87e-07</td></tr><tr><td>32</td><td>22.2</td><td>3.2e-06</td><td>1.94e-06</td><td>1.26e-06</td><td>8.74e-07</td><td>6.4e-07</td><td>4.92e-07</td><td>3.95e-07</td><td>3.3e-07</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th><em>m</em>/<em>n</em></th><th><em>k</em></th><th><em>k</em>=17</th><th><em>k</em>=18</th><th><em>k</em>=19</th><th><em>k</em>=20</th><th><em>k</em>=21</th><th><em>k</em>=22</th><th><em>k</em>=23</th><th><em>k</em>=24</th></tr></thead><tbody><tr><td>22</td><td>15.2</td><td>2.67e-05</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>23</td><td>15.9</td><td>1.61e-05</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>24</td><td>16.6</td><td>9.84e-06</td><td>1e-05</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>25</td><td>17.3</td><td>6.08e-06</td><td>6.11e-06</td><td>6.27e-06</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>26</td><td>18</td><td>3.81e-06</td><td>3.76e-06</td><td>3.8e-06</td><td>3.92e-06</td><td></td><td></td><td></td><td></td></tr><tr><td>27</td><td>18.7</td><td>2.41e-06</td><td>2.34e-06</td><td>2.33e-06</td><td>2.37e-06</td><td></td><td></td><td></td><td></td></tr><tr><td>28</td><td>19.4</td><td>1.54e-06</td><td>1.47e-06</td><td>1.44e-06</td><td>1.44e-06</td><td>1.48e-06</td><td></td><td></td><td></td></tr><tr><td>29</td><td>20.1</td><td>9.96e-07</td><td>9.35e-07</td><td>9.01e-07</td><td>8.89e-07</td><td>8.96e-07</td><td>9.21e-07</td><td></td><td></td></tr><tr><td>30</td><td>20.8</td><td>6.5e-07</td><td>6e-07</td><td>5.69e-07</td><td>5.54e-07</td><td>5.5e-07</td><td>5.58e-07</td><td></td><td></td></tr><tr><td>31</td><td>21.5</td><td>4.29e-07</td><td>3.89e-07</td><td>3.63e-07</td><td>3.48e-07</td><td>3.41e-07</td><td>3.41e-07</td><td>3.48e-07</td><td></td></tr><tr><td>32</td><td>22.2</td><td>2.85e-07</td><td>2.55e-07</td><td>2.34e-07</td><td>2.21e-07</td><td>2.13e-07</td><td>2.1e-07</td><td>2.12e-07</td><td>2.17e-07</td></tr></tbody></table></div><h2 id="四、参考"><a href="#四、参考" class="headerlink" title="四、参考"></a>四、参考</h2><p>【0】数学之美 （第三版）</p><p>【1】<a href="https://www.jianshu.com/p/25f0139637b7">markdown中公式编辑教程</a></p><p>【2】<a href="http://pages.cs.wisc.edu/~cao/papers/summary-cache/node8.html">Bloom Filters - the math</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;布隆过滤器&quot;&gt;&lt;a href=&quot;#布隆过滤器&quot; class=&quot;headerlink&quot; title=&quot;布隆过滤器&quot;&gt;&lt;/a&gt;布隆过滤器&lt;/h1&gt;&lt;h2 id=&quot;一、简介&quot;&gt;&lt;a href=&quot;#一、简介&quot; class=&quot;headerlink&quot; title=&quot;一、简介&quot;</summary>
      
    
    
    
    <category term="Math" scheme="https://www.delta1037.cn/categories/Math/"/>
    
    
    <category term="Math" scheme="https://www.delta1037.cn/tags/Math/"/>
    
  </entry>
  
  <entry>
    <title>最大熵模型</title>
    <link href="https://www.delta1037.cn/2020/Math/%E6%9C%80%E5%A4%A7%E7%86%B5%E6%A8%A1%E5%9E%8B/"/>
    <id>https://www.delta1037.cn/2020/Math/%E6%9C%80%E5%A4%A7%E7%86%B5%E6%A8%A1%E5%9E%8B/</id>
    <published>2020-12-11T14:16:31.000Z</published>
    <updated>2020-12-11T17:31:07.257Z</updated>
    
    <content type="html"><![CDATA[<h1 id="最大熵模型"><a href="#最大熵模型" class="headerlink" title="最大熵模型"></a>最大熵模型</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;最大熵模型&quot;&gt;&lt;a href=&quot;#最大熵模型&quot; class=&quot;headerlink&quot; title=&quot;最大熵模型&quot;&gt;&lt;/a&gt;最大熵模型&lt;/h1&gt;</summary>
      
    
    
    
    <category term="Math" scheme="https://www.delta1037.cn/categories/Math/"/>
    
    
    <category term="Math" scheme="https://www.delta1037.cn/tags/Math/"/>
    
  </entry>
  
  <entry>
    <title>经济学十大原理</title>
    <link href="https://www.delta1037.cn/2020/Economics/%E7%BB%8F%E6%B5%8E%E5%AD%A6%E5%8D%81%E5%A4%A7%E5%8E%9F%E7%90%86/"/>
    <id>https://www.delta1037.cn/2020/Economics/%E7%BB%8F%E6%B5%8E%E5%AD%A6%E5%8D%81%E5%A4%A7%E5%8E%9F%E7%90%86/</id>
    <published>2020-12-09T14:32:31.000Z</published>
    <updated>2020-12-11T17:31:04.603Z</updated>
    
    <content type="html"><![CDATA[<h1 id="经济学十大原理"><a href="#经济学十大原理" class="headerlink" title="经济学十大原理"></a>经济学十大原理</h1><h2 id="一、十大原理分类"><a href="#一、十大原理分类" class="headerlink" title="一、十大原理分类"></a>一、十大原理分类</h2><h3 id="1-1-人们如何做出决策"><a href="#1-1-人们如何做出决策" class="headerlink" title="1.1 人们如何做出决策"></a>1.1 人们如何做出决策</h3><h4 id="原理一：人们面临权衡取舍"><a href="#原理一：人们面临权衡取舍" class="headerlink" title="原理一：人们面临权衡取舍"></a>原理一：人们面临权衡取舍</h4><p>为了得到一件喜爱的东西，我们通常不得不放弃另一件喜爱的东西。做出决策就是要求我们在一个目标与另一个目标之间进行权衡取舍。</p><p>人们只有了解面临的选择，才有可能做出良好的决策。</p><h4 id="原理二：某种东西的成本是为了得到它所放弃的东西"><a href="#原理二：某种东西的成本是为了得到它所放弃的东西" class="headerlink" title="原理二：某种东西的成本是为了得到它所放弃的东西"></a>原理二：某种东西的成本是为了得到它所放弃的东西</h4><p>一种东西的<strong>机会成本</strong>是为了得到这种东西所放弃的东西</p><h4 id="原理三：理性人考虑边际量"><a href="#原理三：理性人考虑边际量" class="headerlink" title="原理三：理性人考虑边际量"></a>原理三：理性人考虑边际量</h4><p>理性人通常比较边际收益与边际成本来做决策。当且仅当一种行为的边际收益大于边际成本时，一个理性的决策者才会采取这种行为。</p><h4 id="原理四：人们会对激励做出反应"><a href="#原理四：人们会对激励做出反应" class="headerlink" title="原理四：人们会对激励做出反应"></a>原理四：人们会对激励做出反应</h4><p><strong>激励</strong>是引起一个人做出某种行为的东西（例如惩罚或奖励的预期）。由于理性人会通过比较成本与收益做出决策，所以他们会对激励做出反应</p><h3 id="1-2-人们如何互相影响"><a href="#1-2-人们如何互相影响" class="headerlink" title="1.2 人们如何互相影响"></a>1.2 人们如何互相影响</h3><h4 id="原理五：贸易可以使每个人的情况都变得更好"><a href="#原理五：贸易可以使每个人的情况都变得更好" class="headerlink" title="原理五：贸易可以使每个人的情况都变得更好"></a>原理五：贸易可以使每个人的情况都变得更好</h4><p>贸易可以使得每个人做自己擅长的活动。通过与其他人贸易，人们可以以较低的成本获得各种各样的物品与服务。</p><h4 id="原理六：市场通常是组织经济活动的一种-好方法"><a href="#原理六：市场通常是组织经济活动的一种-好方法" class="headerlink" title="原理六：市场通常是组织经济活动的一种 好方法"></a>原理六：市场通常是组织经济活动的一种 好方法</h4><p><strong>市场经济</strong>：许多家庭和企业在物品与服务市场上互相交易时，通过他们的分散决策配置资源的经济。</p><p>家庭和企业在市场上互相交易，他们仿佛被一只“看不见的手”所指引，并导致了合意的市场结果。</p><h4 id="原理七：政府优势可以改善市场的结果"><a href="#原理七：政府优势可以改善市场的结果" class="headerlink" title="原理七：政府优势可以改善市场的结果"></a>原理七：政府优势可以改善市场的结果</h4><p>看不见的手是强有力的，但并不是无所不能的。政府干预经济并改变人们自己选择的资源配置的原因有两类：促进效率或促进平等。也就是说，大多数政策目标是要么把经济蛋糕做大，要么改变这个蛋糕的分割方式。</p><h3 id="1-3-整体经济如何运行"><a href="#1-3-整体经济如何运行" class="headerlink" title="1.3 整体经济如何运行"></a>1.3 整体经济如何运行</h3><h4 id="原理八：一国的生活水平取决于它生产物品与服务能力"><a href="#原理八：一国的生活水平取决于它生产物品与服务能力" class="headerlink" title="原理八：一国的生活水平取决于它生产物品与服务能力"></a>原理八：一国的生活水平取决于它生产物品与服务能力</h4><p>生活水平的差别可以归结于<strong>生产率</strong>的差别，即每一单位劳动投入所生产的物品与服务数量的差别。</p><h4 id="原理九：当政府发行了过多的货币时，物价上升"><a href="#原理九：当政府发行了过多的货币时，物价上升" class="headerlink" title="原理九：当政府发行了过多的货币时，物价上升"></a>原理九：当政府发行了过多的货币时，物价上升</h4><p>通货膨胀是物价总水平的上升。大多数严重或者持续的通货膨胀情况下，罪魁祸首是货币的增长。</p><h4 id="原理十：社会面临通货膨胀与失业之间的短期权衡取舍"><a href="#原理十：社会面临通货膨胀与失业之间的短期权衡取舍" class="headerlink" title="原理十：社会面临通货膨胀与失业之间的短期权衡取舍"></a>原理十：社会面临通货膨胀与失业之间的短期权衡取舍</h4><p>长期中，物价水平的上升主要是货币量增加的结果</p><p>货币注入的短期效应：</p><ul><li>经济中货币的增加刺激了社会的整体支出水平，从而增加了对物品和服务的需求</li><li>需求的增加随着时间的推移，会引起企业提高物价，但同时，它也鼓励企业雇佣更多的工人，并生产更多的物品与服务</li><li>雇佣更多的工人意味着更少的失业</li></ul><h2 id="二、参考文献"><a href="#二、参考文献" class="headerlink" title="二、参考文献"></a>二、参考文献</h2><p>【0】经济学原理 微观经济学分册</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;经济学十大原理&quot;&gt;&lt;a href=&quot;#经济学十大原理&quot; class=&quot;headerlink&quot; title=&quot;经济学十大原理&quot;&gt;&lt;/a&gt;经济学十大原理&lt;/h1&gt;&lt;h2 id=&quot;一、十大原理分类&quot;&gt;&lt;a href=&quot;#一、十大原理分类&quot; class=&quot;headerli</summary>
      
    
    
    
    <category term="经济学" scheme="https://www.delta1037.cn/categories/%E7%BB%8F%E6%B5%8E%E5%AD%A6/"/>
    
    
    <category term="经济学" scheme="https://www.delta1037.cn/tags/%E7%BB%8F%E6%B5%8E%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>fcntl</title>
    <link href="https://www.delta1037.cn/2020/Linux/Linux_fcntl/"/>
    <id>https://www.delta1037.cn/2020/Linux/Linux_fcntl/</id>
    <published>2020-12-04T14:08:31.000Z</published>
    <updated>2020-12-11T17:31:07.109Z</updated>
    
    <content type="html"><![CDATA[<h1 id="fcntl"><a href="#fcntl" class="headerlink" title="fcntl"></a>fcntl</h1><p>fcntl针对描述符提供控制，可以用来改变已打开文件的性质</p><h2 id="一、函数定义"><a href="#一、函数定义" class="headerlink" title="一、函数定义"></a>一、函数定义</h2><p>函数接口定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fcntl</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> cmd)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 针对cmd的值，可以使用第三个参数arg/lock</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fcntl</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> cmd, <span class="keyword">long</span> arg)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fcntl</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> cmd, struct flock *lock)</span></span>;</span><br></pre></td></tr></table></figure><p>函数参数结构定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">flcok</span> &#123;</span></span><br><span class="line">　　 <span class="keyword">short</span> <span class="keyword">int</span> l_type; <span class="comment">/* 锁类型：F_RDLCK, F_WRLCK, F_UNLCK */</span></span><br><span class="line">　　 <span class="keyword">short</span> <span class="keyword">int</span> l_whence;<span class="comment">/* 锁定开始位置：SEEK_SET, SEEK_CUR, SEEK_END */</span></span><br><span class="line">　　 <span class="keyword">off_t</span> l_start; <span class="comment">/* 锁定开始计算位置：relative starting offset in bytes */</span></span><br><span class="line">　　 <span class="keyword">off_t</span> l_len; <span class="comment">/* 锁定长度：#bytes; 0 means EOF */</span></span><br><span class="line">　　 <span class="keyword">pid_t</span> l_pid; <span class="comment">/* PID returned by F_GETLK */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 注：开始位置是由l_whence和l_start共同指定的</span></span><br><span class="line"><span class="comment">// l_whence指定了l_start开始计算的位置</span></span><br></pre></td></tr></table></figure><p>函数参数解释：</p><ul><li>fd是要改变的描述符（已打开的文件等）</li><li><p>cmd：操作指定，包含如下几种</p><ul><li><code>F_DUPFD</code>：复制一个现有的描述符</li><li><code>F_GETFD</code>/<code>F_SETFD</code>：获得／设置文件描述符标记</li><li><code>F_GETFL</code>/<code>F_SETFL</code>：获得／设置文件状态标记</li><li><code>F_GETOWN</code>/<code>F_SETOWN</code>：获得／设置异步I/O所有权</li><li><code>F_GETLK</code>、<code>F_SETLK/F_SETLKW</code>：获得／设置记录锁</li></ul></li><li><p>arg/lock：针对cmd的值，需要的第三个参数</p></li></ul><h2 id="二、应用场景"><a href="#二、应用场景" class="headerlink" title="二、应用场景"></a>二、应用场景</h2><h3 id="2-1-记录上锁"><a href="#2-1-记录上锁" class="headerlink" title="2.1 记录上锁"></a>2.1 记录上锁</h3><p>记录上锁使用如下接口：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fcntl</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> cmd, ... <span class="comment">/* struct flock *lock */</span>)</span></span>;</span><br><span class="line"><span class="comment">/* 成功返回值取决于cmd，失败返回-1 */</span></span><br></pre></td></tr></table></figure><p>记录上锁使用cmd的类型：<code>F_GETLK</code>、<code>F_SETLK/F_SETLKW</code></p><ul><li>F_GETLK：</li><li>F_SETLK：</li><li>F_SETLKW：</li></ul><h2 id="三、参考文献"><a href="#三、参考文献" class="headerlink" title="三、参考文献"></a>三、参考文献</h2><p>【0】Unix网络编程</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;fcntl&quot;&gt;&lt;a href=&quot;#fcntl&quot; class=&quot;headerlink&quot; title=&quot;fcntl&quot;&gt;&lt;/a&gt;fcntl&lt;/h1&gt;&lt;p&gt;fcntl针对描述符提供控制，可以用来改变已打开文件的性质&lt;/p&gt;
&lt;h2 id=&quot;一、函数定义&quot;&gt;&lt;a href=</summary>
      
    
    
    
    <category term="Linux" scheme="https://www.delta1037.cn/categories/Linux/"/>
    
    
    <category term="Linux" scheme="https://www.delta1037.cn/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>ioctl</title>
    <link href="https://www.delta1037.cn/2020/Linux/Linux_ioctl/"/>
    <id>https://www.delta1037.cn/2020/Linux/Linux_ioctl/</id>
    <published>2020-12-04T14:08:31.000Z</published>
    <updated>2020-12-11T17:31:06.947Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ioctl"><a href="#ioctl" class="headerlink" title="ioctl"></a>ioctl</h1><p>ioctl()系统调用为<strong>执行文件</strong>和<strong>设备操作</strong>提供了一种多用途机制</p><h2 id="一、接口定义"><a href="#一、接口定义" class="headerlink" title="一、接口定义"></a>一、接口定义</h2><p>ioctl接口定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ioctl</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> request, ... <span class="comment">/* argp */</span>)</span></span></span><br></pre></td></tr></table></figure><p>接口参数说明：</p><ul><li>fd：某个设备或者文件已经打开的文件描述符</li><li><p>request：将在fd上执行的控制操作（<strong>具体设备的头文件</strong>定义了可以传递给request参数的常量）</p></li><li><p>argp：argp的值的类型是由request的参数值确定的，类型如下：</p><ul><li>不需要该参数（哈哈哈没想到吧）</li><li>指向整数或者结构的指针</li></ul></li></ul><h2 id="二、应用场景"><a href="#二、应用场景" class="headerlink" title="二、应用场景"></a>二、应用场景</h2><h2 id="三、参考文献"><a href="#三、参考文献" class="headerlink" title="三、参考文献"></a>三、参考文献</h2><p>【0】Linux/UNIX系统编程手册</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;ioctl&quot;&gt;&lt;a href=&quot;#ioctl&quot; class=&quot;headerlink&quot; title=&quot;ioctl&quot;&gt;&lt;/a&gt;ioctl&lt;/h1&gt;&lt;p&gt;ioctl()系统调用为&lt;strong&gt;执行文件&lt;/strong&gt;和&lt;strong&gt;设备操作&lt;/strong&gt;提供了</summary>
      
    
    
    
    <category term="Linux" scheme="https://www.delta1037.cn/categories/Linux/"/>
    
    
    <category term="Linux" scheme="https://www.delta1037.cn/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux终端动态刷新</title>
    <link href="https://www.delta1037.cn/2020/Linux/Linux%E7%BB%88%E7%AB%AF%E5%8A%A8%E6%80%81%E5%88%B7%E6%96%B0/"/>
    <id>https://www.delta1037.cn/2020/Linux/Linux%E7%BB%88%E7%AB%AF%E5%8A%A8%E6%80%81%E5%88%B7%E6%96%B0/</id>
    <published>2020-12-03T11:16:31.000Z</published>
    <updated>2020-12-11T17:31:06.003Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux终端动态刷新"><a href="#Linux终端动态刷新" class="headerlink" title="Linux终端动态刷新"></a>Linux终端动态刷新</h1><h2 id="一、代码片段"><a href="#一、代码片段" class="headerlink" title="一、代码片段"></a>一、代码片段</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CStat::runtimePrintBuf</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; &amp;buf)</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> last_print_lines = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; last_print_lines; ++i)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\033[1A&quot;</span>); <span class="comment">//先回到上一行</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\033[K&quot;</span>);  <span class="comment">//清除该行</span></span><br><span class="line">    &#125;</span><br><span class="line">    last_print_lines = buf.size();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;it : buf)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, it.c_str());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二、相关知识"><a href="#二、相关知识" class="headerlink" title="二、相关知识"></a>二、相关知识</h2><h3 id="2-1-终端颜色字符"><a href="#2-1-终端颜色字符" class="headerlink" title="2.1 终端颜色字符"></a>2.1 终端颜色字符</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 字体颜色控制</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;\033[30m 黑色字 \033[0m&quot;</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;\033[31m 红色字 \033[0m&quot;</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;\033[32m 绿色字 \033[0m&quot;</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;\033[33m 黄色字 \033[0m&quot;</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;\033[34m 蓝色字 \033[0m&quot;</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;\033[35m 紫色字 \033[0m&quot;</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;\033[36m 天蓝字 \033[0m&quot;</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;\033[37m 白色字 \033[0m&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 字体背景颜色和字体颜色</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;\033[40;37m 黑底白字 \033[0m&quot;</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;\033[41;37m 红底白字 \033[0m&quot;</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;\033[42;37m 绿底白字 \033[0m&quot;</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;\033[43;37m 黄底白字 \033[0m&quot;</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;\033[44;37m 蓝底白字 \033[0m&quot;</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;\033[45;37m 紫底白字 \033[0m&quot;</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;\033[46;37m 天蓝底白字 \033[0m&quot;</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;\033[47;30m 白底黑字 \033[0m&quot;</span></span><br></pre></td></tr></table></figure><h3 id="2-2-终端控制字符"><a href="#2-2-终端控制字符" class="headerlink" title="2.2 终端控制字符"></a>2.2 终端控制字符</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">\33[0m 关闭所有属性 </span><br><span class="line">\33[1m 设置高亮度 </span><br><span class="line">\33[4m 下划线 </span><br><span class="line">\33[5m 闪烁 </span><br><span class="line">\33[7m 反显 </span><br><span class="line">\33[8m 消隐 </span><br><span class="line">\33[30m — \33[37m 设置前景色 </span><br><span class="line">\33[40m — \33[47m 设置背景色 </span><br><span class="line">\33[nA 光标上移n行 </span><br><span class="line">\33[nB 光标下移n行 </span><br><span class="line">\33[nC 光标右移n行 </span><br><span class="line">\33[nD 光标左移n行 </span><br><span class="line">\33[y;xH设置光标位置 </span><br><span class="line">\33[2J 清屏 </span><br><span class="line">\33[K 清除从光标到行尾的内容 </span><br><span class="line">\33[s 保存光标位置 </span><br><span class="line">\33[u 恢复光标位置 </span><br><span class="line">\33[?25l 隐藏光标 </span><br><span class="line">\33[?25h 显示光标</span><br></pre></td></tr></table></figure><p>在C语言中使用终端控制字符，如上代码片段所示</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\033[1A&quot;</span>); <span class="comment">//先回到上一行</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\033[K&quot;</span>);  <span class="comment">//清除该行</span></span><br></pre></td></tr></table></figure><h2 id="三、参考"><a href="#三、参考" class="headerlink" title="三、参考"></a>三、参考</h2><p>【0】<a href="https://www.cnblogs.com/lr-ting/archive/2013/02/28/2936792.html">shell脚本中echo显示内容带颜色</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Linux终端动态刷新&quot;&gt;&lt;a href=&quot;#Linux终端动态刷新&quot; class=&quot;headerlink&quot; title=&quot;Linux终端动态刷新&quot;&gt;&lt;/a&gt;Linux终端动态刷新&lt;/h1&gt;&lt;h2 id=&quot;一、代码片段&quot;&gt;&lt;a href=&quot;#一、代码片段&quot; cla</summary>
      
    
    
    
    <category term="Linux" scheme="https://www.delta1037.cn/categories/Linux/"/>
    
    
    <category term="Linux" scheme="https://www.delta1037.cn/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux C语言实现按键即时识别</title>
    <link href="https://www.delta1037.cn/2020/Linux/Linux%E8%AF%86%E5%88%AB%E6%8C%89%E9%94%AE/"/>
    <id>https://www.delta1037.cn/2020/Linux/Linux%E8%AF%86%E5%88%AB%E6%8C%89%E9%94%AE/</id>
    <published>2020-12-03T11:16:31.000Z</published>
    <updated>2020-12-11T17:31:05.613Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux-C语言实现按键即时识别"><a href="#Linux-C语言实现按键即时识别" class="headerlink" title="Linux C语言实现按键即时识别"></a>Linux C语言实现按键即时识别</h1><p>top中的源代码，慢慢理解。。。<br><strong>不需要按ENTER键，按下即可识别</strong></p><h2 id="一、代码片段"><a href="#一、代码片段" class="headerlink" title="一、代码片段"></a>一、代码片段</h2><p>部分摘自top源代码，部分来源于网络博客</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;termios.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* The original and new terminal attributes */</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">termios</span> <span class="title">Savedtty</span>,</span></span><br><span class="line"><span class="class">                      <span class="title">Rawtty</span>;</span></span><br><span class="line"><span class="comment">// 设置终端相关属性</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">initKeyboard</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tcgetattr(<span class="number">0</span>,&amp;Savedtty);</span><br><span class="line">    Rawtty = Savedtty;</span><br><span class="line">    Rawtty.c_lflag &amp;= ~ICANON;    <span class="comment">// 设置不以规范模式工作，读请求直接从队列读取字符，至少接到MIN字节或者两个字节之间超时值TIME到期时，read才返回</span></span><br><span class="line">    Rawtty.c_lflag &amp;= ~ECHO;      <span class="comment">// 关闭输入字符回显到终端设备</span></span><br><span class="line">    <span class="comment">// Rawtty.c_lflag &amp;= ~ISIG;   // 判断输入字符是否要产生终端信号的特殊字符</span></span><br><span class="line">    Rawtty.c_cc[VMIN] = <span class="number">1</span>;        <span class="comment">// 至少接到MIN字节</span></span><br><span class="line">    Rawtty.c_cc[VTIME] = <span class="number">0</span>;       <span class="comment">// 两个字节之间超时值TIME</span></span><br><span class="line">    tcsetattr(<span class="number">0</span>, TCSANOW, &amp;Rawtty);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 恢复终端属性</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">closeKeyboard</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tcsetattr(<span class="number">0</span>, TCSANOW, &amp;Savedtty);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 读取字符</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">chin</span> <span class="params">(<span class="keyword">int</span> ech, <span class="keyword">char</span> *buf, <span class="keyword">unsigned</span> cnt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> rc;</span><br><span class="line">   fflush(<span class="built_in">stdout</span>);</span><br><span class="line">   <span class="keyword">if</span> (!ech)</span><br><span class="line">      rc = read(STDIN_FILENO, buf, cnt);</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">      tcsetattr(STDIN_FILENO, TCSAFLUSH, &amp;Savedtty);</span><br><span class="line">      rc = read(STDIN_FILENO, buf, cnt);</span><br><span class="line">      tcsetattr(STDIN_FILENO, TCSAFLUSH, &amp;Rawtty);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// may be the beginning of a lengthy escape sequence</span></span><br><span class="line">   tcflush(STDIN_FILENO, TCIFLUSH);</span><br><span class="line">   <span class="keyword">return</span> rc;                   <span class="comment">// note: we do NOT produce a vaid &#x27;string&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断读取字符的有效性</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">char</span> <span class="title">kbhit</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> file_flags;</span><br><span class="line">    <span class="keyword">int</span> rc;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    fd_set fs;</span><br><span class="line">    FD_ZERO(&amp;fs);</span><br><span class="line">    FD_SET(STDIN_FILENO, &amp;fs);</span><br><span class="line">    file_flags = fcntl(STDIN_FILENO, F_GETFL);</span><br><span class="line">    <span class="keyword">if</span>(file_flags==<span class="number">-1</span>) file_flags=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    fcntl(STDIN_FILENO, F_SETFL, O_NONBLOCK|file_flags);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// check 1st, in case tv zeroed (by sig handler) before it got set</span></span><br><span class="line">    rc = chin(<span class="number">0</span>, &amp;c, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (rc &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// EOF is pretty much a &quot;can&#x27;t happen&quot; except for a kernel bug.</span></span><br><span class="line">        <span class="comment">// We should quickly die via SIGHUP, and thus not spin here.</span></span><br><span class="line">        <span class="comment">// if (rc == 0) end_pgm(0); /* EOF from terminal */</span></span><br><span class="line">        fcntl(STDIN_FILENO, F_SETFL, file_flags);</span><br><span class="line">        select(<span class="number">1</span>, &amp;fs, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">        fcntl(STDIN_FILENO, F_SETFL, O_NONBLOCK|file_flags);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (chin(<span class="number">0</span>, &amp;c, <span class="number">1</span>) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        fcntl(STDIN_FILENO, F_SETFL, file_flags);</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fcntl(STDIN_FILENO, F_SETFL, file_flags);</span><br><span class="line">    &#125;</span><br><span class="line">    kbhit();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#<span class="meta"># use</span></span><br><span class="line">initKeyboard();</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">   <span class="keyword">char</span> input = kbhit();</span><br><span class="line">   <span class="keyword">if</span>( input == <span class="string">&#x27;q&#x27;</span>)&#123;</span><br><span class="line">       <span class="comment">// do something</span></span><br><span class="line">       <span class="keyword">break</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">closeKeyboard();</span><br></pre></td></tr></table></figure><h2 id="二、相关知识"><a href="#二、相关知识" class="headerlink" title="二、相关知识"></a>二、相关知识</h2><h3 id="2-1-终端相关"><a href="#2-1-终端相关" class="headerlink" title="2.1 终端相关"></a>2.1 终端相关</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;termios.h&gt;</span></span></span><br><span class="line"><span class="comment">// 终端属性结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">termios</span>&#123;</span></span><br><span class="line">    <span class="keyword">tcflag_t</span> c_iflag;<span class="comment">// 输入标志</span></span><br><span class="line">    <span class="keyword">tcflag_t</span> c_oflag;<span class="comment">// 输出标志</span></span><br><span class="line">    <span class="keyword">tcflag_t</span> c_cflag;<span class="comment">// 控制标志</span></span><br><span class="line">    <span class="keyword">tcflag_t</span> c_lflag;<span class="comment">// 本地标志</span></span><br><span class="line">    <span class="keyword">cc_t</span>     c_cc[NCCS];<span class="comment">// 控制字符</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取终端的属性</span></span><br><span class="line">tcgetattr(<span class="keyword">int</span> fd, struct termios* tty_struct);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置终端属性</span></span><br><span class="line">tcsetattr(<span class="keyword">int</span> fd, <span class="keyword">int</span> opt, <span class="keyword">const</span> struct termios* tty_struct);</span><br></pre></td></tr></table></figure><p>tcsetattr的opt参数指定新设置的终端属性什么时候起作用</p><ul><li>TCSANOW：更改立即发生</li><li>TCSADRAIN：发送了所有的输出后更改才发生</li><li>TCSAFLUSH：发送了所有的输出后更改才发生。更进一步，更改发生时未读入的所有输入都会被丢弃</li></ul><p><strong>标志详细见APUE</strong></p><h3 id="2-2-select函数"><a href="#2-2-select函数" class="headerlink" title="2.2 select函数"></a>2.2 select函数</h3><p>允许进程指示内核等待多个事件中的任何一个发生，并且只有一个或者多个事件或者超时之后才唤醒它</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> maxfdp, fd_set *readset, fd_set *writeset, fd_set *exceptset, <span class="keyword">const</span> struct timeval *timeout)</span></span>;</span><br><span class="line"><span class="comment">// return：返回就绪的描述符的数目，超时返回0，出错返回-1</span></span><br></pre></td></tr></table></figure><ul><li>若timeout为空指针，则永远等下去</li><li>若timeout中秒数和微妙数设置为0，检查描述符之后立即返回</li><li>若timeout中秒数和微妙数设置不为0，在有描述符就绪时返回，但是不超过timeout指定的时间</li></ul><h3 id="2-3-fcntl函数"><a href="#2-3-fcntl函数" class="headerlink" title="2.3 fcntl函数"></a>2.3 fcntl函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fcntl</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> cmd)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fcntl</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> cmd, <span class="keyword">long</span> arg)</span></span>;         </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fcntl</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> cmd, struct flock *lock)</span></span>;</span><br><span class="line"><span class="comment">//fcntl()针对(文件)描述符提供控制.参数fd是被参数cmd操作(如下面的描述)的描述符。针对cmd的值,fcntl能够接受第三个参数（arg）</span></span><br></pre></td></tr></table></figure><p>fcntl函数功能：</p><ul><li>复制一个现有的描述符（cmd=F_DUPFD）</li><li>获得／设置文件描述符标记(cmd=F_GETFD或F_SETFD)</li><li>获得／设置文件状态标记(cmd=F_GETFL或F_SETFL)</li><li>.获得／设置异步I/O所有权(cmd=F_GETOWN或F_SETOWN)</li><li>获得／设置记录锁(cmd=F_GETLK,F_SETLK或F_SETLKW)</li></ul><h2 id="三、参考文献"><a href="#三、参考文献" class="headerlink" title="三、参考文献"></a>三、参考文献</h2><p>【1】<a href="http://archive.ubuntu.com/ubuntu/pool/main/p/procps/procps_3.2.8.orig.tar.gz">top相关源码</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Linux-C语言实现按键即时识别&quot;&gt;&lt;a href=&quot;#Linux-C语言实现按键即时识别&quot; class=&quot;headerlink&quot; title=&quot;Linux C语言实现按键即时识别&quot;&gt;&lt;/a&gt;Linux C语言实现按键即时识别&lt;/h1&gt;&lt;p&gt;top中的源代码，慢</summary>
      
    
    
    
    <category term="Linux" scheme="https://www.delta1037.cn/categories/Linux/"/>
    
    
    <category term="Linux" scheme="https://www.delta1037.cn/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Shell脚本基础</title>
    <link href="https://www.delta1037.cn/2020/Linux/shell%E8%84%9A%E6%9C%AC%E5%9F%BA%E7%A1%80/"/>
    <id>https://www.delta1037.cn/2020/Linux/shell%E8%84%9A%E6%9C%AC%E5%9F%BA%E7%A1%80/</id>
    <published>2020-12-03T11:16:31.000Z</published>
    <updated>2020-12-11T17:31:04.789Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Shell脚本基础"><a href="#Shell脚本基础" class="headerlink" title="Shell脚本基础"></a>Shell脚本基础</h1><h2 id="一、变量"><a href="#一、变量" class="headerlink" title="一、变量"></a>一、变量</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用变量，建议方式</span></span><br><span class="line"><span class="variable">$&#123;var&#125;</span></span><br><span class="line"><span class="comment"># 在变量名var后是空格时才可用如下方式</span></span><br><span class="line"><span class="variable">$var</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设定只读变量</span></span><br><span class="line"><span class="built_in">declare</span> -r var_name</span><br><span class="line"><span class="built_in">readonly</span> var_name</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除变量</span></span><br><span class="line">uset var_name</span><br></pre></td></tr></table></figure><h3 id="1-1-字符串变量"><a href="#1-1-字符串变量" class="headerlink" title="1.1 字符串变量"></a>1.1 字符串变量</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 字符串的定义</span></span><br><span class="line">var_string=<span class="string">&quot;hello world&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 字符串的长度计算</span></span><br><span class="line"><span class="variable">$&#123;#var_string&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 字符串拼接</span></span><br><span class="line">var_string_new=<span class="string">&quot;<span class="variable">$&#123;var_string&#125;</span> new string&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">######## 字符串操作 ########</span></span><br><span class="line"><span class="comment"># 根据起始和截取长度截取字符串</span></span><br><span class="line"><span class="variable">$&#123;string_var:start_index:length&#125;</span> </span><br></pre></td></tr></table></figure><h3 id="1-2-变量赋值"><a href="#1-2-变量赋值" class="headerlink" title="1.2 变量赋值"></a>1.2 变量赋值</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 除了显式赋值，也可以将命令的结果存入到变量，如下就是将`ls /etc`的结果存到到了file_array</span></span><br><span class="line">file_array=$( ls /etc )</span><br><span class="line"></span><br><span class="line"><span class="comment"># 也可以使用` 命令 `方式</span></span><br><span class="line">file_array=` ls /etc `</span><br><span class="line"></span><br><span class="line"><span class="comment"># 应用:循环访问文件</span></span><br><span class="line"><span class="keyword">for</span> file <span class="keyword">in</span> $( ls /etc )</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">      <span class="comment"># do something</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><h3 id="1-3-数组变量"><a href="#1-3-数组变量" class="headerlink" title="1.3 数组变量"></a>1.3 数组变量</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 数组的定义</span></span><br><span class="line">array_var=(val0 val1 val2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 单独定义每个元素</span></span><br><span class="line">array_var[0]=val0</span><br><span class="line">array_var[1]=val1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取所有元素</span></span><br><span class="line"><span class="variable">$&#123;array_var[@]&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取数组的长度/元素个数</span></span><br><span class="line"><span class="variable">$&#123;#array_var[@]&#125;</span></span><br><span class="line"><span class="variable">$&#123;#array_var[*]&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取单个元素长度</span></span><br><span class="line"><span class="variable">$&#123;#array_var[n]&#125;</span></span><br></pre></td></tr></table></figure><h2 id="二、运算符"><a href="#二、运算符" class="headerlink" title="二、运算符"></a>二、运算符</h2><h3 id="2-1-算数运算符"><a href="#2-1-算数运算符" class="headerlink" title="2.1 算数运算符"></a>2.1 算数运算符</h3><ul><li><code>+、-、*、/，%</code> 借助<code>expr</code>进行计算，例如<code>expr $var1 + $var2</code></li><li><code>=</code> 赋值</li><li><code>==</code> <strong>数字</strong>比较相等返回true，<code>[ $var1 == $var2 ]</code></li><li><code>!=</code> <strong>数字</strong>比较不相等返回true，<code>[ $var1 != $var2 ]</code></li></ul><h3 id="2-2-关系运算符"><a href="#2-2-关系运算符" class="headerlink" title="2.2 关系运算符"></a>2.2 关系运算符</h3><p>关系运算符只用于比较<strong>数字</strong>之间的关系，<strong>不支持字符串，除非字符串的值是数字</strong></p><ul><li><code>-eq</code> 数字相等返回true，<code>[ $var1 -eq $var2 ]</code> =&gt; <code>==</code></li><li><code>-ne</code> 数字不相等返回true，<code>[ $var1 -nq $var2 ]</code> =&gt; <code>!=</code></li><li><code>-gt</code> 左边大于右边返回true，<code>[ $var1 -gt $var2 ]</code> =&gt; <code>&gt;</code></li><li><code>-lt</code> 左边小于右边返回true，<code>[ $var1 -lt $var2 ]</code> =&gt; <code>&lt;</code></li><li><code>-ge</code> 左边大于等于右边返回true，<code>[ $var1 -ge $var2 ]</code> =&gt; <code>&gt;=</code></li><li><code>-le</code> 左边小于等于右边返回true，<code>[ $var1 -le $var2 ]</code> =&gt; <code>&lt;=</code></li></ul><h3 id="2-3-布尔运算符"><a href="#2-3-布尔运算符" class="headerlink" title="2.3 布尔运算符"></a>2.3 布尔运算符</h3><p>设<code>var1=10，var2=20</code></p><ul><li><code>!</code> 非运算，表达式为false，返回true，<code>[ ! false ]</code>返回true</li><li><code>-o</code> 或运算，有一个表达式为true就为true，<code>[ $var1 -lt 20 -o $var1 -gt 100 ]</code>返回true</li><li><code>-a</code> 与运算，所有表达式为true才是true，<code>[ $var1 -lt 20 -a $var1 -gt 100 ]</code>返回false</li></ul><h3 id="2-4-逻辑运算符"><a href="#2-4-逻辑运算符" class="headerlink" title="2.4 逻辑运算符"></a>2.4 逻辑运算符</h3><ul><li>&amp;&amp; ：逻辑的AND</li><li>|| ：逻辑的OR</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 注意需要两个嵌套的中括号</span></span><br><span class="line"><span class="keyword">if</span> [[ <span class="variable">$&#123;var1&#125;</span> == 0 &amp;&amp; <span class="variable">$&#123;var2&#125;</span> == 0 ]];<span class="keyword">then</span></span><br><span class="line">     // <span class="keyword">do</span> something</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><h3 id="2-5-字符串运算符"><a href="#2-5-字符串运算符" class="headerlink" title="2.5 字符串运算符"></a>2.5 字符串运算符</h3><p>设<code>var1=&quot;abc&quot;，var2=&quot;efg&quot;</code></p><ul><li><code>=</code> 检测字符串相等返回true，<code>[ $var1 = $var2 ]</code>返回false</li><li><code>!=</code> 检测字符串不相等返回true，<code>[ $var1 != $var2 ]</code>返回true</li><li><code>-z</code> 检测字符串长度为0返回true，<code>[ -z $var1 ]</code>返回false</li><li><code>-n</code> 检测字符串长度不为0返回true，<code>[ -n $var1 ]</code>返回true</li><li><code>$</code> 检测字符串不为空返回true，<code>[ $var1 ]</code>返回true</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">########## 字符串为空和字符串长度的运算测试 ##########</span></span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">var1=</span><br><span class="line">var2=<span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ -z <span class="variable">$var1</span> ];<span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;var1 字符串长度为0&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;var1 字符串长度不为0&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ -z <span class="variable">$var2</span> ];<span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;var2 字符串长度为0&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;var2 字符串长度不为0&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ -z <span class="variable">$no_exits</span> ];<span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;no_exits 字符串长度为0&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;no_exits 字符串长度不为0&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$var1</span> ];<span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;var1 字符串不为空&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;var1 字符串为空&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$var2</span> ];<span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;var2 字符串不为空&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;var2 字符串为空&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$no_exits</span> ];<span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;no_exits 字符串不为空&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;no_exits 字符串为空&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment">########## 输出 ##########</span></span><br><span class="line">var1 字符串长度为0</span><br><span class="line">var2 字符串长度为0</span><br><span class="line">no_exits 字符串长度为0</span><br><span class="line">var1 字符串为空</span><br><span class="line">var2 字符串为空</span><br><span class="line">no_exits 字符串为空</span><br><span class="line"></span><br><span class="line"><span class="comment">########## 结论 ##########</span></span><br><span class="line">字符串长度和字符串是否为空的运算*好像*是一致的，他们有没有区别呢？</span><br></pre></td></tr></table></figure><h3 id="2-6-文件测试运算符"><a href="#2-6-文件测试运算符" class="headerlink" title="2.6 文件测试运算符"></a>2.6 文件测试运算符</h3><p>使用方法：\<operator\> file_name</p><p>operator</p><ul><li><code>-e</code> 文件是否存在</li><li><code>-r</code> 文件可读检测</li><li><code>-w</code> 文件可写检测</li><li><code>-x</code> 文件可执行检测</li><li><code>-d</code> 目录检测</li><li><code>-f</code> 普通文件检测（既不是目录，也不是设备文件）</li><li><code>-b</code> 块设备检测</li><li><code>-c</code> 字符设备检测</li><li><code>-p</code> 有名管道检测</li><li><code>-s</code> 文件大小是否为0</li><li><code>-S</code> 文件是否是socket连接</li><li><code>-L</code> 文件是否存在并且是一个符号链接</li><li><code>-g</code> 文件SGID位检测</li><li><code>-u</code> 文件SUID位检测</li><li><code>-k</code> 文件粘滞位（Sticky Bit）检测</li></ul><h2 id="三、参考文章"><a href="#三、参考文章" class="headerlink" title="三、参考文章"></a>三、参考文章</h2><p>【1】<a href="https://www.runoob.com/linux/linux-shell.html">Shell 教程</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Shell脚本基础&quot;&gt;&lt;a href=&quot;#Shell脚本基础&quot; class=&quot;headerlink&quot; title=&quot;Shell脚本基础&quot;&gt;&lt;/a&gt;Shell脚本基础&lt;/h1&gt;&lt;h2 id=&quot;一、变量&quot;&gt;&lt;a href=&quot;#一、变量&quot; class=&quot;headerli</summary>
      
    
    
    
    <category term="Linux" scheme="https://www.delta1037.cn/categories/Linux/"/>
    
    
    <category term="Linux" scheme="https://www.delta1037.cn/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux获取时间</title>
    <link href="https://www.delta1037.cn/2020/Linux/Linux%E8%8E%B7%E5%8F%96%E6%97%B6%E9%97%B4/"/>
    <id>https://www.delta1037.cn/2020/Linux/Linux%E8%8E%B7%E5%8F%96%E6%97%B6%E9%97%B4/</id>
    <published>2020-11-20T11:16:31.000Z</published>
    <updated>2020-12-11T17:31:05.813Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux获取时间"><a href="#Linux获取时间" class="headerlink" title="Linux获取时间"></a>Linux获取时间</h1><h2 id="一、获取时间"><a href="#一、获取时间" class="headerlink" title="一、获取时间"></a>一、获取时间</h2><h3 id="1-1-获取秒、微秒"><a href="#1-1-获取秒、微秒" class="headerlink" title="1.1 获取秒、微秒"></a>1.1 获取秒、微秒</h3><p>Linux中获取微秒级时间的系统调用<code>gettimeofday()</code>，但是返回值的准确性依赖于系统的架构。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="comment">/* 在tz指向的缓冲区中返回日历时间；Linux不支持tz参数，设置为NULL */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gettimeofday</span><span class="params">(struct timeval *tv, struct timezone *tz)</span></span>; </span><br></pre></td></tr></table></figure><p>其中<code>timeval</code>结构体定义如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> &#123;</span></span><br><span class="line">    <span class="keyword">time_t</span> tv_sec;  <span class="comment">/* 从1970年1月1日00:00:00以来的秒数(long) */</span></span><br><span class="line">    <span class="keyword">suseconds_t</span> tv_usec; <span class="comment">/* 附加的微秒(long int) */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>time()</code>系统调用返回自Epoch( 1970年1月1日00:00:00 )以来的秒数，如果<code>p_time</code>参数不为空，则会将返回值置于<code>p_time</code>指向的位置。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">time_t</span> <span class="title">time</span><span class="params">(<span class="keyword">time_t</span> *p_time)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="二、时间转换"><a href="#二、时间转换" class="headerlink" title="二、时间转换"></a>二、时间转换</h2><h3 id="2-1-time-t和可打印的格式"><a href="#2-1-time-t和可打印的格式" class="headerlink" title="2.1 time_t和可打印的格式"></a>2.1 time_t和可打印的格式</h3><p><code>ctime()</code>提供了一种简单的将时间转成字符串格式的转换方式。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">ctime</span><span class="params">(<span class="keyword">const</span> <span class="keyword">time_t</span> *p_time)</span></span>; <span class="comment">// 返回的字符串包括终止空字符和换行符</span></span><br><span class="line"><span class="comment">// output eg :  Wed Jun  8 14:22:34 2012 </span></span><br><span class="line"><span class="comment">// 返回的字符串是静态分配的，下次调用会覆盖</span></span><br></pre></td></tr></table></figure><p>注：在SUSv3规定，调用<code>ctime()</code>、<code>gmtime()</code>、<code>localTime()</code>或<code>asctime()</code>中的任一个函数，都可能覆盖其它函数的返回</p><h3 id="2-2-time-t和分解的格式"><a href="#2-2-time-t和分解的格式" class="headerlink" title="2.2 time_t和分解的格式"></a>2.2 time_t和分解的格式</h3><p><code>gmtime()</code>可以把日历时间转换成一个对应UTC的分解的时间；<code>localTime()</code>考虑时区和夏令时的设置，返回对应系统本地时间的分解时间</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="function">struct tm *<span class="title">gmtime</span><span class="params">(<span class="keyword">const</span> <span class="keyword">time_t</span> *p_time)</span></span>;</span><br><span class="line"><span class="function">struct tm *<span class="title">localTime</span><span class="params">(<span class="keyword">const</span> <span class="keyword">time_t</span> *p_time)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可重入版本</span></span><br><span class="line"><span class="function">struct tm *<span class="title">gmtime_r</span><span class="params">(<span class="keyword">const</span> <span class="keyword">time_t</span> *p_time)</span></span>;</span><br><span class="line"><span class="function">struct tm *<span class="title">localTime_r</span><span class="params">(<span class="keyword">const</span> <span class="keyword">time_t</span> *p_time)</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分解时间结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tm</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span>    tm_sec;   <span class="comment">/* seconds [0,61] */</span></span><br><span class="line">    <span class="keyword">int</span>    tm_min;   <span class="comment">/* minutes [0,59] */</span></span><br><span class="line">    <span class="keyword">int</span>    tm_hour;  <span class="comment">/* hour [0,23] */</span></span><br><span class="line">    <span class="keyword">int</span>    tm_mday;  <span class="comment">/* day of month [1,31] */</span></span><br><span class="line">    <span class="keyword">int</span>    tm_mon;   <span class="comment">/* month of year [0,11] */</span></span><br><span class="line">    <span class="keyword">int</span>    tm_year;  <span class="comment">/* years since 1900 */</span></span><br><span class="line">    <span class="keyword">int</span>    tm_wday;  <span class="comment">/* day of week [0,6] (Sunday = 0) */</span></span><br><span class="line">    <span class="keyword">int</span>    tm_yday;  <span class="comment">/* day of year [0,365] */</span></span><br><span class="line">    <span class="keyword">int</span>    tm_isdst; <span class="comment">/* daylight savings flag */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="2-3-分解的格式与可打印格式"><a href="#2-3-分解的格式与可打印格式" class="headerlink" title="2.3 分解的格式与可打印格式"></a>2.3 分解的格式与可打印格式</h3><p><code>asctime()</code>将分解的格式转换成可打印的格式，指向由静态分配的字符串</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">asctime</span><span class="params">(<span class="keyword">const</span> struct tm *timeptr)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可重入版本</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">asctime_r</span><span class="params">(<span class="keyword">const</span> struct tm *timeptr)</span></span>;</span><br></pre></td></tr></table></figure><p><code>strftime()</code>在将分解的时间转换成可打印的格式时提供更为精确的控制。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">strftime</span><span class="params">(<span class="keyword">char</span> *out_str, <span class="keyword">size_t</span> max_size, <span class="keyword">const</span> <span class="keyword">char</span> *format, <span class="keyword">const</span> struct tm *timeptr)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// strftime不会自动添加换行符</span></span><br><span class="line"><span class="comment">// out_str会按照format做格式化</span></span><br></pre></td></tr></table></figure><p>format参数定义：</p><div class="table-container"><table><thead><tr><th style="text-align:left">说明符</th><th style="text-align:left">描述</th><th style="text-align:left">实例</th></tr></thead><tbody><tr><td style="text-align:left">%a</td><td style="text-align:left">星期几的缩写</td><td style="text-align:left">Tue</td></tr><tr><td style="text-align:left">%A</td><td style="text-align:left">星期几的全称</td><td style="text-align:left">Tuesday</td></tr><tr><td style="text-align:left">%b</td><td style="text-align:left">月份名称的缩写</td><td style="text-align:left">Feb</td></tr><tr><td style="text-align:left">%B</td><td style="text-align:left">月份全称</td><td style="text-align:left">February</td></tr><tr><td style="text-align:left">%c</td><td style="text-align:left">日期和时间</td><td style="text-align:left">Tue Feb  1 21:39:46 2011</td></tr><tr><td style="text-align:left">%d</td><td style="text-align:left">一月中的一天（两位数字，01-31）</td><td style="text-align:left">01</td></tr><tr><td style="text-align:left">%D</td><td style="text-align:left">美国日期的格式（同%m%d%y）</td><td style="text-align:left">02/01/2011</td></tr><tr><td style="text-align:left">%e</td><td style="text-align:left">一月中的一天（两个字符）</td><td style="text-align:left">1</td></tr><tr><td style="text-align:left">%F</td><td style="text-align:left">ISO格式的日期（%Y-%m-%d）</td><td style="text-align:left">2011-02-01</td></tr><tr><td style="text-align:left">%H</td><td style="text-align:left">24 小时格式的小时（两位数，00-23）</td><td style="text-align:left">21</td></tr><tr><td style="text-align:left">%I</td><td style="text-align:left">12 小时格式的小时（两位数，01-12）</td><td style="text-align:left">09</td></tr><tr><td style="text-align:left">%j</td><td style="text-align:left">一年中的第几天（三位数，001-366）</td><td style="text-align:left">032</td></tr><tr><td style="text-align:left">%m</td><td style="text-align:left">十进制数表示的月份（两位，01-12）</td><td style="text-align:left">08</td></tr><tr><td style="text-align:left">%M</td><td style="text-align:left">分（两位，00-59）</td><td style="text-align:left">55</td></tr><tr><td style="text-align:left">%p</td><td style="text-align:left">AM 或 PM 名称</td><td style="text-align:left">PM</td></tr><tr><td style="text-align:left">%P</td><td style="text-align:left">上午/下午（GNU扩展）</td><td style="text-align:left">pm</td></tr><tr><td style="text-align:left">%R</td><td style="text-align:left">24小时制的时间（%H:%M）</td><td style="text-align:left">21:39</td></tr><tr><td style="text-align:left">%S</td><td style="text-align:left">秒（00-61）</td><td style="text-align:left">46</td></tr><tr><td style="text-align:left">%T</td><td style="text-align:left">时间（%H:%M:%S）</td><td style="text-align:left">21:39:46</td></tr><tr><td style="text-align:left">%u</td><td style="text-align:left">星期几编号（1-7）</td><td style="text-align:left">2</td></tr><tr><td style="text-align:left">%U</td><td style="text-align:left">一年中的第几周，以第一个星期日作为第一周的第一天（00-53）</td><td style="text-align:left">05</td></tr><tr><td style="text-align:left">%w</td><td style="text-align:left">十进制数表示的星期几，星期日表示为 0（0-6）</td><td style="text-align:left">2</td></tr><tr><td style="text-align:left">%W</td><td style="text-align:left">一年中的第几周，以第一个星期一作为第一周的第一天（00-53）</td><td style="text-align:left">05</td></tr><tr><td style="text-align:left">%x</td><td style="text-align:left">日期表示法（本地化）</td><td style="text-align:left">02/01/2011</td></tr><tr><td style="text-align:left">%X</td><td style="text-align:left">时间表示法（本地化）</td><td style="text-align:left">21:39:46</td></tr><tr><td style="text-align:left">%y</td><td style="text-align:left">两位数字年份，最后两个数字（00-99）</td><td style="text-align:left">11</td></tr><tr><td style="text-align:left">%Y</td><td style="text-align:left">四位数字年份</td><td style="text-align:left">2011</td></tr><tr><td style="text-align:left">%Z</td><td style="text-align:left">时区的名称或缩写</td><td style="text-align:left">CET</td></tr><tr><td style="text-align:left">%%</td><td style="text-align:left">一个 % 符号</td><td style="text-align:left">%</td></tr></tbody></table></div><p><code>strptime()</code>是<code>strftime()</code>的逆向函数，将包含日期的字符串转换成分解的时间</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _XOPNE_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strptime</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str, <span class="keyword">const</span> <span class="keyword">char</span> *format, struct tm *time_ptr)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="转换图"><a href="#转换图" class="headerlink" title="转换图"></a>转换图</h2><p>下图来自Linux/Unix系统编程手册</p><p><img src="https://delta1037.oss-cn-beijing.aliyuncs.com/hexo-blog/Linux_getTime/time_trans.png" alt=""></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Linux获取时间&quot;&gt;&lt;a href=&quot;#Linux获取时间&quot; class=&quot;headerlink&quot; title=&quot;Linux获取时间&quot;&gt;&lt;/a&gt;Linux获取时间&lt;/h1&gt;&lt;h2 id=&quot;一、获取时间&quot;&gt;&lt;a href=&quot;#一、获取时间&quot; class=&quot;head</summary>
      
    
    
    
    <category term="Linux" scheme="https://www.delta1037.cn/categories/Linux/"/>
    
    
    <category term="Linux" scheme="https://www.delta1037.cn/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>C++ 类型转换</title>
    <link href="https://www.delta1037.cn/2020/C_C++/C++%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"/>
    <id>https://www.delta1037.cn/2020/C_C++/C++%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</id>
    <published>2020-04-25T03:19:45.000Z</published>
    <updated>2021-01-31T13:58:12.965Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-类型转换"><a href="#C-类型转换" class="headerlink" title="C++类型转换"></a>C++类型转换</h1><p>典型的C类型转换如下所示</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Typename_1 var_type_1;</span><br><span class="line">Typename_0 var_type_0 = (Typename_0)var_type_1;</span><br></pre></td></tr></table></figure><p>在C语言中，不管什么类型的转换都可以使用上述的形式；C++也支持上述类型的强制类型转换，但是这种转换可能会带来一些隐患，所以C++提供了四个在不同场合的强制类型转换函数：<code>const_cast</code>, <code>static_cast</code>, <code>dynamic_cast</code>, <code>reinterpret_cast</code></p><h2 id="一、const-cast"><a href="#一、const-cast" class="headerlink" title="一、const_cast"></a>一、const_cast</h2><p>const_cast用于修改指针或者引用，将指针或引用的常量形式转为非常量的形式，并且仍然指向原来的对象</p><p><strong>SUM：</strong></p><ul><li>修改指针或者引用</li><li>常量转为非常量</li></ul><p><strong>Code：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># 正常的使用方法</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">test_func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">6</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> *p_const_num = &amp;num;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> *p_num = <span class="keyword">const_cast</span>&lt;<span class="keyword">int</span>*&gt;p_const_num;</span><br><span class="line">    *p_num = <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 未定义的使用方法</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">test_func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *p_const_str = <span class="string">&quot;ABCD&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">char</span> *p_str = <span class="keyword">const_cast</span>&lt;<span class="keyword">char</span>*&gt;p_const_str;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二、static-cast"><a href="#二、static-cast" class="headerlink" title="二、static_cast"></a>二、static_cast</h2><p>static_cast与C语言风格的强制转换效果一样</p><p><strong>SUM：</strong></p><p>常用于：</p><ul><li><p>类层次结构中基类（父类）和派生类（子类）之间指针或引用的转换。注意：进行上行转换（把派生类的指针或引用转换成基类表示）是安全的；进行下行转换（把基类指针或引用转换成派生类表示）时，由于没有动态类型检查，所以是不安全的。</p></li><li><p>基本数据类型之间的转换，如把int转换成char，把int转换成enum。安全性需要开发者来维护</p></li></ul><p><strong>注：</strong></p><ul><li><strong>没有运行时检查</strong>，与C风格一样都存在安全隐患</li><li>static_cast不能转换掉原有类型的const、volatile、或者 __unaligned属性。(前两种可以使用const_cast 来去除)</li><li>c++ 的任何的<strong>隐式转换</strong>都是使用 <em>static_cast</em> 来实现</li></ul><p><strong>Code：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">// base class</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sub</span> :</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"> <span class="comment">// sub class  </span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承类向基类的转换，编译通过并且是安全的</span></span><br><span class="line">Sub sub;</span><br><span class="line">Base *base_ptr = <span class="keyword">static_cast</span>&lt;Base*&gt;sub;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基类向继承类的转换，编译通过但是是不安全的</span></span><br><span class="line">Base base;</span><br><span class="line">Sub *sub_ptr = static_case&lt;Sub*&gt;base;</span><br></pre></td></tr></table></figure><h2 id="三、dynamic-cast"><a href="#三、dynamic-cast" class="headerlink" title="三、dynamic_cast"></a>三、dynamic_cast</h2><p><code>dynamic_cast</code>将基类指针（或引用）转换成继承类指针（或引用），<code>dynamic_cast</code>会根据基类指针是否真正指向继承类指针做相应处理。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;base class print&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sub</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> <span class="keyword">override</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;sub class print&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Sub *sub_ptr = <span class="keyword">new</span> Sub();</span><br><span class="line">    sub_ptr-&gt;print();</span><br><span class="line">    <span class="comment">// 如果基类没有虚函数，使用dynamic_cast会报错</span></span><br><span class="line">    Base *base_ptr = <span class="keyword">dynamic_cast</span>&lt;Base*&gt;(sub_ptr);</span><br><span class="line">    <span class="keyword">if</span>(base_ptr)&#123;</span><br><span class="line">        base_ptr-&gt;print();</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;base ptr is NULL&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> sub_ptr;</span><br><span class="line"></span><br><span class="line">    base_ptr = <span class="keyword">new</span> Base();</span><br><span class="line">    base_ptr-&gt;print();</span><br><span class="line">    sub_ptr = <span class="keyword">dynamic_cast</span>&lt;Sub*&gt;(base_ptr);</span><br><span class="line">    <span class="keyword">if</span>(sub_ptr)&#123;</span><br><span class="line">        sub_ptr-&gt;print();</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;sub ptr is NULL&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> base_ptr;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    Win10上的Clion输出如下:</span></span><br><span class="line"><span class="comment">        sub class print</span></span><br><span class="line"><span class="comment">        sub class print</span></span><br><span class="line"><span class="comment">        base class print</span></span><br><span class="line"><span class="comment">        sub ptr is NULL</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>从上边的运行结果可以看出：</p><ul><li>从子类到基类的指针dynamic_cast转换没有问题</li><li>从基类到子类的转换虽然编译没有报错，但是转换的sub_ptr是一个空指针，说明dynamic_cast在程序运行时对类型进行了检查（RTTI，运行期类型检查，<em>Runtime type information</em>）</li></ul><p>这个检查主要来自虚函数，虚函数时dynamic_cast转换能够进行的前提条件。当一个类有一个虚函数，那么编译器会构造出来一个虚函数表来指示这些虚函数的地址，如果该类被继承并且子类实现了一个同名并具有相同的函数签名的方法重写了基类的方法，那么虚函数表中会将该函数指向新的地址。此时多态性体现：使用激烈的指针或引用指向子类的对象，调用该方法时会顺着虚函数表找到对应子类的方法。</p><h2 id="四、reinterpret-cast"><a href="#四、reinterpret-cast" class="headerlink" title="四、reinterpret_cast"></a>四、reinterpret_cast</h2><p>reinterpret_cast是强制类型转换符用来处理无关类型转换的，通常为操作数的位模式提供较底层的重新解释。</p><p>主要应用在：</p><ul><li>任意指针之间的转换</li><li>引用之间的转换</li><li>指针和足够大的int类型之间的转换</li><li>整数到指针的转换</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *num_ptr = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">2333</span>);</span><br><span class="line">    <span class="keyword">uint64_t</span> ptr_num = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">uint64_t</span>&gt;(num_ptr);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;ptr addr :&quot;</span> &lt;&lt; hex &lt;&lt; num_ptr &lt;&lt; <span class="built_in">endl</span></span><br><span class="line">        &lt;&lt;  <span class="string">&quot;num val :&quot;</span> &lt;&lt; hex &lt;&lt; ptr_num &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*64位机器上的测试和输出</span></span><br><span class="line"><span class="comment"> ptr addr :0x80004adc0</span></span><br><span class="line"><span class="comment"> num val :80004adc0</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>【0】<a href="https://blog.csdn.net/ydar95/article/details/69822540">c++ 四种强制类型转换介绍</a></p><p>【1】<a href="https://blog.csdn.net/lihao21/article/details/50688337">C++虚函数表剖析</a></p><p>【2】<a href="https://baike.baidu.com/item/dynamic_cast">dynamic_cast</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;C-类型转换&quot;&gt;&lt;a href=&quot;#C-类型转换&quot; class=&quot;headerlink&quot; title=&quot;C++类型转换&quot;&gt;&lt;/a&gt;C++类型转换&lt;/h1&gt;&lt;p&gt;典型的C类型转换如下所示&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>deltaNote</title>
    <link href="https://www.delta1037.cn/2019/Deploy/deltaNoteSite/"/>
    <id>https://www.delta1037.cn/2019/Deploy/deltaNoteSite/</id>
    <published>2019-11-23T07:00:59.000Z</published>
    <updated>2020-12-11T17:31:03.869Z</updated>
    
    <content type="html"><![CDATA[<h1 id="deltaNote"><a href="#deltaNote" class="headerlink" title="deltaNote"></a>deltaNote</h1><h2 id="一、资源地址"><a href="#一、资源地址" class="headerlink" title="一、资源地址"></a>一、资源地址</h2><p><a href="https://github.com/delta1037/deltaNote">项目github地址</a><br><a href="https://github.com/delta1037/deltaNote/releases">发行版下载地址</a></p><h2 id="二、使用说明"><a href="#二、使用说明" class="headerlink" title="二、使用说明"></a>二、使用说明</h2><h3 id="2-1-Linux服务端安装"><a href="#2-1-Linux服务端安装" class="headerlink" title="2.1 Linux服务端安装"></a>2.1 Linux服务端安装</h3><p>1、从<a href="https://github.com/delta1037/deltaNote/releases">发行版下载地址</a>下载服务端，解压<br>2、进入解压后的目录，使用<code>./deltaNote</code>命令运行，可以使用<code>netstat -anpt | grep 8888</code>看到服务端已在运行<br>3、可以使用<code>vim deltaNote</code>修改端口等参数</p><ul><li>目前测试服务端：<code>39.96.162.190:8888</code></li></ul><h3 id="2-2-Linux客户端安装"><a href="#2-2-Linux客户端安装" class="headerlink" title="2.2 Linux客户端安装"></a>2.2 Linux客户端安装</h3><p>1、下载压缩包之后，解压<br>2、执行<code>sudo ./install.sh</code>即可安装到<code>/usr/local/deltaNote</code><br>3、执行<code>sudo ./uninstall.sh</code>即可卸载</p><h3 id="2-3-window客户端安装"><a href="#2-3-window客户端安装" class="headerlink" title="2.3 window客户端安装"></a>2.3 window客户端安装</h3><p>1、下载压缩包，解压<br>2、双击<code>*.exe</code>运行安装程序（目前不支持安装在C盘）</p><h3 id="2-4-deltaNote简介"><a href="#2-4-deltaNote简介" class="headerlink" title="2.4 deltaNote简介"></a>2.4 deltaNote简介</h3><h4 id="2-4-1-主界面"><a href="#2-4-1-主界面" class="headerlink" title="2.4.1 主界面"></a>2.4.1 主界面</h4><p>主界面如下图所示<br><img src="https://delta1037.oss-cn-beijing.aliyuncs.com/hexo-blog/deltaNote/main.png" alt="主界面"></p><ul><li>主界面简介：主界面上部有四个按钮，分别是设置，刷新，界面锁和历史记录<ul><li>设置按钮：打开设置面板</li><li>刷新按钮：与服务端进行同步</li><li>界面锁按钮：界面锁打开时，可以对主界面位置进行调整</li><li>历史记录按钮：点击打开查看已做的内容，打开历史记录使用右键可以选择清理历史记录</li></ul></li><li>位置和大小：当界面锁是开启状态时，可以对窗体进行调整，其中<code>1</code>位置可以拖动窗口；<code>2</code>位置可以调整窗体的高度。</li><li>勾选已做：点击每条TODO的前边的小方框，可以将TODO标记为已做，可以在历史记录中查看</li></ul><h4 id="2-4-2-设置"><a href="#2-4-2-设置" class="headerlink" title="2.4.2 设置"></a>2.4.2 设置</h4><p>点击主界面中的设置按钮，可以看到设置界面，如下所示<br><img src="https://delta1037.oss-cn-beijing.aliyuncs.com/hexo-blog/deltaNote/setting.png" alt="设置"></p><ul><li>设置界面简介：<ul><li>服务端地址和端口(目前仅支持IP地址)</li><li>用户名和密码</li><li>调整窗体的透明度</li><li>调整字体大小</li><li>调整主界面宽度</li><li>调整字体和图标颜色</li><li>设置开机启动</li></ul></li></ul><h4 id="2-4-3-创建用户"><a href="#2-4-3-创建用户" class="headerlink" title="2.4.3 创建用户"></a>2.4.3 创建用户</h4><p>点击设置中的创建用户按钮，如下图所示<br><img src="https://delta1037.oss-cn-beijing.aliyuncs.com/hexo-blog/deltaNote/createUser.png" alt="创建用户"></p><p>填入用户名和密码即可创建新用户</p><h2 id="三、问题反馈"><a href="#三、问题反馈" class="headerlink" title="三、问题反馈"></a>三、问题反馈</h2><p><a href="https://github.com/delta1037/deltaNote/issues">问题反馈</a></p><h2 id="四、问题"><a href="#四、问题" class="headerlink" title="四、问题"></a>四、问题</h2><ul><li>window客户端不要安装在C盘，因为安装和运行时没有获取管理员权限</li><li>window客户端开机启动选项打开之后，需要在任务管理器的启动页面禁用再启用</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;deltaNote&quot;&gt;&lt;a href=&quot;#deltaNote&quot; class=&quot;headerlink&quot; title=&quot;deltaNote&quot;&gt;&lt;/a&gt;deltaNote&lt;/h1&gt;&lt;h2 id=&quot;一、资源地址&quot;&gt;&lt;a href=&quot;#一、资源地址&quot; class=&quot;head</summary>
      
    
    
    
    <category term="部署" scheme="https://www.delta1037.cn/categories/%E9%83%A8%E7%BD%B2/"/>
    
    
    <category term="便签" scheme="https://www.delta1037.cn/tags/%E4%BE%BF%E7%AD%BE/"/>
    
  </entry>
  
  <entry>
    <title>MySQL使用MariaDB Audit Plugin实现审计功能</title>
    <link href="https://www.delta1037.cn/2019/Deploy/MySQL%E4%BD%BF%E7%94%A8MariaDB-Audit-Plugin%E5%AE%9E%E7%8E%B0%E5%AE%A1%E8%AE%A1%E5%8A%9F%E8%83%BD/"/>
    <id>https://www.delta1037.cn/2019/Deploy/MySQL%E4%BD%BF%E7%94%A8MariaDB-Audit-Plugin%E5%AE%9E%E7%8E%B0%E5%AE%A1%E8%AE%A1%E5%8A%9F%E8%83%BD/</id>
    <published>2019-10-20T04:35:08.000Z</published>
    <updated>2020-12-11T17:31:02.845Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、安装MariaDB-Audit-Plugin"><a href="#一、安装MariaDB-Audit-Plugin" class="headerlink" title="一、安装MariaDB Audit Plugin"></a>一、安装MariaDB Audit Plugin</h2><h3 id="1-1-准备MariaDB安装环境"><a href="#1-1-准备MariaDB安装环境" class="headerlink" title="1.1 准备MariaDB安装环境"></a>1.1 准备MariaDB安装环境</h3><p>为了不对使用mysql的主机造成影响，建议使用另一台与mysql主机系统一致的主机来安装MariaDB，然后不用执行下面的卸载操作<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get autoremove --purge mysql-\*</span><br><span class="line">sudo rm -rf /var/lib/mysql*</span><br><span class="line">sudo rm -rf /etc/mysql/</span><br></pre></td></tr></table></figure></p><h3 id="1-2-安装MariaDB"><a href="#1-2-安装MariaDB" class="headerlink" title="1.2 安装MariaDB"></a>1.2 安装MariaDB</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install mariadb-server</span><br></pre></td></tr></table></figure><p>安装完成之后在/usr/lib/mysql/plugin目录中有server_audit.so插件，将该插件拷贝出来备用（拷贝到mysql主机的/usr/lib/mysql/plugin目录中）</p><h3 id="1-3-MySQL环境恢复"><a href="#1-3-MySQL环境恢复" class="headerlink" title="1.3 MySQL环境恢复"></a>1.3 MySQL环境恢复</h3><p>如果是在mysql的主机上进行安装MariaDB操作，使用如下命令将MariaDB卸载，并重新安装mysql<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get remove --purge mariadb-\*</span><br><span class="line">sudo rm -rf /etc/mysql/</span><br><span class="line">sudo rm -rf /var/lib/mysql*</span><br><span class="line">sudo apt-get remove --purge mysql-\*</span><br><span class="line">sudo apt-get install mysql-server mysql-client</span><br></pre></td></tr></table></figure></p><h3 id="1-4-添加MySQL配置"><a href="#1-4-添加MySQL配置" class="headerlink" title="1.4 添加MySQL配置"></a>1.4 添加MySQL配置</h3><p>修改/etc/mysql/my.cnf文件，在文件末尾添加如下内容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">log_output&#x3D;FILE</span><br><span class="line">server_audit_file_path&#x3D;&#x2F;var&#x2F;log&#x2F;mysql&#x2F;audit.log</span><br><span class="line">server_audit_events &#x3D; &#39;QUERY_DCL,QUERY_DML_NO_SELECT,QUERY_DML,QUERY_DDL,TABLE,QUERY,CONNECT&#39;</span><br><span class="line">server_audit_logging&#x3D;1</span><br></pre></td></tr></table></figure><br>重新启动MySQL<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service mysql restart</span><br></pre></td></tr></table></figure></p><h2 id="二、Mysql审计日志分析"><a href="#二、Mysql审计日志分析" class="headerlink" title="二、Mysql审计日志分析"></a>二、Mysql审计日志分析</h2><h3 id="2-1-server-audit-events变量过滤功能"><a href="#2-1-server-audit-events变量过滤功能" class="headerlink" title="2.1 server_audit_events变量过滤功能"></a>2.1 server_audit_events变量过滤功能</h3><p>使用mysql -uroot -p登陆数据库，执行如下命令修改变量为如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set global server_audit_events&#x3D;&#39;QUERY_DDL&#39;;</span><br></pre></td></tr></table></figure><br>执行如下SQL语句<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">create database test2;</span><br><span class="line">use test2;</span><br><span class="line">create table table1 (col1 VARCHAR(20));</span><br><span class="line">insert into table1 values (&quot;lili&quot;);</span><br><span class="line">select * from table1;</span><br></pre></td></tr></table></figure><br><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">20191019 </span><span class="number">20</span>:<span class="number">56</span>:<span class="number">50</span>,delta-mysql,root,localhost,<span class="number">16</span>,<span class="number">1300</span>,QUERY,test,<span class="comment">&#x27;create database test2&#x27;,0</span></span><br><span class="line"><span class="symbol">20191019 </span><span class="number">20</span>:<span class="number">57</span>:<span class="number">29</span>,delta-mysql,root,localhost,<span class="number">16</span>,<span class="number">1306</span>,QUERY,test2,<span class="comment">&#x27;create table table1 (col1 VARCHAR(20))&#x27;,0</span></span><br></pre></td></tr></table></figure><br>由上图可见只有create类型的日志被记录下来，insert和select类型的操作日志并没有被记录下来，并且操作类型字段显示为QUERY类型</p><p>使用mysql -uroot -p登陆数据库，执行如下命令修改变量为如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set global server_audit_events&#x3D;&#39;QUERY_DDL,QUERY_DML&#39;;</span><br></pre></td></tr></table></figure><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">create database test3;</span><br><span class="line">use test3;</span><br><span class="line">create table table2 (col1 VARCHAR(20));</span><br><span class="line">insert into table2 values (&quot;lili&quot;);</span><br><span class="line">select * from table2;</span><br></pre></td></tr></table></figure></p><p>前两行是上面的日志，后面的是新产生的日志<br><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">20191019 </span><span class="number">20</span>:<span class="number">56</span>:<span class="number">50</span>,delta-mysql,root,localhost,<span class="number">16</span>,<span class="number">1300</span>,QUERY,test,<span class="comment">&#x27;create database test2&#x27;,0</span></span><br><span class="line"><span class="symbol">20191019 </span><span class="number">20</span>:<span class="number">57</span>:<span class="number">29</span>,delta-mysql,root,localhost,<span class="number">16</span>,<span class="number">1306</span>,QUERY,test2,<span class="comment">&#x27;create table table1 (col1 VARCHAR(20))&#x27;,0</span></span><br><span class="line"><span class="symbol">20191019 </span><span class="number">21</span>:<span class="number">45</span>:<span class="number">18</span>,delta-mysql,root,localhost,<span class="number">16</span>,<span class="number">1312</span>,QUERY,test2,<span class="comment">&#x27;create table table2 (col1 VARCHAR(20))&#x27;,0</span></span><br><span class="line"><span class="symbol">20191019 </span><span class="number">21</span>:<span class="number">45</span>:<span class="number">33</span>,delta-mysql,root,localhost,<span class="number">16</span>,<span class="number">1313</span>,QUERY,test2,<span class="comment">&#x27;insert into table2 values (&quot;lili&quot;)&#x27;,0</span></span><br><span class="line"><span class="symbol">20191019 </span><span class="number">21</span>:<span class="number">45</span>:<span class="number">56</span>,delta-mysql,root,localhost,<span class="number">16</span>,<span class="number">1314</span>,QUERY,test2,<span class="comment">&#x27;select * from table2&#x27;,0</span></span><br><span class="line"><span class="symbol">20191019 </span><span class="number">21</span>:<span class="number">47</span>:<span class="number">52</span>,delta-mysql,root,localhost,<span class="number">16</span>,<span class="number">1316</span>,QUERY,test2,<span class="comment">&#x27;create databse test3&#x27;,1064</span></span><br><span class="line"><span class="symbol">20191019 </span><span class="number">21</span>:<span class="number">47</span>:<span class="number">58</span>,delta-mysql,root,localhost,<span class="number">16</span>,<span class="number">1317</span>,QUERY,test2,<span class="comment">&#x27;create database test3&#x27;,0</span></span><br><span class="line"><span class="symbol">20191019 </span><span class="number">21</span>:<span class="number">48</span>:<span class="number">08</span>,delta-mysql,root,localhost,<span class="number">16</span>,<span class="number">1318</span>,QUERY,test2,<span class="comment">&#x27;SELECT DATABASE()&#x27;,0</span></span><br><span class="line"><span class="symbol">20191019 </span><span class="number">21</span>:<span class="number">48</span>:<span class="number">15</span>,delta-mysql,root,localhost,<span class="number">16</span>,<span class="number">1320</span>,QUERY,test2,<span class="comment">&#x27;SELECT DATABASE()&#x27;,0</span></span><br><span class="line"><span class="symbol">20191019 </span><span class="number">21</span>:<span class="number">48</span>:<span class="number">31</span>,delta-mysql,root,localhost,<span class="number">16</span>,<span class="number">1324</span>,QUERY,test3,<span class="comment">&#x27;create table table2 (col1 VARCHAR(20))&#x27;,0</span></span><br><span class="line"><span class="symbol">20191019 </span><span class="number">21</span>:<span class="number">48</span>:<span class="number">31</span>,delta-mysql,root,localhost,<span class="number">16</span>,<span class="number">1325</span>,QUERY,test3,<span class="comment">&#x27;insert into table2 values (&quot;lili&quot;)&#x27;,0</span></span><br><span class="line"><span class="symbol">20191019 </span><span class="number">21</span>:<span class="number">48</span>:<span class="number">31</span>,delta-mysql,root,localhost,<span class="number">16</span>,<span class="number">1326</span>,QUERY,test3,<span class="comment">&#x27;select * from table2&#x27;,0</span></span><br></pre></td></tr></table></figure></p><p>由上可见，create，select和insert类型的日志均被记录下来，并且操作类型字段均为QUERY类型，并不是QUERY_DDL和QUERY_DML类型</p><p>根据<a href="https://mariadb.com/kb/en/library/mariadb-audit-plugin-log-settings/">官方文档</a>显示，QUERY_DDL操作类型指的是进行CREATE等操作时才产生QUERY_DDL操作类型的日志，QUERY_DML操作类型是进行SELECT等操作时才产生QUERY_DML操作类型的日志。</p><p>综上所述，server_audit_events确实对操作日志起到了过滤作用，但是实际日志中操作类型字段只有QUERY。说明QUERY_DDL确实起到了日志类型过滤作用，实际操作类型字段仍为QUERY。</p><h2 id="2-2TABLE-Event分析"><a href="#2-2TABLE-Event分析" class="headerlink" title="2.2TABLE Event分析"></a>2.2TABLE Event分析</h2><p>按照<a href="https://mariadb.com/kb/en/library/mariadb-audit-plugin-log-settings/">官方文档</a>显示，执行查询操作时会显示操作类型为READ的TABLE事件日志<br><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">20170817 </span><span class="number">16</span>:<span class="number">04</span>:<span class="number">33</span>,ip-<span class="number">172</span>-<span class="number">30</span>-<span class="number">0</span>-<span class="number">38</span>,root,localhost,<span class="number">29</span>,<span class="number">913</span>,<span class="keyword">READ</span>,company,employees,</span><br><span class="line"><span class="symbol">20170817 </span><span class="number">16</span>:<span class="number">04</span>:<span class="number">33</span>,ip-<span class="number">172</span>-<span class="number">30</span>-<span class="number">0</span>-<span class="number">38</span>,root,localhost,<span class="number">29</span>,<span class="number">913</span>,<span class="keyword">READ</span>,company,employees_salaries,</span><br><span class="line"><span class="symbol">20170817 </span><span class="number">16</span>:<span class="number">04</span>:<span class="number">33</span>,ip-<span class="number">172</span>-<span class="number">30</span>-<span class="number">0</span>-<span class="number">38</span>,root,localhost,<span class="number">29</span>,<span class="number">913</span>,<span class="keyword">READ</span>,company,ref_job_titles,</span><br><span class="line"><span class="symbol">20170817 </span><span class="number">16</span>:<span class="number">04</span>:<span class="number">33</span>,ip-<span class="number">172</span>-<span class="number">30</span>-<span class="number">0</span>-<span class="number">38</span>,root,localhost,<span class="number">29</span>,<span class="number">913</span>,<span class="keyword">READ</span>,company,org_departments,</span><br><span class="line"><span class="symbol">20170817 </span><span class="number">16</span>:<span class="number">04</span>:<span class="number">33</span>,ip-<span class="number">172</span>-<span class="number">30</span>-<span class="number">0</span>-<span class="number">38</span>,root,localhost,<span class="number">29</span>,<span class="number">913</span>,QUERY,company,</span><br><span class="line"><span class="comment">&#x27;SELECT * FROM employee_pay WHERE title LIKE \&#x27;%Executive%\&#x27; OR title LIKE \&#x27;%Manager%\&#x27;&#x27;,0</span></span><br></pre></td></tr></table></figure><br>下面是在MySQL中执行查询操作产生的audit日志，由最后一条可以看出，并没有READ类型的操作日志。<br><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">20191020 </span><span class="number">10</span>:<span class="number">48</span>:<span class="number">09</span>,delta-mysql,root,localhost,<span class="number">3</span>,<span class="number">31</span>,QUERY,wordpress,<span class="comment">&#x27;SELECT * FROM wp_options WHERE option_name LIKE \&#x27;%Executive%\&#x27; OR title LIKE \&#x27;%Manager%\&#x27;&#x27;,1054</span></span><br><span class="line"><span class="symbol">20191020 </span><span class="number">10</span>:<span class="number">48</span>:<span class="number">19</span>,delta-mysql,root,localhost,<span class="number">3</span>,<span class="number">32</span>,QUERY,wordpress,<span class="comment">&#x27;SELECT * FROM wp_options WHERE option_name LIKE \&#x27;%Executive%\&#x27; OR option_name LIKE \&#x27;%Manager%\&#x27;&#x27;,0</span></span><br></pre></td></tr></table></figure><br>通过查询<a href="http://www.mysqldbaservices.com/2016/03/11/mysql-mariadb-audit-plugin-installation-and-configuration/">资料</a>，TABLE事件只支持MariaDB 5.5.31 以及更新的版本，MySQL Server不提供MariaDB Audit Plugin需要的信息来追踪TABLE事件。</p><h2 id="三、参考资料"><a href="#三、参考资料" class="headerlink" title="三、参考资料"></a>三、参考资料</h2><p><a href="https://mariadb.com/kb/en/library/mariadb-audit-plugin-log-settings/">MariaDB Audit Plugin 官方文档</a><br><a href="http://www.mysqldbaservices.com/2016/03/11/mysql-mariadb-audit-plugin-installation-and-configuration/">MYSQL-MARIADB AUDIT PLUGIN INSTALLATION AND CONFIGURATION</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、安装MariaDB-Audit-Plugin&quot;&gt;&lt;a href=&quot;#一、安装MariaDB-Audit-Plugin&quot; class=&quot;headerlink&quot; title=&quot;一、安装MariaDB Audit Plugin&quot;&gt;&lt;/a&gt;一、安装MariaDB Au</summary>
      
    
    
    
    <category term="部署" scheme="https://www.delta1037.cn/categories/%E9%83%A8%E7%BD%B2/"/>
    
    
    <category term="MySQL" scheme="https://www.delta1037.cn/tags/MySQL/"/>
    
    <category term="审计" scheme="https://www.delta1037.cn/tags/%E5%AE%A1%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>CentOS 6安装GitLab服务端</title>
    <link href="https://www.delta1037.cn/2019/Deploy/CentOS-6%E5%AE%89%E8%A3%85gitlab%E6%9C%8D%E5%8A%A1%E7%AB%AF/"/>
    <id>https://www.delta1037.cn/2019/Deploy/CentOS-6%E5%AE%89%E8%A3%85gitlab%E6%9C%8D%E5%8A%A1%E7%AB%AF/</id>
    <published>2019-10-18T07:58:34.000Z</published>
    <updated>2020-12-11T17:31:04.083Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、配置基础环境"><a href="#一、配置基础环境" class="headerlink" title="一、配置基础环境"></a>一、配置基础环境</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">yum install openssh-server</span><br><span class="line">yum install postfix</span><br><span class="line">service postfix start</span><br><span class="line">chkconfig postfix on</span><br></pre></td></tr></table></figure><h2 id="二、下载安装gitlab"><a href="#二、下载安装gitlab" class="headerlink" title="二、下载安装gitlab"></a>二、下载安装gitlab</h2><p>gitlab安装包下载地址：<br>centos 6系统的下载地址:<a href="https://mirrors.tuna.tsinghua.edu.cn/gitlab-ce/yum/el6">https://mirrors.tuna.tsinghua.edu.cn/gitlab-ce/yum/el6</a><br>centos 7系统的下载地址:<a href="https://mirrors.tuna.tsinghua.edu.cn/gitlab-ce/yum/el7">https://mirrors.tuna.tsinghua.edu.cn/gitlab-ce/yum/el7</a><br>安装：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -i gitlab-ce-9.5.9-ce.0.el6.x86_64.rpm</span><br></pre></td></tr></table></figure></p><h2 id="三、配置gitlab"><a href="#三、配置gitlab" class="headerlink" title="三、配置gitlab"></a>三、配置gitlab</h2><p>修改gitlab配置文件指定服务器ip和自定义端口，将external_url后面的值修改为<a href="http://ip:port（例如http://192.168.7.89:8010，如果不指定端口则是默认的端口80）">http://ip:port（例如http://192.168.7.89:8010，如果不指定端口则是默认的端口80）</a><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/gitlab/gitlab.rb</span><br></pre></td></tr></table></figure></p><p>如果服务端开启了防火墙，则需要开放相应的端口<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -I INPUT -p tcp --dport 8010 -j ACCEPT</span><br></pre></td></tr></table></figure></p><p>按照新的配置文件重新配置gitlab，并重新启动<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gitlab-ctl reconfigure</span><br><span class="line">gitlab-ctl restart</span><br></pre></td></tr></table></figure><br>查看gitlab运行状态<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">gitlab-ctl status</span><br><span class="line"></span><br><span class="line"><span class="comment"># 得到如下输出</span></span><br><span class="line">run: gitaly: (pid 10798) 24009s; run: <span class="built_in">log</span>: (pid 4490) 24327s</span><br><span class="line">run: gitlab-monitor: (pid 10820) 24009s; run: <span class="built_in">log</span>: (pid 5099) 24297s</span><br><span class="line">run: gitlab-workhorse: (pid 10824) 24008s; run: <span class="built_in">log</span>: (pid 4654) 24321s</span><br><span class="line">run: logrotate: (pid 24622) 2407s; run: <span class="built_in">log</span>: (pid 4894) 24309s</span><br><span class="line">run: nginx: (pid 10887) 24007s; run: <span class="built_in">log</span>: (pid 4803) 24315s</span><br><span class="line">run: node-exporter: (pid 10896) 24007s; run: <span class="built_in">log</span>: (pid 5007) 24303s</span><br><span class="line">run: postgres-exporter: (pid 10908) 24006s; run: <span class="built_in">log</span>: (pid 5383) 24279s</span><br><span class="line">run: postgresql: (pid 10918) 24006s; run: <span class="built_in">log</span>: (pid 3780) 24391s</span><br><span class="line">run: prometheus: (pid 10926) 24005s; run: <span class="built_in">log</span>: (pid 5271) 24285s</span><br><span class="line">run: redis: (pid 10943) 24005s; run: <span class="built_in">log</span>: (pid 3615) 24398s</span><br><span class="line">run: redis-exporter: (pid 10947) 24005s; run: <span class="built_in">log</span>: (pid 5181) 24291s</span><br><span class="line">run: sidekiq: (pid 10959) 24004s; run: <span class="built_in">log</span>: (pid 4393) 24333s</span><br><span class="line">run: unicorn: (pid 10987) 24003s; run: <span class="built_in">log</span>: (pid 4292) 24339s</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><h3 id="bug0-GLIBC-2-14’-not-found"><a href="#bug0-GLIBC-2-14’-not-found" class="headerlink" title="bug0:`GLIBC_2.14’ not found"></a>bug0:`GLIBC_2.14’ not found</h3><p>如果出现报错/lib64/libc.so.6: version `GLIBC_2.14’ not found，则需要升级glibc<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下载安装包</span></span><br><span class="line">wget http://ftp.gnu.org/gnu/glibc/glibc-2.14.tar.gz</span><br><span class="line">tar zxvf glibc-2.14.tar.gz</span><br><span class="line"><span class="built_in">cd</span> glibc-2.14</span><br><span class="line">mkdir build</span><br><span class="line"><span class="built_in">cd</span> build</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译安装</span></span><br><span class="line">../configure --prefix=/opt/glibc-2.14</span><br><span class="line">make -j4</span><br><span class="line">make install</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置链接库目录</span></span><br><span class="line"><span class="built_in">export</span> LD_LIBRARY_PATH=/opt/glibc-2.14/lib</span><br></pre></td></tr></table></figure></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、配置基础环境&quot;&gt;&lt;a href=&quot;#一、配置基础环境&quot; class=&quot;headerlink&quot; title=&quot;一、配置基础环境&quot;&gt;&lt;/a&gt;一、配置基础环境&lt;/h2&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td cla</summary>
      
    
    
    
    <category term="部署" scheme="https://www.delta1037.cn/categories/%E9%83%A8%E7%BD%B2/"/>
    
    
    <category term="GitLab" scheme="https://www.delta1037.cn/tags/GitLab/"/>
    
  </entry>
  
  <entry>
    <title>Install Oracle Database 9i on CentOS 5 (i386)</title>
    <link href="https://www.delta1037.cn/2019/Deploy/Install-Oracle-Database-9i-on-CentOS-5-i386/"/>
    <id>https://www.delta1037.cn/2019/Deploy/Install-Oracle-Database-9i-on-CentOS-5-i386/</id>
    <published>2019-10-14T03:17:38.000Z</published>
    <updated>2020-12-11T17:31:03.224Z</updated>
    
    <content type="html"><![CDATA[<p>Oracle Database 9i的官方安装环境为RHEL3，RHEL4。由于项目需要，需要同时安装Oracle Database 9i和日志采集工具rsyslog，rsyslog仅支持RHEL/CENTOS 5及其以上的版本，最终在<a href="http://archive.kernel.org/centos-vault/5.0/isos/i386/">CentOS 5 (i386)</a>版本上安装成功。</p><h2 id="一、软件下载："><a href="#一、软件下载：" class="headerlink" title="一、软件下载："></a>一、软件下载：</h2><ol><li>Oracle9i Database Release 2 Enterprise/Standard Edition for Intel Linux（ship_9204_linux_disk）：<a href="http://stararly.com/DataBase/3432.html">迅雷</a> <a href="https://pan.baidu.com/s/1cqR1YYu9aBGxq1Kq4AtNvA">百度网盘提取码：ve9y</a></li><li><p>补丁：</p></li><li><p><a href="http://oss.oracle.com/projects/compat-oracle/dist/files/RedHat/compat-libcwait-2.1-1.i386.rpm">compat-libcwait-2.1-1.i386.rpm</a></p></li><li><p><a href="http://oss.oracle.com/projects/compat-oracle/dist/files/RedHat/compat-oracle-rhel4-1.0-5.i386.rpm">compat-oracle-rhel4-1.0-5.i386.rpm</a></p></li><li><p><a href="https://www.oracle.com/java/technologies/java-archive-javase-v13-downloads.html">j2re-1_3_1_19-linux-i586.bin</a></p></li></ol><h2 id="二、开始安装"><a href="#二、开始安装" class="headerlink" title="二、开始安装"></a>二、开始安装</h2><h3 id="1、关闭SELinux"><a href="#1、关闭SELinux" class="headerlink" title="1、关闭SELinux"></a>1、关闭SELinux</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gedit /etc/selinux/config</span><br><span class="line"><span class="built_in">set</span> SELINUX=disabled</span><br></pre></td></tr></table></figure><h3 id="2、-安装JRE"><a href="#2、-安装JRE" class="headerlink" title="2、 安装JRE"></a>2、 安装JRE</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">chmod +x j2re-1_3_1_19-linux-i586.bin</span><br><span class="line">./j2re-1_3_1_19-linux-i586.bin</span><br><span class="line">mv jre1.3.1_19 /usr/<span class="built_in">local</span>/</span><br></pre></td></tr></table></figure><h3 id="3、安装缺少的依赖"><a href="#3、安装缺少的依赖" class="headerlink" title="3、安装缺少的依赖"></a>3、安装缺少的依赖</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 检查依赖缺失</span></span><br><span class="line">rpm -q compat-db compat-gcc-34 compat-gcc-34-c++ \</span><br><span class="line">  compat-libgcc-296 compat-libstdc++-296 compat-libstdc++-33 \</span><br><span class="line">  gcc gcc-c++ glibc glibc-common glibc-devel glibc-headers libgcc make libXp</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用yum安装依赖</span></span><br><span class="line">yum install compat-db*</span><br><span class="line">yum install compat-gcc*</span><br><span class="line">yum install gcc*</span><br><span class="line">yum install compat-libgcc*</span><br><span class="line">yum install compat-libstdc++*</span><br><span class="line">yum install gnome-libs*</span><br><span class="line">yum install libaio*</span><br><span class="line">yum install openmotif*</span><br><span class="line">yum install xorg-x11-deprecated-libs*</span><br><span class="line">yum install glibc-devel*</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装补丁</span></span><br><span class="line">rpm -Uvh compat-libcwait-2.1-1.i386.rpm</span><br><span class="line">rpm -Uvh compat-oracle-rhel4-1.0-5.i386.rpm --nodeps</span><br></pre></td></tr></table></figure><h3 id="4、配置环境"><a href="#4、配置环境" class="headerlink" title="4、配置环境"></a>4、配置环境</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/lib</span><br><span class="line">ln -s libstdc++-3-libc6.2-2-2.10.0.so libstdc++-libc6.1-1.so.2</span><br><span class="line">ln -s libgdbm.so.2.0.0 libdb.so.2</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> /usr/bin</span><br><span class="line">ln -s gcc34 gcc32</span><br></pre></td></tr></table></figure><h3 id="5、添加oracle组和用户"><a href="#5、添加oracle组和用户" class="headerlink" title="5、添加oracle组和用户"></a>5、添加oracle组和用户</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">groupadd oinstall <span class="comment">#添加oinstall组</span></span><br><span class="line">groupadd dba <span class="comment"># 添加dba组</span></span><br><span class="line">useradd -g oinstall -G dba oracle <span class="comment">#新建用户并添加到组</span></span><br><span class="line">passwd oracle <span class="comment">#按照输出设置密码</span></span><br></pre></td></tr></table></figure><h3 id="6、建立安装目录"><a href="#6、建立安装目录" class="headerlink" title="6、建立安装目录"></a>6、建立安装目录</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /opt</span><br><span class="line">mkdir oracle <span class="comment"># 创建oracle目录</span></span><br><span class="line">chown –R oracle.oinstall oracle <span class="comment">#修改oracle目录权限</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> oracle</span><br><span class="line">mkdir 920 <span class="comment"># 创建9i安装目录</span></span><br></pre></td></tr></table></figure><h3 id="7、-配置环境变量和系统设置"><a href="#7、-配置环境变量和系统设置" class="headerlink" title="7、 配置环境变量和系统设置"></a>7、 配置环境变量和系统设置</h3><p>以oracle用户登陆，打开/u01/oracle/.bash_profile，在文件末尾追加如下内容<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ORACLE_BASE=/opt/oracle; <span class="built_in">export</span> ORACLE_BASE</span><br><span class="line">ORACLE_HOME=<span class="variable">$ORACLE_BASE</span>/920; <span class="built_in">export</span> ORACLE_HOME</span><br><span class="line">ORACLE_SID=orcl; <span class="built_in">export</span> ORACLE_SID</span><br><span class="line">LD_LIBRARY_PATH=<span class="variable">$ORACLE_HOME</span>/lib; <span class="built_in">export</span> LD_LIBRARY_PATH</span><br><span class="line">ORACLE_OEM_JAVARUNTIME=/usr/<span class="built_in">local</span>/jre1.3.1_19; <span class="built_in">export</span> ORACLE_OEM_JAVARUNTIME</span><br><span class="line">PATH=<span class="variable">$PATH</span>:<span class="variable">$ORACLE_HOME</span>/bin; <span class="built_in">export</span> PATH</span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$USER</span> = <span class="string">&quot;oracle&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">  <span class="keyword">if</span> [ <span class="variable">$SHELL</span> = <span class="string">&quot;/bin/ksh&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">ulimit</span> -p 16384</span><br><span class="line">    <span class="built_in">ulimit</span> -n 65536</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">ulimit</span> -u 16384 -n 65536</span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><br>以root用户登陆，打开/etc/sysctl.conf，在文件末尾追加如下内容，并执行sysctl -p生效<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">kernel.shmmni = 4096</span><br><span class="line">kernel.sem = 250 32000 100 128</span><br><span class="line">fs.file-max = 65536</span><br><span class="line">net.ipv4.ip_local_port_range = 1024 65000</span><br><span class="line">net.core.rmem_default=262144</span><br><span class="line">net.core.wmem_default=262144</span><br><span class="line">net.core.rmem_max=262144</span><br><span class="line">net.core.wmem_max=262144</span><br></pre></td></tr></table></figure></p><p>打开/etc/security/limits.conf，在文件末尾追加如下内容<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">oracle soft nofile 65536</span><br><span class="line">oracle hard nofile 65536</span><br><span class="line">oracle soft nproc 16384</span><br><span class="line">oracle hard nproc 16384</span><br></pre></td></tr></table></figure></p><h3 id="8、文件准备"><a href="#8、文件准备" class="headerlink" title="8、文件准备"></a>8、文件准备</h3><p>a）从网上下载oracle Database 9i有三个文件<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ship_9204_linux_disk1.cpio.gz</span><br><span class="line">ship_9204_linux_disk2.cpio.gz</span><br><span class="line">ship_9204_linux_disk3.cpio.gz</span><br></pre></td></tr></table></figure></p><p>b）对压缩文件解压<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gunzip ship_9204_linux_disk1.cpio.gz</span><br><span class="line">gunzip ship_9204_linux_disk2.cpio.gz</span><br><span class="line">gunzip ship_9204_linux_disk3.cpio.gz</span><br></pre></td></tr></table></figure></p><p>c）使用如下命令解压得到Disk1、Disk2和Disk3文件夹<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cpio -idmv &lt; ship_9204_linux_disk1.cpio</span><br><span class="line">cpio -idmv &lt; ship_9204_linux_disk2.cpio</span><br><span class="line">cpio -idmv &lt; ship_9204_linux_disk3.cpio</span><br></pre></td></tr></table></figure></p><h3 id="9、-开始安装"><a href="#9、-开始安装" class="headerlink" title="9、 开始安装"></a>9、 开始安装</h3><p>进入Disk1目录，执行./ runInstaller开始图形界面的安装程序，选择自己喜欢的版本进行安装，一路next就可以</p><h4 id="备注："><a href="#备注：" class="headerlink" title="备注："></a>备注：</h4><p>1、终端界面可能出现Inside isCluster, bCluster bfr return is : false，不影响后续使用<br>2、在最后的configuration阶段会发生错误如下</p><p><img src="https://delta1037.oss-cn-beijing.aliyuncs.com/hexo-blog/centos5_install_oracle_9i/centos5_install_oracle_9i.png" alt=""></p><p>此时退出安装程序，进行如下操作</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> <span class="variable">$ORACLE_HOME</span></span><br><span class="line">rm JRE</span><br><span class="line">ln -s <span class="variable">$ORACLE_BASE</span>/jre/1.3.1 JRE</span><br><span class="line"><span class="built_in">cd</span> JRE/bin</span><br><span class="line">ln -s java jre</span><br><span class="line"><span class="built_in">cd</span> i386/native_threads/</span><br><span class="line">ln -s java jre</span><br></pre></td></tr></table></figure><p>然后再执行./ runInstaller走一遍安装流程即可</p><h2 id="三、使用"><a href="#三、使用" class="headerlink" title="三、使用"></a>三、使用</h2><h3 id="1、建立数据库"><a href="#1、建立数据库" class="headerlink" title="1、建立数据库"></a>1、建立数据库</h3><p>进入/u01/oracle/product/bin目录，运行dbca命令，进入建立数据库的图形界面，根据界面提示进行操作</p><h3 id="2、使用过程中可能会遇到的问题"><a href="#2、使用过程中可能会遇到的问题" class="headerlink" title="2、使用过程中可能会遇到的问题"></a>2、使用过程中可能会遇到的问题</h3><p>a）startup 出现LRM-00109: could not open parameter file …：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /opt/oracle /admin/sxf/pfile <span class="comment">#sxf是dbca新建的数据库名</span></span><br><span class="line">cp init.ora.* /opt/oracle/920/dbs/initmyoracle.ora</span><br></pre></td></tr></table></figure></p><p>b）startup出现ORA-01990: error opening password file ‘/opt/oracle/920/dbs/orapw’<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /opt/oracle/920/bin</span><br><span class="line">orapwd file=/opt/oracle/920/dbs/orapw passwd=sxf123 entries=1024</span><br></pre></td></tr></table></figure></p><h2 id="四、个人经验"><a href="#四、个人经验" class="headerlink" title="四、个人经验"></a>四、个人经验</h2><p>1、以CentOS 5（x86_64）无法完成amd64_db_9204_Disk1.cpio.gz的安装<br>2、以CentOS 4（x86_64）可以完成amd64_db_9204_Disk1.cpio.gz的安装</p><h2 id="五、参考文献"><a href="#五、参考文献" class="headerlink" title="五、参考文献"></a>五、参考文献</h2><p>1、<a href="http://nirajkvinit.blogspot.com/2008/10/installing-oracle-9i-on-rhel5.html">Installing Oracle 9i on RHEL5. (x86)</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Oracle Database 9i的官方安装环境为RHEL3，RHEL4。由于项目需要，需要同时安装Oracle Database 9i和日志采集工具rsyslog，rsyslog仅支持RHEL/CENTOS 5及其以上的版本，最终在&lt;a href=&quot;http://arc</summary>
      
    
    
    
    <category term="部署" scheme="https://www.delta1037.cn/categories/%E9%83%A8%E7%BD%B2/"/>
    
    
    <category term="Oracle Database 9i" scheme="https://www.delta1037.cn/tags/Oracle-Database-9i/"/>
    
  </entry>
  
  <entry>
    <title>Linux启动过程分析</title>
    <link href="https://www.delta1037.cn/2019/Linux/Linux%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/"/>
    <id>https://www.delta1037.cn/2019/Linux/Linux%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/</id>
    <published>2019-10-14T03:09:25.000Z</published>
    <updated>2020-12-11T17:31:06.629Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第一阶段-BIOS"><a href="#第一阶段-BIOS" class="headerlink" title="第一阶段-BIOS"></a>第一阶段-BIOS</h2><p>计算机通电后，首先会区读取ROM芯片中的开机程序（基本输入输出系统/BIOS）</p><h3 id="1-1-硬件自检"><a href="#1-1-硬件自检" class="headerlink" title="1.1 硬件自检"></a>1.1 硬件自检</h3><p>BIOS程序首先检查计算机硬件是否满足运行的基本条件—<strong>硬件自检</strong>（POST）</p><p>CMOS：存储硬件的各项参数。</p><h3 id="1-2-启动顺序"><a href="#1-2-启动顺序" class="headerlink" title="1.2 启动顺序"></a>1.2 启动顺序</h3><p>硬件自检完成后，BIOS把控制权交给下一阶段的启动程序。</p><p>这时，BIOS需要知道下一阶段的启动程序在哪个设备，也就是BIOS需要有一个外部存储设备排序，排在前边的设备就是优先转交控制权的设备。这个排序叫<strong>启动顺序</strong>。</p><h2 id="第二阶段-主引导记录"><a href="#第二阶段-主引导记录" class="headerlink" title="第二阶段-主引导记录"></a>第二阶段-主引导记录</h2><p>BIOS把控制权交给排在第一位的存储设备。</p><p>计算机读取此设备的第一个扇区（最前边的512个字节，叫做<strong>主引导记录</strong><Master boot record，缩写为**MBR**>），如果这个扇区最后两个字节是0x55和0xAA，表明设备可以启动；如果不是，表明设备不能启动，控制权交给启动顺序中的下一个 设备。</p><h3 id="2-1-主引导记录结构"><a href="#2-1-主引导记录结构" class="headerlink" title="2.1 主引导记录结构"></a>2.1 主引导记录结构</h3><div class="table-container"><table><thead><tr><th>范围/字节</th><th>作用</th></tr></thead><tbody><tr><td>1-446</td><td>调用操作系统的机器码</td></tr><tr><td>447-510</td><td>分区表：将磁盘分为若干个区</td></tr><tr><td>511-512</td><td>主引导记录签名</td></tr></tbody></table></div><h3 id="2-2-分区表"><a href="#2-2-分区表" class="headerlink" title="2.2 分区表"></a>2.2 分区表</h3><p>考虑到每个区可以安装不同的操作系统，主引导记录必须知道将控制权交给哪个区。</p><p>分区表长度有64个字节，里面分为四项（所以一个硬盘最多有四个一级分区，又叫主分区），每一项16个字节</p><p>主分区16个字节组成：</p><div class="table-container"><table><thead><tr><th>范围/字节</th><th>作用</th></tr></thead><tbody><tr><td>1-1</td><td>如果为0x80，就表示该分区是激活分区，控制权要交给这个分区。四个分区里面只能有一个是激活的</td></tr><tr><td>2-4</td><td>主分区第一个扇区的物理位置（柱面、磁头、扇区号）</td></tr><tr><td>5-5</td><td>主分区类型</td></tr><tr><td>6-8</td><td>主分区最后一个扇区的物理位置</td></tr><tr><td>9-12</td><td>该主分区第一个扇区的逻辑地址</td></tr><tr><td>13-16</td><td>主分区的扇区总数</td></tr></tbody></table></div><h2 id="第三阶段-硬盘启动"><a href="#第三阶段-硬盘启动" class="headerlink" title="第三阶段-硬盘启动"></a>第三阶段-硬盘启动</h2><p>这时，计算机的控制权就交给了硬盘的某个分区了</p><h3 id="3-1-情况A：卷引导记录"><a href="#3-1-情况A：卷引导记录" class="headerlink" title="3.1 情况A：卷引导记录"></a>3.1 情况A：卷引导记录</h3><p>计算机会读取激活分区的第一个扇区，叫做卷引导记录（Volume boot record，VBR）</p><p>卷引导记录告诉计算机，操作系统在这个分区的位置。然后计算机就会加载操作系统了。</p><h3 id="3-2-情况B：扩展分区和逻辑分区"><a href="#3-2-情况B：扩展分区和逻辑分区" class="headerlink" title="3.2 情况B：扩展分区和逻辑分区"></a>3.2 情况B：扩展分区和逻辑分区</h3><p>随着硬盘越来越大，四个分区已经不够了，需要更多分区。于是规定有一个分区可以定义为扩展分区（里面又分了好多个区，叫逻辑分区）。</p><p>计算机首先读取扩展分区的第一个扇区，叫扩展引导记录（EBR）。它里面包含一张64字节的分区表，但是最多只有两项（也就是两个逻辑分区，包括它自身的分区表和下一个分区的分区表）。从里面找到第二个逻辑分区的位置，直到找到一个分区里面只包含它自己的分区表为止。</p><h3 id="3-3-情况C：启动管理器"><a href="#3-3-情况C：启动管理器" class="headerlink" title="3.3 情况C：启动管理器"></a>3.3 情况C：启动管理器</h3><p>在这种情况下，计算机读取主引导记录前446个字节的机器码之后，不把控制权交给某一个分区，而是运行启动管理器（boot loader），由用户选择启动哪一个操作系统。</p><p>Linux环境中，最流行的启动管理器是Grub。</p><h2 id="第四阶段-操作系统"><a href="#第四阶段-操作系统" class="headerlink" title="第四阶段-操作系统"></a>第四阶段-操作系统</h2><p>控制权交给操作系统之后，操作系统的内核首先载入内存。</p><p>所有进程的祖先叫进程0，idle进程，或者由于历史的原因叫做swapper进程。</p><p>start_kernel()函数初始化内核需要的所有数据结构，激活终端，创建另一个叫做进程1的内核线程（一般叫做init进程），创建init进程之后，进程0执行cpu_idle()函数，该函数本质上是在开中断的情况下重复之星hlt汇编指令。当 没有其他进程处于TASK_RUNNING才选择执行进程0。</p><p><strong>多处理器系统</strong>中每个CPU都有一个进程0，计算机启动之后首先启动一个CPU，禁用其他CPU，swapper进程进程初始化内核数据结构，通过copy_process()函数创建另外的swapper进程。</p><p>进程0创建的内核线程执行init()函数，init()依次完成内核初始化。init()调用execve()系统调用装入可执行程序init，结果init内核线程变成了一个普通进程。</p><p>以Linux系统为例，首先载入/boot目录下面的kernel。内核加载成功后（如上），第一个运行的程序是/sbin/init，它根据配置文件产生init进程，pid进程编号为1，其它进程都是它的后代。</p><p>然后init进程加载系统的各个模块，比如窗口和网络程序，直到/bin/login程序，跳出登录页面。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="http://www.ruanyifeng.com/blog/2013/02/booting.html">计算机是如何启动的</a></li><li>深入理解Linux内核</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;第一阶段-BIOS&quot;&gt;&lt;a href=&quot;#第一阶段-BIOS&quot; class=&quot;headerlink&quot; title=&quot;第一阶段-BIOS&quot;&gt;&lt;/a&gt;第一阶段-BIOS&lt;/h2&gt;&lt;p&gt;计算机通电后，首先会区读取ROM芯片中的开机程序（基本输入输出系统/BIOS）&lt;/p</summary>
      
    
    
    
    <category term="Linux" scheme="https://www.delta1037.cn/categories/Linux/"/>
    
    
    <category term="Linux小系统" scheme="https://www.delta1037.cn/tags/Linux%E5%B0%8F%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>点石成金，挥刀琢玉——“双创老太”刘玉那些事儿</title>
    <link href="https://www.delta1037.cn/2019/DianGroup/%E8%8B%B1%E9%9B%84%E4%BC%9A%E5%88%98%E8%80%81%E5%B8%88%E4%BB%8B%E7%BB%8D/"/>
    <id>https://www.delta1037.cn/2019/DianGroup/%E8%8B%B1%E9%9B%84%E4%BC%9A%E5%88%98%E8%80%81%E5%B8%88%E4%BB%8B%E7%BB%8D/</id>
    <published>2019-08-21T11:14:55.000Z</published>
    <updated>2020-12-11T17:31:04.449Z</updated>
    
    <content type="html"><![CDATA[<h1 id="点石成金，挥刀琢玉——“双创老太”刘玉那些事儿"><a href="#点石成金，挥刀琢玉——“双创老太”刘玉那些事儿" class="headerlink" title="点石成金，挥刀琢玉——“双创老太”刘玉那些事儿"></a>点石成金，挥刀琢玉——“双创老太”刘玉那些事儿</h1><p>   高调、爱折腾、不走寻常路、犀利、“毒舌”、超级大忙人，她是被贴满标签的华中大教授——刘玉老师。而其中最响亮，最广为人知的标签，一定非“双创老太”莫属。今天，让我们走近这神秘的刘玉教授，说一说，她的那些事儿——</p><p><span style="font-size:20px;color:white;background-color: red;font-weight:bold;">她是谁——</span></p><ul><li>湖北省创业红娘众创空间        负责人</li><li>武汉创业红娘公益服务中心     理事长</li><li>华中科技大学    电信学院      教   授</li><li>华中科技大学    Dian团队      创始人</li></ul><hr><p><span style="font-size:20px;color:white;background-color: red;font-weight:bold;">她都做过什么——</span></p><p><span style="font-size:16px;color:red;font-weight:bold;">扶弟子创新</span></p><p>   曾指导本科生获全国挑战杯特等奖，Dian团队育人模式获国家教学成果二等奖，教育部大学生创新性实验计划的“源头”之一，央视小崔说事栏目曾以“点亮未来”专题报道，曾应邀到全国高校、中学、企事业等逾百家单位作创新创业报告，引起强烈反响。曾获评“全国师德先进个人”和湖北省“五一劳动奖章”、湖北省教育系统“三育人”奖、 宝钢优秀教师特等奖的提名奖、两次获华中科技大学教学质量优秀一等奖。<br>     在她严格要求和精心培养下，Dian团队出站队员500多人在社会上总体表现优异，近7年涌现出50余家创业公司，其中贝贝网和贝店已成为独角兽，释码大华、ping++、悦然心动等创业公司业绩斐然，4人荣登福布斯中国30位“30岁以下创业者”榜单。</p><p><span style="font-size:16px;color:red;font-weight:bold;">帮他人创业</span></p><p>  2015年3月，刘玉创办“武汉市洪山区创业红娘公益服务中心”，义务为优秀创业项目与投资机构牵线搭桥，创业项目的甄选范围从华中科技大学在校生拓宽至全社会，不分地域、不分年龄、不分学校、不分学历。至今，经刘玉老师推荐的创业项目已超过500个，融资成交率13.2%，促成投资总额2.57亿元。</p><hr><p><span style="font-size:20px;color:white;background-color: red;font-weight:bold;">她的那些事儿——</span></p><ul><li><a href="http://szbold.cjn.cn/cjrb/html/2015-12/25/content_5498033.htm"><span style="color:red;font-size:18px;">刘玉:创客点睛手——《长江日报》</span></a></li></ul><ul><li><a href="https://www.chsi.com.cn/jyzx/200711/20071108/1493323.html"><span style="color:orange;font-size:18px;">创新潜能在实践中尽情释放——《中国教育报》网络版</span></a></li></ul><ul><li><a href="http://hb.people.com.cn/n2/2016/0115/c337099-27552249.html"><span style="color:red;font-size:18px;">人民网专访“创业红娘”刘玉：如何做到人靠谱、事落实、有情怀</span></a></li></ul><ul><li><a href="http://zqb.cyol.com/html/2016-01/19/nw.D110000zgqnb_20160119_2-10.htm"><span style="color:orange;font-size:18px;">刘玉：被“强推转身”的创业红娘——《中国青年报》</span></a></li></ul><ul><li><a href="http://cjrb.cjn.cn/html/2018-04/04/content_67430.htm"><span style="color:red;font-size:18px;">全国布撒“姻缘线”的“创业红娘” ——武汉首个创业服务公益机构实录——《长江日报》</span></a></li></ul><ul><li><a href="http://news.cnhubei.com/xw//sh/201604/t3592740.shtml"><span style="color:orange;font-size:18px;">武汉女教授入选“中国好人” 免费孵出50多家公司——荆楚网</span></a></li></ul><ul><li><a href="http://hb.people.com.cn/n2/2017/0526/c337099-30246043.html"><span style="color:red;font-size:18px;">华科Dian团队15年走出10余家“过亿”企业——人民网</span></a></li></ul><ul><li><a href="http://cppcc.people.com.cn/GB/35377/11493611.html"><span style="color:orange;font-size:18px;">崔永元“说事”设“圈套” 女教授均“化险为夷”——中国政协新闻网</span> </a></li></ul><ul><li><a href="http://www.cnki.com.cn/Article/CJFDTotal-DYXS201409005.htm"><span style="color:red;font-size:18px;">“点”下种子——访谈华中科技大学“点团队”创始人刘玉教授——《大学生》</span></a></li></ul><ul><li><a href="https://www.chsi.com.cn/jyzx/200711/20071108/1493323.html"><span style="color:orange;font-size:18px;">华科创客点睛手刘玉讲述：张小龙在武汉首提微信产品观——荆楚网</span></a></li></ul><ul><li><a href="http://hustxb.cuepa.cn/show_more.php?tkey=&amp;bkey=&amp;doc_id=235846"><span style="color:red;font-size:18px;">刘延东寄语Dian团队———在实践中释放创新潜能</span></a></li></ul><ul><li><a href="http://zqb.cyol.com/html/2014-06/26/nw.D110000zgqnb_20140626_3-07.htm"><span style="color:orange;font-size:18px;">华中科大教授刘玉：人才标准固化扼杀大学生创新热情——《中国青年报》</span></a></li></ul><ul><li><a href="http://archive.wenming.cn/jddzhr/2010-04/02/content_19412216_2.htm"><span style="color:red;font-size:18px;">华中科技大学刘玉教授：未来工程师“点”亮江城 </span></a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;点石成金，挥刀琢玉——“双创老太”刘玉那些事儿&quot;&gt;&lt;a href=&quot;#点石成金，挥刀琢玉——“双创老太”刘玉那些事儿&quot; class=&quot;headerlink&quot; title=&quot;点石成金，挥刀琢玉——“双创老太”刘玉那些事儿&quot;&gt;&lt;/a&gt;点石成金，挥刀琢玉——“双创老太”</summary>
      
    
    
    
    <category term="Dian团队" scheme="https://www.delta1037.cn/categories/Dian%E5%9B%A2%E9%98%9F/"/>
    
    
  </entry>
  
</feed>
