<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Delta1037</title>
  
  <subtitle>技术是纯净的</subtitle>
  <link href="https://www.delta1037.cn/atom.xml" rel="self"/>
  
  <link href="https://www.delta1037.cn/"/>
  <updated>2021-01-17T08:41:59.576Z</updated>
  <id>https://www.delta1037.cn/</id>
  
  <author>
    <name>delta1037</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>圣诞树彩灯曲线方程</title>
    <link href="https://www.delta1037.cn/2020/Math/%E5%9C%A3%E8%AF%9E%E6%A0%91%E5%BD%A9%E7%81%AF%E6%9B%B2%E7%BA%BF%E6%96%B9%E7%A8%8B/"/>
    <id>https://www.delta1037.cn/2020/Math/%E5%9C%A3%E8%AF%9E%E6%A0%91%E5%BD%A9%E7%81%AF%E6%9B%B2%E7%BA%BF%E6%96%B9%E7%A8%8B/</id>
    <published>2020-12-19T14:18:31.000Z</published>
    <updated>2021-01-17T08:41:59.576Z</updated>
    
    <content type="html"><![CDATA[<h1 id="圣诞树彩灯曲线方程"><a href="#圣诞树彩灯曲线方程" class="headerlink" title="圣诞树彩灯曲线方程"></a>圣诞树彩灯曲线方程</h1><p>马上就要圣诞节了，圣诞树上会绕一圈彩灯，以表对圣诞节的敬意，淦！</p><p>对于一个圣诞树，绕的一圈的彩灯的曲线是什么样的呢？侧面看起来是什么样的？如果彩灯曲线上彩灯分布式均匀的，那么彩灯的位置该怎么计算？</p><p>本文假设圣诞树是一个圆锥体，彩灯从顶端开始等梯度绕线，并绕了整数圈，如下图所示：</p><p><img src="https://delta1037.oss-cn-beijing.aliyuncs.com/hexo-blog/christmas_tree_equation/view.png" alt=""></p><p>本文主要固定值：</p><ul><li>H：圆锥体高</li><li>W：圆锥体底面直径</li><li>A：圆锥顶点</li><li>O：圆锥底面圆心</li><li>M：绕线与底面的交点</li><li>Q：绕线的圈数</li><li>T：彩灯的间隔距离</li></ul><h2 id="一、建立三维的彩灯曲线方程"><a href="#一、建立三维的彩灯曲线方程" class="headerlink" title="一、建立三维的彩灯曲线方程"></a>一、建立三维的彩灯曲线方程</h2><p>以圆锥的底面圆心O为基准，在底面上建立极坐标系；以从圆锥顶点A到圆锥底面圆心O方向为$Z$轴；建立坐标系，如下图所示</p><p><img src="https://delta1037.oss-cn-beijing.aliyuncs.com/hexo-blog/christmas_tree_equation/view_axi_draw.png" alt=""></p><p>绕线的圈数是Q，所以绕线的总角度是 $2{\pi}Q$，由于绕线是均匀的，所以$Z$轴方向的$h$和极坐标平面上的曲线半径$l$都是均匀变化的，所以曲线方程如下：</p><script type="math/tex; mode=display">f(\theta, l, h)\begin{cases}\theta=\theta , &0 \le \theta \le 2{\pi}Q \\l = { {W\theta}\over{4{\pi}Q} }, \\h = { {H\theta}\over{2{\pi}Q} }, \end{cases}</script><p>其中：</p><p>曲线半径最大是$W\over2$，在$\theta \in[0, 2{\pi}Q]$的范围内均匀变化所以$l = { { W\over2 }\over{2{\pi}Q}  }\theta = { {W\theta}\over{4{\pi}Q} }$</p><p>圆锥高为$H$，在$\theta \in[0, 2{\pi}Q]$的范围内均匀变化所以$l = { { H }\over{2{\pi}Q}  }\theta = { {H\theta}\over{2{\pi}Q} }$</p><h2 id="二、俯视图的彩灯曲线"><a href="#二、俯视图的彩灯曲线" class="headerlink" title="二、俯视图的彩灯曲线"></a>二、俯视图的彩灯曲线</h2><p>圣诞树上彩灯从树的俯视图方向看如下：</p><p><img src="https://delta1037.oss-cn-beijing.aliyuncs.com/hexo-blog/christmas_tree_equation/top_view.png" alt="俯视图效果"></p><p>为什么俯视图（像）是螺旋线呢？俯视图去掉了三维视图中高的特征，所以可以在俯视图上建立极坐标系，如下如所示：</p><p><img src="https://delta1037.oss-cn-beijing.aliyuncs.com/hexo-blog/christmas_tree_equation/top_view-axi-draw.png" alt="俯视图坐标系"></p><p>从三维坐标系中抽出极坐标平面相关的变量，由于三维坐标系中的曲线方程$f(\theta, l, h)$组成的方程中与极坐标平面相关的变量$\theta,l$与$h$没有关系，所以俯视图彩灯曲线方程如下：</p><script type="math/tex; mode=display">l = f(\theta) = { {W\theta}\over{4{\pi}Q} }  \ \ \ \ \ \ \ 0 \le \theta \le 2{\pi}Q \\</script><p>其中：</p><p>$l$是随$\theta$均匀变化的，所以俯视图是平面上的螺旋线。</p><h2 id="三、主视图的彩灯曲线"><a href="#三、主视图的彩灯曲线" class="headerlink" title="三、主视图的彩灯曲线"></a>三、主视图的彩灯曲线</h2><p>圣诞树上的彩灯从树的主视图方向看如下：</p><p><img src="https://delta1037.oss-cn-beijing.aliyuncs.com/hexo-blog/christmas_tree_equation/main_view.png" alt=""></p><p>主视图为什么长这个样子呢？主视图上关于三维坐标系中的$h$相关的特征是没有损失的，那么关于螺旋线在主视图上的投影是什么样的呢？</p><p>我们可以在俯视图的螺旋线上看（如下图所示），我们对于螺旋线的任何一个位置，向极坐标的起始位置作垂线（起始位置是与主视图方向平行的），也就是在$\theta$处，我们在主视图方向看到的偏离圆锥中轴线方向的长度是$l*cos(\theta)$。</p><p><img src="https://delta1037.oss-cn-beijing.aliyuncs.com/hexo-blog/christmas_tree_equation/top_view-axi-draw-fuzhu.png" alt=""></p><p>我们在主视图上建立如下坐标系：</p><p><img src="https://delta1037.oss-cn-beijing.aliyuncs.com/hexo-blog/christmas_tree_equation/main_view-axi-draw.png" alt=""></p><p>所以根据以上的分析，在$h$方向是随$\theta$均匀变化的，在$w$方向，坐标长度是$l*cos(\theta)$，但是在主视图的坐标系中不存在$\theta$变量，所以我们使用h变量来替换掉$\theta$，根据彩灯的三维曲线方程，我们知道$h = { {H\theta}\over{2{\pi}Q} }$，所以$\theta$使用$h$来表示则是$\theta = { {2{\pi}Qh}\over{H} }$，$l$使用$\theta$替换可得$l = { {W\theta}\over{4{\pi}Q} }$。所以在$w$方向，$w = l\ cos(\theta) = { {W\theta}\over{4{\pi}Q} } \ cos(\theta) = {Wh\over2H}\ cos({ {2{\pi}Qh}\over{H} })$ 。所以主视图上的方程如下：</p><script type="math/tex; mode=display">w = f(h) = {Wh\over2H}\ cos({ {2{\pi}Qh}\over{H} })  \ \ \ \ \ \ \ 0 \le h \le H \\</script><p>其中：</p><p>$w$的核心为$h \ cos(h)$，该函数是一次函数$h$和三角函数$cos(h)$的乘积，即使用一次函数$h$对三角函数$cos(h)$的范围进行了限制。</p><h2 id="四、主视图上彩灯位置方程"><a href="#四、主视图上彩灯位置方程" class="headerlink" title="四、主视图上彩灯位置方程"></a>四、主视图上彩灯位置方程</h2><p>俯视图上来看彩灯的间隔距离是不相等的（由于俯视图上将曲线等梯度下降这一特性抹掉了，彩灯实际的距离应该是$\sqrt{ 彩灯间隔对应梯度^2 + 俯视图彩灯间隔^2 }$，联想到小时候见到的一个三角形纸片卷在铅笔上从而类似盘山公路，将螺旋线展开<strong>可能</strong>也是一个直角三角形，将盘山公路这一想法对应到螺旋线中，从三维方程中可知，$h = { {H \theta}\over{2{\pi}Q} } $，即$h$是随着$\theta$线性变化的，即盘上公路展开的图形的高是随着$\theta$线性变化的；盘山公路展开的图形对应的底边是$l*\Delta \theta$的和式，由于$l = { {W\theta}\over{4{\pi}Q} }$，所以底边对应增量$d_{v} = { {W\theta}\over{4{\pi}Q} } d_{\theta}$，求积分得$V = { {W\theta^{2} }\over{8{\pi}Q} } $，所以展开图形的底边不是随着$\theta$线性变化的，所以螺旋线展开不是一个直角三角形，其中斜边向下弯曲，因为斜率随着$\theta$的增大而减小）</p><p>但我们为了简化计算，认为螺旋线的展开是一个三角形，并且从$\theta$的范围得出底边的总长度是${\pi wQ}\over{2}$。</p><p>为了计算彩灯间隔T对应的$\Delta h$，有了$\Delta h$才能计算每一个彩灯相对于上一个$h$位置的$w$值。</p><p>假设彩灯在俯视图上的间隔是T，假设间隔T对应的角度变化量为$\Delta \theta$，所以T和$\Delta \theta$的对应关系是</p><script type="math/tex; mode=display">T = l\Delta \theta = { {W\theta}\over{4{\pi}Q} }  \Delta \theta</script><p>代入$\theta = { {2{\pi}Qh}\over{H} }$可得</p><script type="math/tex; mode=display">\Delta \theta = { 4{ {\pi}QT}\over{W\theta} } = { 2HT \over { Wh } }</script><p>由$\theta = { {2{\pi}Qh}\over{H} }$可得</p><script type="math/tex; mode=display">\Delta \theta = { {2{\pi}Q\Delta h}\over{H} }</script><p>联立方程(5)(6)消去$\Delta \theta$可得</p><script type="math/tex; mode=display">\Delta h = { TH^2 \over {\pi WQh} }</script><p>所以每一次彩灯的变化量与当前的h值有关（假设当前为$h$，则下一次位置是$h + \Delta h$，以此自以为是的将方程7进行修正，将$h$值取为当前$h$和下一次位置$h + \Delta h$的平均值$h + { \Delta h \over 2 }$，从而得到如下方程）</p><script type="math/tex; mode=display">\Delta h = { TH^2 \over {\pi WQ(h + {\Delta h\over2}) } }</script><p>从而得到一元二次方程</p><script type="math/tex; mode=display">{\pi WQ \over 2}·\Delta h^2 + {\pi WQh}·\Delta h - TH^2 = 0</script><p>由$x_1,x_2 = {-b \pm \sqrt{b^2-4ac} \over 2 }$得</p><script type="math/tex; mode=display">\Delta h_1 = -h + { \sqrt{ h^2 + {2TH^2\over{ \pi WQ } } }  }\\ \Delta h_2 = -h - { \sqrt{ h^2 + {2TH^2\over{ \pi WQ } } }  } （负值舍去）</script><p>JS语言代码示例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> h_start = <span class="number">0.001</span>;</span><br><span class="line"><span class="keyword">var</span> h_max = <span class="number">300</span>;</span><br><span class="line"><span class="keyword">for</span>(double h = h_start; h &lt; h_max;)&#123;</span><br><span class="line">    <span class="comment">// 计算灯位置的x坐标和y坐标</span></span><br><span class="line">    <span class="keyword">var</span> light_x = h;</span><br><span class="line">    <span class="keyword">var</span> light_y = (W*h)/(<span class="number">2</span>*H) * <span class="built_in">Math</span>.sin(<span class="number">2</span>*<span class="built_in">Math</span>.PI*Q*h/H)</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 更新h的值</span></span><br><span class="line">    <span class="keyword">var</span> equation_A = <span class="built_in">Math</span>.PI * W * Q / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">var</span> equation_B =  <span class="built_in">Math</span>.PI * W * Q * h;</span><br><span class="line">    <span class="keyword">var</span> equation_C = -(T * H * H);</span><br><span class="line">    h = <span class="built_in">Math</span>.sqrt(equation_B * equation_B - <span class="number">4</span> * equation_A * equation_C) / (<span class="number">2</span> * equation_A);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>渲染出来的图：</p><p><img src="https://delta1037.oss-cn-beijing.aliyuncs.com/hexo-blog/christmas_tree_equation/tree_light.png" alt=""></p><p>备注：</p><p>如果想固定彩灯的总数$N$，需要求得彩灯间隔T的值，俯视图上的线的总长度是${\pi wQ}\over{2}$，所以该长度除以$N$得$T = { {\pi wQ}\over{2N} } $ 。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;圣诞树彩灯曲线方程&quot;&gt;&lt;a href=&quot;#圣诞树彩灯曲线方程&quot; class=&quot;headerlink&quot; title=&quot;圣诞树彩灯曲线方程&quot;&gt;&lt;/a&gt;圣诞树彩灯曲线方程&lt;/h1&gt;&lt;p&gt;马上就要圣诞节了，圣诞树上会绕一圈彩灯，以表对圣诞节的敬意，淦！&lt;/p&gt;
&lt;p&gt;对于</summary>
      
    
    
    
    <category term="Math" scheme="https://www.delta1037.cn/categories/Math/"/>
    
    
    <category term="Math" scheme="https://www.delta1037.cn/tags/Math/"/>
    
  </entry>
  
  <entry>
    <title>常用环境配置</title>
    <link href="https://www.delta1037.cn/2020/Mirror/%E5%B8%B8%E7%94%A8%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    <id>https://www.delta1037.cn/2020/Mirror/%E5%B8%B8%E7%94%A8%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</id>
    <published>2020-12-11T17:29:31.000Z</published>
    <updated>2020-12-11T17:31:07.612Z</updated>
    
    <content type="html"><![CDATA[<h1 id="常用环境配置"><a href="#常用环境配置" class="headerlink" title="常用环境配置"></a>常用环境配置</h1><h2 id="一、node"><a href="#一、node" class="headerlink" title="一、node"></a>一、node</h2><ul><li><p>安装包下载：</p><p><a href="https://npm.taobao.org/mirrors/node/v14.15.1/">nodejs淘宝源</a></p></li><li><p>更新方法</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下载二进制包</span></span><br><span class="line">wget https://nodejs.org/dist/v12.19.1/node-v12.19.1-linux-x64.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解压包</span></span><br><span class="line">tar -xzvf node-v12.19.1-linux-x64.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 移动到系统目录</span></span><br><span class="line">mv node-v12.19.1-linux-x64 /usr/<span class="built_in">local</span>/lib/nodejs</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加环境变量</span></span><br><span class="line"><span class="built_in">export</span> PATH=/usr/<span class="built_in">local</span>/lib/nodejs/bin:<span class="variable">$PATH</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看是否更新成功</span></span><br><span class="line">node -v</span><br></pre></td></tr></table></figure><h2 id="二、npm"><a href="#二、npm" class="headerlink" title="二、npm"></a>二、npm</h2><p>npm安装包太慢，配置淘宝npm镜像</p><h3 id="2-1-临时配置"><a href="#2-1-临时配置" class="headerlink" title="2.1 临时配置"></a>2.1 临时配置</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm --registry https://registry.npm.taobao.org install express</span><br></pre></td></tr></table></figure><h3 id="2-2-永久配置"><a href="#2-2-永久配置" class="headerlink" title="2.2 永久配置"></a>2.2 永久配置</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 配置</span></span><br><span class="line">npm config <span class="built_in">set</span> registry https://registry.npm.taobao.org</span><br><span class="line"></span><br><span class="line"><span class="comment"># 验证</span></span><br><span class="line">npm config get registry</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">npm info express</span><br></pre></td></tr></table></figure><h3 id="2-3-通过cnpm使用"><a href="#2-3-通过cnpm使用" class="headerlink" title="2.3 通过cnpm使用"></a>2.3 通过cnpm使用</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">npm install -g cnpm --registry=https://registry.npm.taobao.org</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用</span></span><br><span class="line">cnpm install express</span><br></pre></td></tr></table></figure><h3 id="2-4-恢复原源"><a href="#2-4-恢复原源" class="headerlink" title="2.4 恢复原源"></a>2.4 恢复原源</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config <span class="built_in">set</span> registry https://registry.npmjs.org</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>【0】<a href="https://blog.csdn.net/quuqu/article/details/64121812">npm太慢， 淘宝npm镜像使用方法</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;常用环境配置&quot;&gt;&lt;a href=&quot;#常用环境配置&quot; class=&quot;headerlink&quot; title=&quot;常用环境配置&quot;&gt;&lt;/a&gt;常用环境配置&lt;/h1&gt;&lt;h2 id=&quot;一、node&quot;&gt;&lt;a href=&quot;#一、node&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="Mirror" scheme="https://www.delta1037.cn/categories/Mirror/"/>
    
    
    <category term="Mirror" scheme="https://www.delta1037.cn/tags/Mirror/"/>
    
  </entry>
  
  <entry>
    <title>布隆过滤器</title>
    <link href="https://www.delta1037.cn/2020/Math/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/"/>
    <id>https://www.delta1037.cn/2020/Math/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/</id>
    <published>2020-12-11T14:16:31.000Z</published>
    <updated>2020-12-21T15:12:35.998Z</updated>
    
    <content type="html"><![CDATA[<h1 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h1><h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><p>布隆过滤器是由伯顿·布隆于1970年提出的。布隆过滤器实际上是一个很长的二进制向量和一系列随机映射函数。布隆过滤器用于判断一个元素是否在一个集合中，它只有插入元素和查询元素是否存在两种操作。</p><p>哈希表也有与布隆过滤器同样的功能，但是布隆过滤器只需要哈希表的$1/8$到$1/4$的大小就可以解决相同的问题，但是布隆过滤器可能存在误识别的问题，后续给出误识别的概率计算。</p><h2 id="二、应用"><a href="#二、应用" class="headerlink" title="二、应用"></a>二、应用</h2><ul><li>建立初始环境：假设存储一亿个电子邮件地址，建立16亿个比特位，即一个两亿字节的向量，将16亿个比特位清零。</li><li>插入元素：对于要插入的每一个电子邮件地址，使用8个不同的随机数生成器（$F_1$，$F_2$，…，$F_8$），生成8个信息指纹（$f_1$，$f_2$，…，$f_8$），再使用一个随机数产成器G将8个信息指纹映射到1-16亿中的八个自然数（$g_1$，$g_2$，…，$g_8$）。在16亿个比特位中将这8个自然数位置的比特位置为1。</li><li>查询元素：对于一个需要查询的邮件地址，使用相同的八个随机数生成器和随机数产生器得到八个自然数（$t_1$，$t_2$，…，$t_8$），如果在16亿个比特位向量中对应的比特值为1，则判断为元素存在。</li></ul><p><img src="https://delta1037.oss-cn-beijing.aliyuncs.com/hexo-blog/bloom/bloom.png" alt="布隆过滤器映射方法"></p><p>问题：有极小的概率误判元素存在，因为有可能某个邮件地址在布隆过滤器中的对应的8个位置恰巧被设置为1。</p><h2 id="三、误识别概率计算"><a href="#三、误识别概率计算" class="headerlink" title="三、误识别概率计算"></a>三、误识别概率计算</h2><p>假设布隆过滤器有m个比特位，已经插入了n个元素，每个元素使用k个散列函数。</p><p>在布隆过滤器中插入一个新的元素时，元素的第一个散列函数会将布隆过滤器中的某一位设置为1，因此某一位被设置为1的概率是${ {1}\over{m} }$（因为一共有m个比特位，每一个比特位被设置为1的概率是相同的，都是${ {1}\over{m} }$），某一位没有被设置为1的概率是$1-{ {1}\over{m} }$。</p><p>对于布隆过滤器中的一个特定的位置，插入一个元素，k个散列函数都没有将它置为1的概率是$(1-{ {1}\over{m} })^k$。插入第二个元素，该位置仍然没有被设置为1的概率是$(1-{ {1}\over{m} })^{2k}$。如果插入了n个元素，该位置仍然没有被置为1的概率是$(1-{ {1}\over{m} })^{nk}$。反过来，该位置被置为1的概率是$1-(1-{ {1}\over{m} })^{nk}$。</p><p>假定n个元素都已经插入到了布隆过滤器中，新来一个不在集合（即n个元素组成的集合）中的元素，新元素的第一个散列函数正好命中一个被置为1的位置的概率是上述计算的概率是$1-(1-{ {1}\over{m} })^{nk}$，如果新元素被误识别为在集合中，那么k个散列函数都命中了被置为1的位置，其概率为</p><script type="math/tex; mode=display">(1-(1-{ {1}\over{m} })^{nk})^k \approx (1-e^{ {-nk}\over{m} })^k</script><p>化简后为</p><script type="math/tex; mode=display">p = (1-e^{ {-ln({ {m}\over{n} }ln2)n}\over{m} })^{ln({ {m}\over{n} }ln2)}</script><p>如果n值比较大，可以近似为</p><script type="math/tex; mode=display">(1-e^{ {-k(n+0.5)}\over{m-1} })^k \approx (1-e^{ {-kn}\over{m} })^k</script><p>误识别率参考表，来源于<a href="http://pages.cs.wisc.edu/~cao/papers/summary-cache/node8.html">Bloom Filters - the math</a></p><div class="table-container"><table><thead><tr><th><em>m</em>/<em>n</em></th><th><em>k</em></th><th><em>k</em>=1</th><th><em>k</em>=2</th><th><em>k</em>=3</th><th><em>k</em>=4</th><th><em>k</em>=5</th><th><em>k</em>=6</th><th><em>k</em>=7</th><th><em>k</em>=8</th></tr></thead><tbody><tr><td>2</td><td>1.39</td><td>0.393</td><td>0.400</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>3</td><td>2.08</td><td>0.283</td><td>0.237</td><td>0.253</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>4</td><td>2.77</td><td>0.221</td><td>0.155</td><td>0.147</td><td>0.160</td><td></td><td></td><td></td><td></td></tr><tr><td>5</td><td>3.46</td><td>0.181</td><td>0.109</td><td>0.092</td><td>0.092</td><td>0.101</td><td></td><td></td><td></td></tr><tr><td>6</td><td>4.16</td><td>0.154</td><td>0.0804</td><td>0.0609</td><td>0.0561</td><td>0.0578</td><td>0.0638</td><td></td><td></td></tr><tr><td>7</td><td>4.85</td><td>0.133</td><td>0.0618</td><td>0.0423</td><td>0.0359</td><td>0.0347</td><td>0.0364</td><td></td><td></td></tr><tr><td>8</td><td>5.55</td><td>0.118</td><td>0.0489</td><td>0.0306</td><td>0.024</td><td>0.0217</td><td>0.0216</td><td>0.0229</td><td></td></tr><tr><td>9</td><td>6.24</td><td>0.105</td><td>0.0397</td><td>0.0228</td><td>0.0166</td><td>0.0141</td><td>0.0133</td><td>0.0135</td><td>0.0145</td></tr><tr><td>10</td><td>6.93</td><td>0.0952</td><td>0.0329</td><td>0.0174</td><td>0.0118</td><td>0.00943</td><td>0.00844</td><td>0.00819</td><td>0.00846</td></tr><tr><td>11</td><td>7.62</td><td>0.0869</td><td>0.0276</td><td>0.0136</td><td>0.00864</td><td>0.0065</td><td>0.00552</td><td>0.00513</td><td>0.00509</td></tr><tr><td>12</td><td>8.32</td><td>0.08</td><td>0.0236</td><td>0.0108</td><td>0.00646</td><td>0.00459</td><td>0.00371</td><td>0.00329</td><td>0.00314</td></tr><tr><td>13</td><td>9.01</td><td>0.074</td><td>0.0203</td><td>0.00875</td><td>0.00492</td><td>0.00332</td><td>0.00255</td><td>0.00217</td><td>0.00199</td></tr><tr><td>14</td><td>9.7</td><td>0.0689</td><td>0.0177</td><td>0.00718</td><td>0.00381</td><td>0.00244</td><td>0.00179</td><td>0.00146</td><td>0.00129</td></tr><tr><td>15</td><td>10.4</td><td>0.0645</td><td>0.0156</td><td>0.00596</td><td>0.003</td><td>0.00183</td><td>0.00128</td><td>0.001</td><td>0.000852</td></tr><tr><td>16</td><td>11.1</td><td>0.0606</td><td>0.0138</td><td>0.005</td><td>0.00239</td><td>0.00139</td><td>0.000935</td><td>0.000702</td><td>0.000574</td></tr><tr><td>17</td><td>11.8</td><td>0.0571</td><td>0.0123</td><td>0.00423</td><td>0.00193</td><td>0.00107</td><td>0.000692</td><td>0.000499</td><td>0.000394</td></tr><tr><td>18</td><td>12.5</td><td>0.054</td><td>0.0111</td><td>0.00362</td><td>0.00158</td><td>0.000839</td><td>0.000519</td><td>0.00036</td><td>0.000275</td></tr><tr><td>19</td><td>13.2</td><td>0.0513</td><td>0.00998</td><td>0.00312</td><td>0.0013</td><td>0.000663</td><td>0.000394</td><td>0.000264</td><td>0.000194</td></tr><tr><td>20</td><td>13.9</td><td>0.0488</td><td>0.00906</td><td>0.0027</td><td>0.00108</td><td>0.00053</td><td>0.000303</td><td>0.000196</td><td>0.00014</td></tr><tr><td>21</td><td>14.6</td><td>0.0465</td><td>0.00825</td><td>0.00236</td><td>0.000905</td><td>0.000427</td><td>0.000236</td><td>0.000147</td><td>0.000101</td></tr><tr><td>22</td><td>15.2</td><td>0.0444</td><td>0.00755</td><td>0.00207</td><td>0.000764</td><td>0.000347</td><td>0.000185</td><td>0.000112</td><td>7.46e-05</td></tr><tr><td>23</td><td>15.9</td><td>0.0425</td><td>0.00694</td><td>0.00183</td><td>0.000649</td><td>0.000285</td><td>0.000147</td><td>8.56e-05</td><td>5.55e-05</td></tr><tr><td>24</td><td>16.6</td><td>0.0408</td><td>0.00639</td><td>0.00162</td><td>0.000555</td><td>0.000235</td><td>0.000117</td><td>6.63e-05</td><td>4.17e-05</td></tr><tr><td>25</td><td>17.3</td><td>0.0392</td><td>0.00591</td><td>0.00145</td><td>0.000478</td><td>0.000196</td><td>9.44e-05</td><td>5.18e-05</td><td>3.16e-05</td></tr><tr><td>26</td><td>18</td><td>0.0377</td><td>0.00548</td><td>0.00129</td><td>0.000413</td><td>0.000164</td><td>7.66e-05</td><td>4.08e-05</td><td>2.42e-05</td></tr><tr><td>27</td><td>18.7</td><td>0.0364</td><td>0.0051</td><td>0.00116</td><td>0.000359</td><td>0.000138</td><td>6.26e-05</td><td>3.24e-05</td><td>1.87e-05</td></tr><tr><td>28</td><td>19.4</td><td>0.0351</td><td>0.00475</td><td>0.00105</td><td>0.000314</td><td>0.000117</td><td>5.15e-05</td><td>2.59e-05</td><td>1.46e-05</td></tr><tr><td>29</td><td>20.1</td><td>0.0339</td><td>0.00444</td><td>0.000949</td><td>0.000276</td><td>9.96e-05</td><td>4.26e-05</td><td>2.09e-05</td><td>1.14e-05</td></tr><tr><td>30</td><td>20.8</td><td>0.0328</td><td>0.00416</td><td>0.000862</td><td>0.000243</td><td>8.53e-05</td><td>3.55e-05</td><td>1.69e-05</td><td>9.01e-06</td></tr><tr><td>31</td><td>21.5</td><td>0.0317</td><td>0.0039</td><td>0.000785</td><td>0.000215</td><td>7.33e-05</td><td>2.97e-05</td><td>1.38e-05</td><td>7.16e-06</td></tr><tr><td>32</td><td>22.2</td><td>0.0308</td><td>0.00367</td><td>0.000717</td><td>0.000191</td><td>6.33e-05</td><td>2.5e-05</td><td>1.13e-05</td><td>5.73e-06</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th><em>m</em>/<em>n</em></th><th><em>k</em></th><th><em>k</em>=9</th><th><em>k</em>=10</th><th><em>k</em>=11</th><th><em>k</em>=12</th><th><em>k</em>=13</th><th><em>k</em>=14</th><th><em>k</em>=15</th><th><em>k</em>=16</th></tr></thead><tbody><tr><td>11</td><td>7.62</td><td>0.00531</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>12</td><td>8.32</td><td>0.00317</td><td>0.00334</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>13</td><td>9.01</td><td>0.00194</td><td>0.00198</td><td>0.0021</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>14</td><td>9.7</td><td>0.00121</td><td>0.0012</td><td>0.00124</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>15</td><td>10.4</td><td>0.000775</td><td>0.000744</td><td>0.000747</td><td>0.000778</td><td></td><td></td><td></td><td></td></tr><tr><td>16</td><td>11.1</td><td>0.000505</td><td>0.00047</td><td>0.000459</td><td>0.000466</td><td>0.000488</td><td></td><td></td><td></td></tr><tr><td>17</td><td>11.8</td><td>0.000335</td><td>0.000302</td><td>0.000287</td><td>0.000284</td><td>0.000291</td><td></td><td></td><td></td></tr><tr><td>18</td><td>12.5</td><td>0.000226</td><td>0.000198</td><td>0.000183</td><td>0.000176</td><td>0.000176</td><td>0.000182</td><td></td><td></td></tr><tr><td>19</td><td>13.2</td><td>0.000155</td><td>0.000132</td><td>0.000118</td><td>0.000111</td><td>0.000109</td><td>0.00011</td><td>0.000114</td><td></td></tr><tr><td>20</td><td>13.9</td><td>0.000108</td><td>8.89e-05</td><td>7.77e-05</td><td>7.12e-05</td><td>6.79e-05</td><td>6.71e-05</td><td>6.84e-05</td><td></td></tr><tr><td>21</td><td>14.6</td><td>7.59e-05</td><td>6.09e-05</td><td>5.18e-05</td><td>4.63e-05</td><td>4.31e-05</td><td>4.17e-05</td><td>4.16e-05</td><td>4.27e-05</td></tr><tr><td>22</td><td>15.2</td><td>5.42e-05</td><td>4.23e-05</td><td>3.5e-05</td><td>3.05e-05</td><td>2.78e-05</td><td>2.63e-05</td><td>2.57e-05</td><td>2.59e-05</td></tr><tr><td>23</td><td>15.9</td><td>3.92e-05</td><td>2.97e-05</td><td>2.4e-05</td><td>2.04e-05</td><td>1.81e-05</td><td>1.68e-05</td><td>1.61e-05</td><td>1.59e-05</td></tr><tr><td>24</td><td>16.6</td><td>2.86e-05</td><td>2.11e-05</td><td>1.66e-05</td><td>1.38e-05</td><td>1.2e-05</td><td>1.08e-05</td><td>1.02e-05</td><td>9.87e-06</td></tr><tr><td>25</td><td>17.3</td><td>2.11e-05</td><td>1.52e-05</td><td>1.16e-05</td><td>9.42e-06</td><td>8.01e-06</td><td>7.1e-06</td><td>6.54e-06</td><td>6.22e-06</td></tr><tr><td>26</td><td>18</td><td>1.57e-05</td><td>1.1e-05</td><td>8.23e-06</td><td>6.52e-06</td><td>5.42e-06</td><td>4.7e-06</td><td>4.24e-06</td><td>3.96e-06</td></tr><tr><td>27</td><td>18.7</td><td>1.18e-05</td><td>8.07e-06</td><td>5.89e-06</td><td>4.56e-06</td><td>3.7e-06</td><td>3.15e-06</td><td>2.79e-06</td><td>2.55e-06</td></tr><tr><td>28</td><td>19.4</td><td>8.96e-06</td><td>5.97e-06</td><td>4.25e-06</td><td>3.22e-06</td><td>2.56e-06</td><td>2.13e-06</td><td>1.85e-06</td><td>1.66e-06</td></tr><tr><td>29</td><td>20.1</td><td>6.85e-06</td><td>4.45e-06</td><td>3.1e-06</td><td>2.29e-06</td><td>1.79e-06</td><td>1.46e-06</td><td>1.24e-06</td><td>1.09e-06</td></tr><tr><td>30</td><td>20.8</td><td>5.28e-06</td><td>3.35e-06</td><td>2.28e-06</td><td>1.65e-06</td><td>1.26e-06</td><td>1.01e-06</td><td>8.39e-06</td><td>7.26e-06</td></tr><tr><td>31</td><td>21.5</td><td>4.1e-06</td><td>2.54e-06</td><td>1.69e-06</td><td>1.2e-06</td><td>8.93e-07</td><td>7e-07</td><td>5.73e-07</td><td>4.87e-07</td></tr><tr><td>32</td><td>22.2</td><td>3.2e-06</td><td>1.94e-06</td><td>1.26e-06</td><td>8.74e-07</td><td>6.4e-07</td><td>4.92e-07</td><td>3.95e-07</td><td>3.3e-07</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th><em>m</em>/<em>n</em></th><th><em>k</em></th><th><em>k</em>=17</th><th><em>k</em>=18</th><th><em>k</em>=19</th><th><em>k</em>=20</th><th><em>k</em>=21</th><th><em>k</em>=22</th><th><em>k</em>=23</th><th><em>k</em>=24</th></tr></thead><tbody><tr><td>22</td><td>15.2</td><td>2.67e-05</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>23</td><td>15.9</td><td>1.61e-05</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>24</td><td>16.6</td><td>9.84e-06</td><td>1e-05</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>25</td><td>17.3</td><td>6.08e-06</td><td>6.11e-06</td><td>6.27e-06</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>26</td><td>18</td><td>3.81e-06</td><td>3.76e-06</td><td>3.8e-06</td><td>3.92e-06</td><td></td><td></td><td></td><td></td></tr><tr><td>27</td><td>18.7</td><td>2.41e-06</td><td>2.34e-06</td><td>2.33e-06</td><td>2.37e-06</td><td></td><td></td><td></td><td></td></tr><tr><td>28</td><td>19.4</td><td>1.54e-06</td><td>1.47e-06</td><td>1.44e-06</td><td>1.44e-06</td><td>1.48e-06</td><td></td><td></td><td></td></tr><tr><td>29</td><td>20.1</td><td>9.96e-07</td><td>9.35e-07</td><td>9.01e-07</td><td>8.89e-07</td><td>8.96e-07</td><td>9.21e-07</td><td></td><td></td></tr><tr><td>30</td><td>20.8</td><td>6.5e-07</td><td>6e-07</td><td>5.69e-07</td><td>5.54e-07</td><td>5.5e-07</td><td>5.58e-07</td><td></td><td></td></tr><tr><td>31</td><td>21.5</td><td>4.29e-07</td><td>3.89e-07</td><td>3.63e-07</td><td>3.48e-07</td><td>3.41e-07</td><td>3.41e-07</td><td>3.48e-07</td><td></td></tr><tr><td>32</td><td>22.2</td><td>2.85e-07</td><td>2.55e-07</td><td>2.34e-07</td><td>2.21e-07</td><td>2.13e-07</td><td>2.1e-07</td><td>2.12e-07</td><td>2.17e-07</td></tr></tbody></table></div><h2 id="四、参考"><a href="#四、参考" class="headerlink" title="四、参考"></a>四、参考</h2><p>【0】数学之美 （第三版）</p><p>【1】<a href="https://www.jianshu.com/p/25f0139637b7">markdown中公式编辑教程</a></p><p>【2】<a href="http://pages.cs.wisc.edu/~cao/papers/summary-cache/node8.html">Bloom Filters - the math</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;布隆过滤器&quot;&gt;&lt;a href=&quot;#布隆过滤器&quot; class=&quot;headerlink&quot; title=&quot;布隆过滤器&quot;&gt;&lt;/a&gt;布隆过滤器&lt;/h1&gt;&lt;h2 id=&quot;一、简介&quot;&gt;&lt;a href=&quot;#一、简介&quot; class=&quot;headerlink&quot; title=&quot;一、简介&quot;</summary>
      
    
    
    
    <category term="Math" scheme="https://www.delta1037.cn/categories/Math/"/>
    
    
    <category term="Math" scheme="https://www.delta1037.cn/tags/Math/"/>
    
  </entry>
  
  <entry>
    <title>最大熵模型</title>
    <link href="https://www.delta1037.cn/2020/Math/%E6%9C%80%E5%A4%A7%E7%86%B5%E6%A8%A1%E5%9E%8B/"/>
    <id>https://www.delta1037.cn/2020/Math/%E6%9C%80%E5%A4%A7%E7%86%B5%E6%A8%A1%E5%9E%8B/</id>
    <published>2020-12-11T14:16:31.000Z</published>
    <updated>2020-12-11T17:31:07.257Z</updated>
    
    <content type="html"><![CDATA[<h1 id="最大熵模型"><a href="#最大熵模型" class="headerlink" title="最大熵模型"></a>最大熵模型</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;最大熵模型&quot;&gt;&lt;a href=&quot;#最大熵模型&quot; class=&quot;headerlink&quot; title=&quot;最大熵模型&quot;&gt;&lt;/a&gt;最大熵模型&lt;/h1&gt;</summary>
      
    
    
    
    <category term="Math" scheme="https://www.delta1037.cn/categories/Math/"/>
    
    
    <category term="Math" scheme="https://www.delta1037.cn/tags/Math/"/>
    
  </entry>
  
  <entry>
    <title>经济学十大原理</title>
    <link href="https://www.delta1037.cn/2020/Economics/%E7%BB%8F%E6%B5%8E%E5%AD%A6%E5%8D%81%E5%A4%A7%E5%8E%9F%E7%90%86/"/>
    <id>https://www.delta1037.cn/2020/Economics/%E7%BB%8F%E6%B5%8E%E5%AD%A6%E5%8D%81%E5%A4%A7%E5%8E%9F%E7%90%86/</id>
    <published>2020-12-09T14:32:31.000Z</published>
    <updated>2020-12-11T17:31:04.603Z</updated>
    
    <content type="html"><![CDATA[<h1 id="经济学十大原理"><a href="#经济学十大原理" class="headerlink" title="经济学十大原理"></a>经济学十大原理</h1><h2 id="一、十大原理分类"><a href="#一、十大原理分类" class="headerlink" title="一、十大原理分类"></a>一、十大原理分类</h2><h3 id="1-1-人们如何做出决策"><a href="#1-1-人们如何做出决策" class="headerlink" title="1.1 人们如何做出决策"></a>1.1 人们如何做出决策</h3><h4 id="原理一：人们面临权衡取舍"><a href="#原理一：人们面临权衡取舍" class="headerlink" title="原理一：人们面临权衡取舍"></a>原理一：人们面临权衡取舍</h4><p>为了得到一件喜爱的东西，我们通常不得不放弃另一件喜爱的东西。做出决策就是要求我们在一个目标与另一个目标之间进行权衡取舍。</p><p>人们只有了解面临的选择，才有可能做出良好的决策。</p><h4 id="原理二：某种东西的成本是为了得到它所放弃的东西"><a href="#原理二：某种东西的成本是为了得到它所放弃的东西" class="headerlink" title="原理二：某种东西的成本是为了得到它所放弃的东西"></a>原理二：某种东西的成本是为了得到它所放弃的东西</h4><p>一种东西的<strong>机会成本</strong>是为了得到这种东西所放弃的东西</p><h4 id="原理三：理性人考虑边际量"><a href="#原理三：理性人考虑边际量" class="headerlink" title="原理三：理性人考虑边际量"></a>原理三：理性人考虑边际量</h4><p>理性人通常比较边际收益与边际成本来做决策。当且仅当一种行为的边际收益大于边际成本时，一个理性的决策者才会采取这种行为。</p><h4 id="原理四：人们会对激励做出反应"><a href="#原理四：人们会对激励做出反应" class="headerlink" title="原理四：人们会对激励做出反应"></a>原理四：人们会对激励做出反应</h4><p><strong>激励</strong>是引起一个人做出某种行为的东西（例如惩罚或奖励的预期）。由于理性人会通过比较成本与收益做出决策，所以他们会对激励做出反应</p><h3 id="1-2-人们如何互相影响"><a href="#1-2-人们如何互相影响" class="headerlink" title="1.2 人们如何互相影响"></a>1.2 人们如何互相影响</h3><h4 id="原理五：贸易可以使每个人的情况都变得更好"><a href="#原理五：贸易可以使每个人的情况都变得更好" class="headerlink" title="原理五：贸易可以使每个人的情况都变得更好"></a>原理五：贸易可以使每个人的情况都变得更好</h4><p>贸易可以使得每个人做自己擅长的活动。通过与其他人贸易，人们可以以较低的成本获得各种各样的物品与服务。</p><h4 id="原理六：市场通常是组织经济活动的一种-好方法"><a href="#原理六：市场通常是组织经济活动的一种-好方法" class="headerlink" title="原理六：市场通常是组织经济活动的一种 好方法"></a>原理六：市场通常是组织经济活动的一种 好方法</h4><p><strong>市场经济</strong>：许多家庭和企业在物品与服务市场上互相交易时，通过他们的分散决策配置资源的经济。</p><p>家庭和企业在市场上互相交易，他们仿佛被一只“看不见的手”所指引，并导致了合意的市场结果。</p><h4 id="原理七：政府优势可以改善市场的结果"><a href="#原理七：政府优势可以改善市场的结果" class="headerlink" title="原理七：政府优势可以改善市场的结果"></a>原理七：政府优势可以改善市场的结果</h4><p>看不见的手是强有力的，但并不是无所不能的。政府干预经济并改变人们自己选择的资源配置的原因有两类：促进效率或促进平等。也就是说，大多数政策目标是要么把经济蛋糕做大，要么改变这个蛋糕的分割方式。</p><h3 id="1-3-整体经济如何运行"><a href="#1-3-整体经济如何运行" class="headerlink" title="1.3 整体经济如何运行"></a>1.3 整体经济如何运行</h3><h4 id="原理八：一国的生活水平取决于它生产物品与服务能力"><a href="#原理八：一国的生活水平取决于它生产物品与服务能力" class="headerlink" title="原理八：一国的生活水平取决于它生产物品与服务能力"></a>原理八：一国的生活水平取决于它生产物品与服务能力</h4><p>生活水平的差别可以归结于<strong>生产率</strong>的差别，即每一单位劳动投入所生产的物品与服务数量的差别。</p><h4 id="原理九：当政府发行了过多的货币时，物价上升"><a href="#原理九：当政府发行了过多的货币时，物价上升" class="headerlink" title="原理九：当政府发行了过多的货币时，物价上升"></a>原理九：当政府发行了过多的货币时，物价上升</h4><p>通货膨胀是物价总水平的上升。大多数严重或者持续的通货膨胀情况下，罪魁祸首是货币的增长。</p><h4 id="原理十：社会面临通货膨胀与失业之间的短期权衡取舍"><a href="#原理十：社会面临通货膨胀与失业之间的短期权衡取舍" class="headerlink" title="原理十：社会面临通货膨胀与失业之间的短期权衡取舍"></a>原理十：社会面临通货膨胀与失业之间的短期权衡取舍</h4><p>长期中，物价水平的上升主要是货币量增加的结果</p><p>货币注入的短期效应：</p><ul><li>经济中货币的增加刺激了社会的整体支出水平，从而增加了对物品和服务的需求</li><li>需求的增加随着时间的推移，会引起企业提高物价，但同时，它也鼓励企业雇佣更多的工人，并生产更多的物品与服务</li><li>雇佣更多的工人意味着更少的失业</li></ul><h2 id="二、参考文献"><a href="#二、参考文献" class="headerlink" title="二、参考文献"></a>二、参考文献</h2><p>【0】经济学原理 微观经济学分册</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;经济学十大原理&quot;&gt;&lt;a href=&quot;#经济学十大原理&quot; class=&quot;headerlink&quot; title=&quot;经济学十大原理&quot;&gt;&lt;/a&gt;经济学十大原理&lt;/h1&gt;&lt;h2 id=&quot;一、十大原理分类&quot;&gt;&lt;a href=&quot;#一、十大原理分类&quot; class=&quot;headerli</summary>
      
    
    
    
    <category term="经济学" scheme="https://www.delta1037.cn/categories/%E7%BB%8F%E6%B5%8E%E5%AD%A6/"/>
    
    
    <category term="经济学" scheme="https://www.delta1037.cn/tags/%E7%BB%8F%E6%B5%8E%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>fcntl</title>
    <link href="https://www.delta1037.cn/2020/Linux/Linux_fcntl/"/>
    <id>https://www.delta1037.cn/2020/Linux/Linux_fcntl/</id>
    <published>2020-12-04T14:08:31.000Z</published>
    <updated>2020-12-11T17:31:07.109Z</updated>
    
    <content type="html"><![CDATA[<h1 id="fcntl"><a href="#fcntl" class="headerlink" title="fcntl"></a>fcntl</h1><p>fcntl针对描述符提供控制，可以用来改变已打开文件的性质</p><h2 id="一、函数定义"><a href="#一、函数定义" class="headerlink" title="一、函数定义"></a>一、函数定义</h2><p>函数接口定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fcntl</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> cmd)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 针对cmd的值，可以使用第三个参数arg/lock</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fcntl</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> cmd, <span class="keyword">long</span> arg)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fcntl</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> cmd, struct flock *lock)</span></span>;</span><br></pre></td></tr></table></figure><p>函数参数结构定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">flcok</span> &#123;</span></span><br><span class="line">　　 <span class="keyword">short</span> <span class="keyword">int</span> l_type; <span class="comment">/* 锁类型：F_RDLCK, F_WRLCK, F_UNLCK */</span></span><br><span class="line">　　 <span class="keyword">short</span> <span class="keyword">int</span> l_whence;<span class="comment">/* 锁定开始位置：SEEK_SET, SEEK_CUR, SEEK_END */</span></span><br><span class="line">　　 <span class="keyword">off_t</span> l_start; <span class="comment">/* 锁定开始计算位置：relative starting offset in bytes */</span></span><br><span class="line">　　 <span class="keyword">off_t</span> l_len; <span class="comment">/* 锁定长度：#bytes; 0 means EOF */</span></span><br><span class="line">　　 <span class="keyword">pid_t</span> l_pid; <span class="comment">/* PID returned by F_GETLK */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 注：开始位置是由l_whence和l_start共同指定的</span></span><br><span class="line"><span class="comment">// l_whence指定了l_start开始计算的位置</span></span><br></pre></td></tr></table></figure><p>函数参数解释：</p><ul><li>fd是要改变的描述符（已打开的文件等）</li><li><p>cmd：操作指定，包含如下几种</p><ul><li><code>F_DUPFD</code>：复制一个现有的描述符</li><li><code>F_GETFD</code>/<code>F_SETFD</code>：获得／设置文件描述符标记</li><li><code>F_GETFL</code>/<code>F_SETFL</code>：获得／设置文件状态标记</li><li><code>F_GETOWN</code>/<code>F_SETOWN</code>：获得／设置异步I/O所有权</li><li><code>F_GETLK</code>、<code>F_SETLK/F_SETLKW</code>：获得／设置记录锁</li></ul></li><li><p>arg/lock：针对cmd的值，需要的第三个参数</p></li></ul><h2 id="二、应用场景"><a href="#二、应用场景" class="headerlink" title="二、应用场景"></a>二、应用场景</h2><h3 id="2-1-记录上锁"><a href="#2-1-记录上锁" class="headerlink" title="2.1 记录上锁"></a>2.1 记录上锁</h3><p>记录上锁使用如下接口：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fcntl</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> cmd, ... <span class="comment">/* struct flock *lock */</span>)</span></span>;</span><br><span class="line"><span class="comment">/* 成功返回值取决于cmd，失败返回-1 */</span></span><br></pre></td></tr></table></figure><p>记录上锁使用cmd的类型：<code>F_GETLK</code>、<code>F_SETLK/F_SETLKW</code></p><ul><li>F_GETLK：</li><li>F_SETLK：</li><li>F_SETLKW：</li></ul><h2 id="三、参考文献"><a href="#三、参考文献" class="headerlink" title="三、参考文献"></a>三、参考文献</h2><p>【0】Unix网络编程</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;fcntl&quot;&gt;&lt;a href=&quot;#fcntl&quot; class=&quot;headerlink&quot; title=&quot;fcntl&quot;&gt;&lt;/a&gt;fcntl&lt;/h1&gt;&lt;p&gt;fcntl针对描述符提供控制，可以用来改变已打开文件的性质&lt;/p&gt;
&lt;h2 id=&quot;一、函数定义&quot;&gt;&lt;a href=</summary>
      
    
    
    
    <category term="Linux" scheme="https://www.delta1037.cn/categories/Linux/"/>
    
    
    <category term="Linux" scheme="https://www.delta1037.cn/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>ioctl</title>
    <link href="https://www.delta1037.cn/2020/Linux/Linux_ioctl/"/>
    <id>https://www.delta1037.cn/2020/Linux/Linux_ioctl/</id>
    <published>2020-12-04T14:08:31.000Z</published>
    <updated>2020-12-11T17:31:06.947Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ioctl"><a href="#ioctl" class="headerlink" title="ioctl"></a>ioctl</h1><p>ioctl()系统调用为<strong>执行文件</strong>和<strong>设备操作</strong>提供了一种多用途机制</p><h2 id="一、接口定义"><a href="#一、接口定义" class="headerlink" title="一、接口定义"></a>一、接口定义</h2><p>ioctl接口定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ioctl</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> request, ... <span class="comment">/* argp */</span>)</span></span></span><br></pre></td></tr></table></figure><p>接口参数说明：</p><ul><li>fd：某个设备或者文件已经打开的文件描述符</li><li><p>request：将在fd上执行的控制操作（<strong>具体设备的头文件</strong>定义了可以传递给request参数的常量）</p></li><li><p>argp：argp的值的类型是由request的参数值确定的，类型如下：</p><ul><li>不需要该参数（哈哈哈没想到吧）</li><li>指向整数或者结构的指针</li></ul></li></ul><h2 id="二、应用场景"><a href="#二、应用场景" class="headerlink" title="二、应用场景"></a>二、应用场景</h2><h2 id="三、参考文献"><a href="#三、参考文献" class="headerlink" title="三、参考文献"></a>三、参考文献</h2><p>【0】Linux/UNIX系统编程手册</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;ioctl&quot;&gt;&lt;a href=&quot;#ioctl&quot; class=&quot;headerlink&quot; title=&quot;ioctl&quot;&gt;&lt;/a&gt;ioctl&lt;/h1&gt;&lt;p&gt;ioctl()系统调用为&lt;strong&gt;执行文件&lt;/strong&gt;和&lt;strong&gt;设备操作&lt;/strong&gt;提供了</summary>
      
    
    
    
    <category term="Linux" scheme="https://www.delta1037.cn/categories/Linux/"/>
    
    
    <category term="Linux" scheme="https://www.delta1037.cn/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux终端动态刷新</title>
    <link href="https://www.delta1037.cn/2020/Linux/Linux%E7%BB%88%E7%AB%AF%E5%8A%A8%E6%80%81%E5%88%B7%E6%96%B0/"/>
    <id>https://www.delta1037.cn/2020/Linux/Linux%E7%BB%88%E7%AB%AF%E5%8A%A8%E6%80%81%E5%88%B7%E6%96%B0/</id>
    <published>2020-12-03T11:16:31.000Z</published>
    <updated>2020-12-11T17:31:06.003Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux终端动态刷新"><a href="#Linux终端动态刷新" class="headerlink" title="Linux终端动态刷新"></a>Linux终端动态刷新</h1><h2 id="一、代码片段"><a href="#一、代码片段" class="headerlink" title="一、代码片段"></a>一、代码片段</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CStat::runtimePrintBuf</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; &amp;buf)</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> last_print_lines = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; last_print_lines; ++i)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\033[1A&quot;</span>); <span class="comment">//先回到上一行</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\033[K&quot;</span>);  <span class="comment">//清除该行</span></span><br><span class="line">    &#125;</span><br><span class="line">    last_print_lines = buf.size();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;it : buf)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, it.c_str());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二、相关知识"><a href="#二、相关知识" class="headerlink" title="二、相关知识"></a>二、相关知识</h2><h3 id="2-1-终端颜色字符"><a href="#2-1-终端颜色字符" class="headerlink" title="2.1 终端颜色字符"></a>2.1 终端颜色字符</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 字体颜色控制</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;\033[30m 黑色字 \033[0m&quot;</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;\033[31m 红色字 \033[0m&quot;</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;\033[32m 绿色字 \033[0m&quot;</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;\033[33m 黄色字 \033[0m&quot;</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;\033[34m 蓝色字 \033[0m&quot;</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;\033[35m 紫色字 \033[0m&quot;</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;\033[36m 天蓝字 \033[0m&quot;</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;\033[37m 白色字 \033[0m&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 字体背景颜色和字体颜色</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;\033[40;37m 黑底白字 \033[0m&quot;</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;\033[41;37m 红底白字 \033[0m&quot;</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;\033[42;37m 绿底白字 \033[0m&quot;</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;\033[43;37m 黄底白字 \033[0m&quot;</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;\033[44;37m 蓝底白字 \033[0m&quot;</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;\033[45;37m 紫底白字 \033[0m&quot;</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;\033[46;37m 天蓝底白字 \033[0m&quot;</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;\033[47;30m 白底黑字 \033[0m&quot;</span></span><br></pre></td></tr></table></figure><h3 id="2-2-终端控制字符"><a href="#2-2-终端控制字符" class="headerlink" title="2.2 终端控制字符"></a>2.2 终端控制字符</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">\33[0m 关闭所有属性 </span><br><span class="line">\33[1m 设置高亮度 </span><br><span class="line">\33[4m 下划线 </span><br><span class="line">\33[5m 闪烁 </span><br><span class="line">\33[7m 反显 </span><br><span class="line">\33[8m 消隐 </span><br><span class="line">\33[30m — \33[37m 设置前景色 </span><br><span class="line">\33[40m — \33[47m 设置背景色 </span><br><span class="line">\33[nA 光标上移n行 </span><br><span class="line">\33[nB 光标下移n行 </span><br><span class="line">\33[nC 光标右移n行 </span><br><span class="line">\33[nD 光标左移n行 </span><br><span class="line">\33[y;xH设置光标位置 </span><br><span class="line">\33[2J 清屏 </span><br><span class="line">\33[K 清除从光标到行尾的内容 </span><br><span class="line">\33[s 保存光标位置 </span><br><span class="line">\33[u 恢复光标位置 </span><br><span class="line">\33[?25l 隐藏光标 </span><br><span class="line">\33[?25h 显示光标</span><br></pre></td></tr></table></figure><p>在C语言中使用终端控制字符，如上代码片段所示</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\033[1A&quot;</span>); <span class="comment">//先回到上一行</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\033[K&quot;</span>);  <span class="comment">//清除该行</span></span><br></pre></td></tr></table></figure><h2 id="三、参考"><a href="#三、参考" class="headerlink" title="三、参考"></a>三、参考</h2><p>【0】<a href="https://www.cnblogs.com/lr-ting/archive/2013/02/28/2936792.html">shell脚本中echo显示内容带颜色</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Linux终端动态刷新&quot;&gt;&lt;a href=&quot;#Linux终端动态刷新&quot; class=&quot;headerlink&quot; title=&quot;Linux终端动态刷新&quot;&gt;&lt;/a&gt;Linux终端动态刷新&lt;/h1&gt;&lt;h2 id=&quot;一、代码片段&quot;&gt;&lt;a href=&quot;#一、代码片段&quot; cla</summary>
      
    
    
    
    <category term="Linux" scheme="https://www.delta1037.cn/categories/Linux/"/>
    
    
    <category term="Linux" scheme="https://www.delta1037.cn/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux C语言实现按键即时识别</title>
    <link href="https://www.delta1037.cn/2020/Linux/Linux%E8%AF%86%E5%88%AB%E6%8C%89%E9%94%AE/"/>
    <id>https://www.delta1037.cn/2020/Linux/Linux%E8%AF%86%E5%88%AB%E6%8C%89%E9%94%AE/</id>
    <published>2020-12-03T11:16:31.000Z</published>
    <updated>2020-12-11T17:31:05.613Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux-C语言实现按键即时识别"><a href="#Linux-C语言实现按键即时识别" class="headerlink" title="Linux C语言实现按键即时识别"></a>Linux C语言实现按键即时识别</h1><p>top中的源代码，慢慢理解。。。<br><strong>不需要按ENTER键，按下即可识别</strong></p><h2 id="一、代码片段"><a href="#一、代码片段" class="headerlink" title="一、代码片段"></a>一、代码片段</h2><p>部分摘自top源代码，部分来源于网络博客</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;termios.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* The original and new terminal attributes */</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">termios</span> <span class="title">Savedtty</span>,</span></span><br><span class="line"><span class="class">                      <span class="title">Rawtty</span>;</span></span><br><span class="line"><span class="comment">// 设置终端相关属性</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">initKeyboard</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tcgetattr(<span class="number">0</span>,&amp;Savedtty);</span><br><span class="line">    Rawtty = Savedtty;</span><br><span class="line">    Rawtty.c_lflag &amp;= ~ICANON;    <span class="comment">// 设置不以规范模式工作，读请求直接从队列读取字符，至少接到MIN字节或者两个字节之间超时值TIME到期时，read才返回</span></span><br><span class="line">    Rawtty.c_lflag &amp;= ~ECHO;      <span class="comment">// 关闭输入字符回显到终端设备</span></span><br><span class="line">    <span class="comment">// Rawtty.c_lflag &amp;= ~ISIG;   // 判断输入字符是否要产生终端信号的特殊字符</span></span><br><span class="line">    Rawtty.c_cc[VMIN] = <span class="number">1</span>;        <span class="comment">// 至少接到MIN字节</span></span><br><span class="line">    Rawtty.c_cc[VTIME] = <span class="number">0</span>;       <span class="comment">// 两个字节之间超时值TIME</span></span><br><span class="line">    tcsetattr(<span class="number">0</span>, TCSANOW, &amp;Rawtty);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 恢复终端属性</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">closeKeyboard</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tcsetattr(<span class="number">0</span>, TCSANOW, &amp;Savedtty);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 读取字符</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">chin</span> <span class="params">(<span class="keyword">int</span> ech, <span class="keyword">char</span> *buf, <span class="keyword">unsigned</span> cnt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> rc;</span><br><span class="line">   fflush(<span class="built_in">stdout</span>);</span><br><span class="line">   <span class="keyword">if</span> (!ech)</span><br><span class="line">      rc = read(STDIN_FILENO, buf, cnt);</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">      tcsetattr(STDIN_FILENO, TCSAFLUSH, &amp;Savedtty);</span><br><span class="line">      rc = read(STDIN_FILENO, buf, cnt);</span><br><span class="line">      tcsetattr(STDIN_FILENO, TCSAFLUSH, &amp;Rawtty);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// may be the beginning of a lengthy escape sequence</span></span><br><span class="line">   tcflush(STDIN_FILENO, TCIFLUSH);</span><br><span class="line">   <span class="keyword">return</span> rc;                   <span class="comment">// note: we do NOT produce a vaid &#x27;string&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断读取字符的有效性</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">char</span> <span class="title">kbhit</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> file_flags;</span><br><span class="line">    <span class="keyword">int</span> rc;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    fd_set fs;</span><br><span class="line">    FD_ZERO(&amp;fs);</span><br><span class="line">    FD_SET(STDIN_FILENO, &amp;fs);</span><br><span class="line">    file_flags = fcntl(STDIN_FILENO, F_GETFL);</span><br><span class="line">    <span class="keyword">if</span>(file_flags==<span class="number">-1</span>) file_flags=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    fcntl(STDIN_FILENO, F_SETFL, O_NONBLOCK|file_flags);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// check 1st, in case tv zeroed (by sig handler) before it got set</span></span><br><span class="line">    rc = chin(<span class="number">0</span>, &amp;c, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (rc &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// EOF is pretty much a &quot;can&#x27;t happen&quot; except for a kernel bug.</span></span><br><span class="line">        <span class="comment">// We should quickly die via SIGHUP, and thus not spin here.</span></span><br><span class="line">        <span class="comment">// if (rc == 0) end_pgm(0); /* EOF from terminal */</span></span><br><span class="line">        fcntl(STDIN_FILENO, F_SETFL, file_flags);</span><br><span class="line">        select(<span class="number">1</span>, &amp;fs, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">        fcntl(STDIN_FILENO, F_SETFL, O_NONBLOCK|file_flags);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (chin(<span class="number">0</span>, &amp;c, <span class="number">1</span>) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        fcntl(STDIN_FILENO, F_SETFL, file_flags);</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fcntl(STDIN_FILENO, F_SETFL, file_flags);</span><br><span class="line">    &#125;</span><br><span class="line">    kbhit();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#<span class="meta"># use</span></span><br><span class="line">initKeyboard();</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">   <span class="keyword">char</span> input = kbhit();</span><br><span class="line">   <span class="keyword">if</span>( input == <span class="string">&#x27;q&#x27;</span>)&#123;</span><br><span class="line">       <span class="comment">// do something</span></span><br><span class="line">       <span class="keyword">break</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">closeKeyboard();</span><br></pre></td></tr></table></figure><h2 id="二、相关知识"><a href="#二、相关知识" class="headerlink" title="二、相关知识"></a>二、相关知识</h2><h3 id="2-1-终端相关"><a href="#2-1-终端相关" class="headerlink" title="2.1 终端相关"></a>2.1 终端相关</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;termios.h&gt;</span></span></span><br><span class="line"><span class="comment">// 终端属性结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">termios</span>&#123;</span></span><br><span class="line">    <span class="keyword">tcflag_t</span> c_iflag;<span class="comment">// 输入标志</span></span><br><span class="line">    <span class="keyword">tcflag_t</span> c_oflag;<span class="comment">// 输出标志</span></span><br><span class="line">    <span class="keyword">tcflag_t</span> c_cflag;<span class="comment">// 控制标志</span></span><br><span class="line">    <span class="keyword">tcflag_t</span> c_lflag;<span class="comment">// 本地标志</span></span><br><span class="line">    <span class="keyword">cc_t</span>     c_cc[NCCS];<span class="comment">// 控制字符</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取终端的属性</span></span><br><span class="line">tcgetattr(<span class="keyword">int</span> fd, struct termios* tty_struct);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置终端属性</span></span><br><span class="line">tcsetattr(<span class="keyword">int</span> fd, <span class="keyword">int</span> opt, <span class="keyword">const</span> struct termios* tty_struct);</span><br></pre></td></tr></table></figure><p>tcsetattr的opt参数指定新设置的终端属性什么时候起作用</p><ul><li>TCSANOW：更改立即发生</li><li>TCSADRAIN：发送了所有的输出后更改才发生</li><li>TCSAFLUSH：发送了所有的输出后更改才发生。更进一步，更改发生时未读入的所有输入都会被丢弃</li></ul><p><strong>标志详细见APUE</strong></p><h3 id="2-2-select函数"><a href="#2-2-select函数" class="headerlink" title="2.2 select函数"></a>2.2 select函数</h3><p>允许进程指示内核等待多个事件中的任何一个发生，并且只有一个或者多个事件或者超时之后才唤醒它</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> maxfdp, fd_set *readset, fd_set *writeset, fd_set *exceptset, <span class="keyword">const</span> struct timeval *timeout)</span></span>;</span><br><span class="line"><span class="comment">// return：返回就绪的描述符的数目，超时返回0，出错返回-1</span></span><br></pre></td></tr></table></figure><ul><li>若timeout为空指针，则永远等下去</li><li>若timeout中秒数和微妙数设置为0，检查描述符之后立即返回</li><li>若timeout中秒数和微妙数设置不为0，在有描述符就绪时返回，但是不超过timeout指定的时间</li></ul><h3 id="2-3-fcntl函数"><a href="#2-3-fcntl函数" class="headerlink" title="2.3 fcntl函数"></a>2.3 fcntl函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fcntl</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> cmd)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fcntl</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> cmd, <span class="keyword">long</span> arg)</span></span>;         </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fcntl</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> cmd, struct flock *lock)</span></span>;</span><br><span class="line"><span class="comment">//fcntl()针对(文件)描述符提供控制.参数fd是被参数cmd操作(如下面的描述)的描述符。针对cmd的值,fcntl能够接受第三个参数（arg）</span></span><br></pre></td></tr></table></figure><p>fcntl函数功能：</p><ul><li>复制一个现有的描述符（cmd=F_DUPFD）</li><li>获得／设置文件描述符标记(cmd=F_GETFD或F_SETFD)</li><li>获得／设置文件状态标记(cmd=F_GETFL或F_SETFL)</li><li>.获得／设置异步I/O所有权(cmd=F_GETOWN或F_SETOWN)</li><li>获得／设置记录锁(cmd=F_GETLK,F_SETLK或F_SETLKW)</li></ul><h2 id="三、参考文献"><a href="#三、参考文献" class="headerlink" title="三、参考文献"></a>三、参考文献</h2><p>【1】<a href="http://archive.ubuntu.com/ubuntu/pool/main/p/procps/procps_3.2.8.orig.tar.gz">top相关源码</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Linux-C语言实现按键即时识别&quot;&gt;&lt;a href=&quot;#Linux-C语言实现按键即时识别&quot; class=&quot;headerlink&quot; title=&quot;Linux C语言实现按键即时识别&quot;&gt;&lt;/a&gt;Linux C语言实现按键即时识别&lt;/h1&gt;&lt;p&gt;top中的源代码，慢</summary>
      
    
    
    
    <category term="Linux" scheme="https://www.delta1037.cn/categories/Linux/"/>
    
    
    <category term="Linux" scheme="https://www.delta1037.cn/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Shell脚本基础</title>
    <link href="https://www.delta1037.cn/2020/Linux/shell%E8%84%9A%E6%9C%AC%E5%9F%BA%E7%A1%80/"/>
    <id>https://www.delta1037.cn/2020/Linux/shell%E8%84%9A%E6%9C%AC%E5%9F%BA%E7%A1%80/</id>
    <published>2020-12-03T11:16:31.000Z</published>
    <updated>2020-12-11T17:31:04.789Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Shell脚本基础"><a href="#Shell脚本基础" class="headerlink" title="Shell脚本基础"></a>Shell脚本基础</h1><h2 id="一、变量"><a href="#一、变量" class="headerlink" title="一、变量"></a>一、变量</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用变量，建议方式</span></span><br><span class="line"><span class="variable">$&#123;var&#125;</span></span><br><span class="line"><span class="comment"># 在变量名var后是空格时才可用如下方式</span></span><br><span class="line"><span class="variable">$var</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设定只读变量</span></span><br><span class="line"><span class="built_in">declare</span> -r var_name</span><br><span class="line"><span class="built_in">readonly</span> var_name</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除变量</span></span><br><span class="line">uset var_name</span><br></pre></td></tr></table></figure><h3 id="1-1-字符串变量"><a href="#1-1-字符串变量" class="headerlink" title="1.1 字符串变量"></a>1.1 字符串变量</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 字符串的定义</span></span><br><span class="line">var_string=<span class="string">&quot;hello world&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 字符串的长度计算</span></span><br><span class="line"><span class="variable">$&#123;#var_string&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 字符串拼接</span></span><br><span class="line">var_string_new=<span class="string">&quot;<span class="variable">$&#123;var_string&#125;</span> new string&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">######## 字符串操作 ########</span></span><br><span class="line"><span class="comment"># 根据起始和截取长度截取字符串</span></span><br><span class="line"><span class="variable">$&#123;string_var:start_index:length&#125;</span> </span><br></pre></td></tr></table></figure><h3 id="1-2-变量赋值"><a href="#1-2-变量赋值" class="headerlink" title="1.2 变量赋值"></a>1.2 变量赋值</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 除了显式赋值，也可以将命令的结果存入到变量，如下就是将`ls /etc`的结果存到到了file_array</span></span><br><span class="line">file_array=$( ls /etc )</span><br><span class="line"></span><br><span class="line"><span class="comment"># 也可以使用` 命令 `方式</span></span><br><span class="line">file_array=` ls /etc `</span><br><span class="line"></span><br><span class="line"><span class="comment"># 应用:循环访问文件</span></span><br><span class="line"><span class="keyword">for</span> file <span class="keyword">in</span> $( ls /etc )</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">      <span class="comment"># do something</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><h3 id="1-3-数组变量"><a href="#1-3-数组变量" class="headerlink" title="1.3 数组变量"></a>1.3 数组变量</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 数组的定义</span></span><br><span class="line">array_var=(val0 val1 val2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 单独定义每个元素</span></span><br><span class="line">array_var[0]=val0</span><br><span class="line">array_var[1]=val1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取所有元素</span></span><br><span class="line"><span class="variable">$&#123;array_var[@]&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取数组的长度/元素个数</span></span><br><span class="line"><span class="variable">$&#123;#array_var[@]&#125;</span></span><br><span class="line"><span class="variable">$&#123;#array_var[*]&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取单个元素长度</span></span><br><span class="line"><span class="variable">$&#123;#array_var[n]&#125;</span></span><br></pre></td></tr></table></figure><h2 id="二、运算符"><a href="#二、运算符" class="headerlink" title="二、运算符"></a>二、运算符</h2><h3 id="2-1-算数运算符"><a href="#2-1-算数运算符" class="headerlink" title="2.1 算数运算符"></a>2.1 算数运算符</h3><ul><li><code>+、-、*、/，%</code> 借助<code>expr</code>进行计算，例如<code>expr $var1 + $var2</code></li><li><code>=</code> 赋值</li><li><code>==</code> <strong>数字</strong>比较相等返回true，<code>[ $var1 == $var2 ]</code></li><li><code>!=</code> <strong>数字</strong>比较不相等返回true，<code>[ $var1 != $var2 ]</code></li></ul><h3 id="2-2-关系运算符"><a href="#2-2-关系运算符" class="headerlink" title="2.2 关系运算符"></a>2.2 关系运算符</h3><p>关系运算符只用于比较<strong>数字</strong>之间的关系，<strong>不支持字符串，除非字符串的值是数字</strong></p><ul><li><code>-eq</code> 数字相等返回true，<code>[ $var1 -eq $var2 ]</code> =&gt; <code>==</code></li><li><code>-ne</code> 数字不相等返回true，<code>[ $var1 -nq $var2 ]</code> =&gt; <code>!=</code></li><li><code>-gt</code> 左边大于右边返回true，<code>[ $var1 -gt $var2 ]</code> =&gt; <code>&gt;</code></li><li><code>-lt</code> 左边小于右边返回true，<code>[ $var1 -lt $var2 ]</code> =&gt; <code>&lt;</code></li><li><code>-ge</code> 左边大于等于右边返回true，<code>[ $var1 -ge $var2 ]</code> =&gt; <code>&gt;=</code></li><li><code>-le</code> 左边小于等于右边返回true，<code>[ $var1 -le $var2 ]</code> =&gt; <code>&lt;=</code></li></ul><h3 id="2-3-布尔运算符"><a href="#2-3-布尔运算符" class="headerlink" title="2.3 布尔运算符"></a>2.3 布尔运算符</h3><p>设<code>var1=10，var2=20</code></p><ul><li><code>!</code> 非运算，表达式为false，返回true，<code>[ ! false ]</code>返回true</li><li><code>-o</code> 或运算，有一个表达式为true就为true，<code>[ $var1 -lt 20 -o $var1 -gt 100 ]</code>返回true</li><li><code>-a</code> 与运算，所有表达式为true才是true，<code>[ $var1 -lt 20 -a $var1 -gt 100 ]</code>返回false</li></ul><h3 id="2-4-逻辑运算符"><a href="#2-4-逻辑运算符" class="headerlink" title="2.4 逻辑运算符"></a>2.4 逻辑运算符</h3><ul><li>&amp;&amp; ：逻辑的AND</li><li>|| ：逻辑的OR</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 注意需要两个嵌套的中括号</span></span><br><span class="line"><span class="keyword">if</span> [[ <span class="variable">$&#123;var1&#125;</span> == 0 &amp;&amp; <span class="variable">$&#123;var2&#125;</span> == 0 ]];<span class="keyword">then</span></span><br><span class="line">     // <span class="keyword">do</span> something</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><h3 id="2-5-字符串运算符"><a href="#2-5-字符串运算符" class="headerlink" title="2.5 字符串运算符"></a>2.5 字符串运算符</h3><p>设<code>var1=&quot;abc&quot;，var2=&quot;efg&quot;</code></p><ul><li><code>=</code> 检测字符串相等返回true，<code>[ $var1 = $var2 ]</code>返回false</li><li><code>!=</code> 检测字符串不相等返回true，<code>[ $var1 != $var2 ]</code>返回true</li><li><code>-z</code> 检测字符串长度为0返回true，<code>[ -z $var1 ]</code>返回false</li><li><code>-n</code> 检测字符串长度不为0返回true，<code>[ -n $var1 ]</code>返回true</li><li><code>$</code> 检测字符串不为空返回true，<code>[ $var1 ]</code>返回true</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">########## 字符串为空和字符串长度的运算测试 ##########</span></span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">var1=</span><br><span class="line">var2=<span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ -z <span class="variable">$var1</span> ];<span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;var1 字符串长度为0&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;var1 字符串长度不为0&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ -z <span class="variable">$var2</span> ];<span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;var2 字符串长度为0&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;var2 字符串长度不为0&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ -z <span class="variable">$no_exits</span> ];<span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;no_exits 字符串长度为0&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;no_exits 字符串长度不为0&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$var1</span> ];<span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;var1 字符串不为空&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;var1 字符串为空&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$var2</span> ];<span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;var2 字符串不为空&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;var2 字符串为空&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$no_exits</span> ];<span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;no_exits 字符串不为空&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;no_exits 字符串为空&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment">########## 输出 ##########</span></span><br><span class="line">var1 字符串长度为0</span><br><span class="line">var2 字符串长度为0</span><br><span class="line">no_exits 字符串长度为0</span><br><span class="line">var1 字符串为空</span><br><span class="line">var2 字符串为空</span><br><span class="line">no_exits 字符串为空</span><br><span class="line"></span><br><span class="line"><span class="comment">########## 结论 ##########</span></span><br><span class="line">字符串长度和字符串是否为空的运算*好像*是一致的，他们有没有区别呢？</span><br></pre></td></tr></table></figure><h3 id="2-6-文件测试运算符"><a href="#2-6-文件测试运算符" class="headerlink" title="2.6 文件测试运算符"></a>2.6 文件测试运算符</h3><p>使用方法：\<operator\> file_name</p><p>operator</p><ul><li><code>-e</code> 文件是否存在</li><li><code>-r</code> 文件可读检测</li><li><code>-w</code> 文件可写检测</li><li><code>-x</code> 文件可执行检测</li><li><code>-d</code> 目录检测</li><li><code>-f</code> 普通文件检测（既不是目录，也不是设备文件）</li><li><code>-b</code> 块设备检测</li><li><code>-c</code> 字符设备检测</li><li><code>-p</code> 有名管道检测</li><li><code>-s</code> 文件大小是否为0</li><li><code>-S</code> 文件是否是socket连接</li><li><code>-L</code> 文件是否存在并且是一个符号链接</li><li><code>-g</code> 文件SGID位检测</li><li><code>-u</code> 文件SUID位检测</li><li><code>-k</code> 文件粘滞位（Sticky Bit）检测</li></ul><h2 id="三、参考文章"><a href="#三、参考文章" class="headerlink" title="三、参考文章"></a>三、参考文章</h2><p>【1】<a href="https://www.runoob.com/linux/linux-shell.html">Shell 教程</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Shell脚本基础&quot;&gt;&lt;a href=&quot;#Shell脚本基础&quot; class=&quot;headerlink&quot; title=&quot;Shell脚本基础&quot;&gt;&lt;/a&gt;Shell脚本基础&lt;/h1&gt;&lt;h2 id=&quot;一、变量&quot;&gt;&lt;a href=&quot;#一、变量&quot; class=&quot;headerli</summary>
      
    
    
    
    <category term="Linux" scheme="https://www.delta1037.cn/categories/Linux/"/>
    
    
    <category term="Linux" scheme="https://www.delta1037.cn/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux获取时间</title>
    <link href="https://www.delta1037.cn/2020/Linux/Linux%E8%8E%B7%E5%8F%96%E6%97%B6%E9%97%B4/"/>
    <id>https://www.delta1037.cn/2020/Linux/Linux%E8%8E%B7%E5%8F%96%E6%97%B6%E9%97%B4/</id>
    <published>2020-11-20T11:16:31.000Z</published>
    <updated>2020-12-11T17:31:05.813Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux获取时间"><a href="#Linux获取时间" class="headerlink" title="Linux获取时间"></a>Linux获取时间</h1><h2 id="一、获取时间"><a href="#一、获取时间" class="headerlink" title="一、获取时间"></a>一、获取时间</h2><h3 id="1-1-获取秒、微秒"><a href="#1-1-获取秒、微秒" class="headerlink" title="1.1 获取秒、微秒"></a>1.1 获取秒、微秒</h3><p>Linux中获取微秒级时间的系统调用<code>gettimeofday()</code>，但是返回值的准确性依赖于系统的架构。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="comment">/* 在tz指向的缓冲区中返回日历时间；Linux不支持tz参数，设置为NULL */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gettimeofday</span><span class="params">(struct timeval *tv, struct timezone *tz)</span></span>; </span><br></pre></td></tr></table></figure><p>其中<code>timeval</code>结构体定义如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> &#123;</span></span><br><span class="line">    <span class="keyword">time_t</span> tv_sec;  <span class="comment">/* 从1970年1月1日00:00:00以来的秒数(long) */</span></span><br><span class="line">    <span class="keyword">suseconds_t</span> tv_usec; <span class="comment">/* 附加的微秒(long int) */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>time()</code>系统调用返回自Epoch( 1970年1月1日00:00:00 )以来的秒数，如果<code>p_time</code>参数不为空，则会将返回值置于<code>p_time</code>指向的位置。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">time_t</span> <span class="title">time</span><span class="params">(<span class="keyword">time_t</span> *p_time)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="二、时间转换"><a href="#二、时间转换" class="headerlink" title="二、时间转换"></a>二、时间转换</h2><h3 id="2-1-time-t和可打印的格式"><a href="#2-1-time-t和可打印的格式" class="headerlink" title="2.1 time_t和可打印的格式"></a>2.1 time_t和可打印的格式</h3><p><code>ctime()</code>提供了一种简单的将时间转成字符串格式的转换方式。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">ctime</span><span class="params">(<span class="keyword">const</span> <span class="keyword">time_t</span> *p_time)</span></span>; <span class="comment">// 返回的字符串包括终止空字符和换行符</span></span><br><span class="line"><span class="comment">// output eg :  Wed Jun  8 14:22:34 2012 </span></span><br><span class="line"><span class="comment">// 返回的字符串是静态分配的，下次调用会覆盖</span></span><br></pre></td></tr></table></figure><p>注：在SUSv3规定，调用<code>ctime()</code>、<code>gmtime()</code>、<code>localTime()</code>或<code>asctime()</code>中的任一个函数，都可能覆盖其它函数的返回</p><h3 id="2-2-time-t和分解的格式"><a href="#2-2-time-t和分解的格式" class="headerlink" title="2.2 time_t和分解的格式"></a>2.2 time_t和分解的格式</h3><p><code>gmtime()</code>可以把日历时间转换成一个对应UTC的分解的时间；<code>localTime()</code>考虑时区和夏令时的设置，返回对应系统本地时间的分解时间</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="function">struct tm *<span class="title">gmtime</span><span class="params">(<span class="keyword">const</span> <span class="keyword">time_t</span> *p_time)</span></span>;</span><br><span class="line"><span class="function">struct tm *<span class="title">localTime</span><span class="params">(<span class="keyword">const</span> <span class="keyword">time_t</span> *p_time)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可重入版本</span></span><br><span class="line"><span class="function">struct tm *<span class="title">gmtime_r</span><span class="params">(<span class="keyword">const</span> <span class="keyword">time_t</span> *p_time)</span></span>;</span><br><span class="line"><span class="function">struct tm *<span class="title">localTime_r</span><span class="params">(<span class="keyword">const</span> <span class="keyword">time_t</span> *p_time)</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分解时间结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tm</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span>    tm_sec;   <span class="comment">/* seconds [0,61] */</span></span><br><span class="line">    <span class="keyword">int</span>    tm_min;   <span class="comment">/* minutes [0,59] */</span></span><br><span class="line">    <span class="keyword">int</span>    tm_hour;  <span class="comment">/* hour [0,23] */</span></span><br><span class="line">    <span class="keyword">int</span>    tm_mday;  <span class="comment">/* day of month [1,31] */</span></span><br><span class="line">    <span class="keyword">int</span>    tm_mon;   <span class="comment">/* month of year [0,11] */</span></span><br><span class="line">    <span class="keyword">int</span>    tm_year;  <span class="comment">/* years since 1900 */</span></span><br><span class="line">    <span class="keyword">int</span>    tm_wday;  <span class="comment">/* day of week [0,6] (Sunday = 0) */</span></span><br><span class="line">    <span class="keyword">int</span>    tm_yday;  <span class="comment">/* day of year [0,365] */</span></span><br><span class="line">    <span class="keyword">int</span>    tm_isdst; <span class="comment">/* daylight savings flag */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="2-3-分解的格式与可打印格式"><a href="#2-3-分解的格式与可打印格式" class="headerlink" title="2.3 分解的格式与可打印格式"></a>2.3 分解的格式与可打印格式</h3><p><code>asctime()</code>将分解的格式转换成可打印的格式，指向由静态分配的字符串</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">asctime</span><span class="params">(<span class="keyword">const</span> struct tm *timeptr)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可重入版本</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">asctime_r</span><span class="params">(<span class="keyword">const</span> struct tm *timeptr)</span></span>;</span><br></pre></td></tr></table></figure><p><code>strftime()</code>在将分解的时间转换成可打印的格式时提供更为精确的控制。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">strftime</span><span class="params">(<span class="keyword">char</span> *out_str, <span class="keyword">size_t</span> max_size, <span class="keyword">const</span> <span class="keyword">char</span> *format, <span class="keyword">const</span> struct tm *timeptr)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// strftime不会自动添加换行符</span></span><br><span class="line"><span class="comment">// out_str会按照format做格式化</span></span><br></pre></td></tr></table></figure><p>format参数定义：</p><div class="table-container"><table><thead><tr><th style="text-align:left">说明符</th><th style="text-align:left">描述</th><th style="text-align:left">实例</th></tr></thead><tbody><tr><td style="text-align:left">%a</td><td style="text-align:left">星期几的缩写</td><td style="text-align:left">Tue</td></tr><tr><td style="text-align:left">%A</td><td style="text-align:left">星期几的全称</td><td style="text-align:left">Tuesday</td></tr><tr><td style="text-align:left">%b</td><td style="text-align:left">月份名称的缩写</td><td style="text-align:left">Feb</td></tr><tr><td style="text-align:left">%B</td><td style="text-align:left">月份全称</td><td style="text-align:left">February</td></tr><tr><td style="text-align:left">%c</td><td style="text-align:left">日期和时间</td><td style="text-align:left">Tue Feb  1 21:39:46 2011</td></tr><tr><td style="text-align:left">%d</td><td style="text-align:left">一月中的一天（两位数字，01-31）</td><td style="text-align:left">01</td></tr><tr><td style="text-align:left">%D</td><td style="text-align:left">美国日期的格式（同%m%d%y）</td><td style="text-align:left">02/01/2011</td></tr><tr><td style="text-align:left">%e</td><td style="text-align:left">一月中的一天（两个字符）</td><td style="text-align:left">1</td></tr><tr><td style="text-align:left">%F</td><td style="text-align:left">ISO格式的日期（%Y-%m-%d）</td><td style="text-align:left">2011-02-01</td></tr><tr><td style="text-align:left">%H</td><td style="text-align:left">24 小时格式的小时（两位数，00-23）</td><td style="text-align:left">21</td></tr><tr><td style="text-align:left">%I</td><td style="text-align:left">12 小时格式的小时（两位数，01-12）</td><td style="text-align:left">09</td></tr><tr><td style="text-align:left">%j</td><td style="text-align:left">一年中的第几天（三位数，001-366）</td><td style="text-align:left">032</td></tr><tr><td style="text-align:left">%m</td><td style="text-align:left">十进制数表示的月份（两位，01-12）</td><td style="text-align:left">08</td></tr><tr><td style="text-align:left">%M</td><td style="text-align:left">分（两位，00-59）</td><td style="text-align:left">55</td></tr><tr><td style="text-align:left">%p</td><td style="text-align:left">AM 或 PM 名称</td><td style="text-align:left">PM</td></tr><tr><td style="text-align:left">%P</td><td style="text-align:left">上午/下午（GNU扩展）</td><td style="text-align:left">pm</td></tr><tr><td style="text-align:left">%R</td><td style="text-align:left">24小时制的时间（%H:%M）</td><td style="text-align:left">21:39</td></tr><tr><td style="text-align:left">%S</td><td style="text-align:left">秒（00-61）</td><td style="text-align:left">46</td></tr><tr><td style="text-align:left">%T</td><td style="text-align:left">时间（%H:%M:%S）</td><td style="text-align:left">21:39:46</td></tr><tr><td style="text-align:left">%u</td><td style="text-align:left">星期几编号（1-7）</td><td style="text-align:left">2</td></tr><tr><td style="text-align:left">%U</td><td style="text-align:left">一年中的第几周，以第一个星期日作为第一周的第一天（00-53）</td><td style="text-align:left">05</td></tr><tr><td style="text-align:left">%w</td><td style="text-align:left">十进制数表示的星期几，星期日表示为 0（0-6）</td><td style="text-align:left">2</td></tr><tr><td style="text-align:left">%W</td><td style="text-align:left">一年中的第几周，以第一个星期一作为第一周的第一天（00-53）</td><td style="text-align:left">05</td></tr><tr><td style="text-align:left">%x</td><td style="text-align:left">日期表示法（本地化）</td><td style="text-align:left">02/01/2011</td></tr><tr><td style="text-align:left">%X</td><td style="text-align:left">时间表示法（本地化）</td><td style="text-align:left">21:39:46</td></tr><tr><td style="text-align:left">%y</td><td style="text-align:left">两位数字年份，最后两个数字（00-99）</td><td style="text-align:left">11</td></tr><tr><td style="text-align:left">%Y</td><td style="text-align:left">四位数字年份</td><td style="text-align:left">2011</td></tr><tr><td style="text-align:left">%Z</td><td style="text-align:left">时区的名称或缩写</td><td style="text-align:left">CET</td></tr><tr><td style="text-align:left">%%</td><td style="text-align:left">一个 % 符号</td><td style="text-align:left">%</td></tr></tbody></table></div><p><code>strptime()</code>是<code>strftime()</code>的逆向函数，将包含日期的字符串转换成分解的时间</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _XOPNE_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strptime</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str, <span class="keyword">const</span> <span class="keyword">char</span> *format, struct tm *time_ptr)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="转换图"><a href="#转换图" class="headerlink" title="转换图"></a>转换图</h2><p>下图来自Linux/Unix系统编程手册</p><p><img src="https://delta1037.oss-cn-beijing.aliyuncs.com/hexo-blog/Linux_getTime/time_trans.png" alt=""></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Linux获取时间&quot;&gt;&lt;a href=&quot;#Linux获取时间&quot; class=&quot;headerlink&quot; title=&quot;Linux获取时间&quot;&gt;&lt;/a&gt;Linux获取时间&lt;/h1&gt;&lt;h2 id=&quot;一、获取时间&quot;&gt;&lt;a href=&quot;#一、获取时间&quot; class=&quot;head</summary>
      
    
    
    
    <category term="Linux" scheme="https://www.delta1037.cn/categories/Linux/"/>
    
    
    <category term="Linux" scheme="https://www.delta1037.cn/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>C++ 类型转换</title>
    <link href="https://www.delta1037.cn/2020/C_C++/C++%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"/>
    <id>https://www.delta1037.cn/2020/C_C++/C++%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</id>
    <published>2020-04-25T03:19:45.000Z</published>
    <updated>2020-12-11T17:31:00.813Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-类型转换"><a href="#C-类型转换" class="headerlink" title="C++类型转换"></a>C++类型转换</h1><p>典型的C类型转换如下所示</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Typename_1 var_type_1;</span><br><span class="line">Typename_0 var_type_0 = (Typename_0)var_type_1;</span><br></pre></td></tr></table></figure><p>在C语言中，不管什么类型的转换都可以使用上述的形式；C++也支持上述类型的强制类型转换，但是这种转换可能会带来一些隐患，所以C++提供了四个在不同场合的强制类型转换函数：<code>const_cast</code>, <code>static_cast</code>, <code>dynamic_cast</code>, <code>reinterpret_cast</code></p><h2 id="一、const-cast"><a href="#一、const-cast" class="headerlink" title="一、const_cast"></a>一、const_cast</h2><p>const_cast用于修改指针或者引用，将指针或引用的常量形式转为非常量的形式，并且仍然指向原来的对象</p><p><strong>SUM：</strong></p><ul><li>修改指针或者引用</li><li>常量转为非常量</li></ul><p><strong>Code：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># 正常的使用方法</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">test_func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">6</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> *p_const_num = &amp;num;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> *p_num = <span class="keyword">const_cast</span>&lt;<span class="keyword">int</span>*&gt;p_const_num;</span><br><span class="line">    *p_num = <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 未定义的使用方法</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">test_func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *p_const_str = <span class="string">&quot;ABCD&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">char</span> *p_str = <span class="keyword">const_cast</span>&lt;<span class="keyword">char</span>*&gt;p_const_str;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二、static-cast"><a href="#二、static-cast" class="headerlink" title="二、static_cast"></a>二、static_cast</h2><p>static_cast与C语言风格的强制转换效果一样</p><p><strong>SUM：</strong></p><p>常用于：</p><ul><li><p>类层次结构中基类（父类）和派生类（子类）之间指针或引用的转换。注意：进行上行转换（把派生类的指针或引用转换成基类表示）是安全的；进行下行转换（把基类指针或引用转换成派生类表示）时，由于没有动态类型检查，所以是不安全的。</p></li><li><p>基本数据类型之间的转换，如把int转换成char，把int转换成enum。安全性需要开发者来维护</p></li></ul><p><strong>注：</strong></p><ul><li><strong>没有运行时检查</strong>，与C风格一样都存在安全隐患</li><li>static_cast不能转换掉原有类型的const、volatile、或者 __unaligned属性。(前两种可以使用const_cast 来去除)</li><li>c++ 的任何的隐式转换都是使用 <em>static_cast</em> 来实现</li></ul><p><strong>Code：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h2 id="三、dynamic-cast"><a href="#三、dynamic-cast" class="headerlink" title="三、dynamic_cast"></a>三、dynamic_cast</h2><h2 id="四、reinterpret-cast"><a href="#四、reinterpret-cast" class="headerlink" title="四、reinterpret_cast"></a>四、reinterpret_cast</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;C-类型转换&quot;&gt;&lt;a href=&quot;#C-类型转换&quot; class=&quot;headerlink&quot; title=&quot;C++类型转换&quot;&gt;&lt;/a&gt;C++类型转换&lt;/h1&gt;&lt;p&gt;典型的C类型转换如下所示&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>deltaNote</title>
    <link href="https://www.delta1037.cn/2019/Deploy/deltaNoteSite/"/>
    <id>https://www.delta1037.cn/2019/Deploy/deltaNoteSite/</id>
    <published>2019-11-23T07:00:59.000Z</published>
    <updated>2020-12-11T17:31:03.869Z</updated>
    
    <content type="html"><![CDATA[<h1 id="deltaNote"><a href="#deltaNote" class="headerlink" title="deltaNote"></a>deltaNote</h1><h2 id="一、资源地址"><a href="#一、资源地址" class="headerlink" title="一、资源地址"></a>一、资源地址</h2><p><a href="https://github.com/delta1037/deltaNote">项目github地址</a><br><a href="https://github.com/delta1037/deltaNote/releases">发行版下载地址</a></p><h2 id="二、使用说明"><a href="#二、使用说明" class="headerlink" title="二、使用说明"></a>二、使用说明</h2><h3 id="2-1-Linux服务端安装"><a href="#2-1-Linux服务端安装" class="headerlink" title="2.1 Linux服务端安装"></a>2.1 Linux服务端安装</h3><p>1、从<a href="https://github.com/delta1037/deltaNote/releases">发行版下载地址</a>下载服务端，解压<br>2、进入解压后的目录，使用<code>./deltaNote</code>命令运行，可以使用<code>netstat -anpt | grep 8888</code>看到服务端已在运行<br>3、可以使用<code>vim deltaNote</code>修改端口等参数</p><ul><li>目前测试服务端：<code>39.96.162.190:8888</code></li></ul><h3 id="2-2-Linux客户端安装"><a href="#2-2-Linux客户端安装" class="headerlink" title="2.2 Linux客户端安装"></a>2.2 Linux客户端安装</h3><p>1、下载压缩包之后，解压<br>2、执行<code>sudo ./install.sh</code>即可安装到<code>/usr/local/deltaNote</code><br>3、执行<code>sudo ./uninstall.sh</code>即可卸载</p><h3 id="2-3-window客户端安装"><a href="#2-3-window客户端安装" class="headerlink" title="2.3 window客户端安装"></a>2.3 window客户端安装</h3><p>1、下载压缩包，解压<br>2、双击<code>*.exe</code>运行安装程序（目前不支持安装在C盘）</p><h3 id="2-4-deltaNote简介"><a href="#2-4-deltaNote简介" class="headerlink" title="2.4 deltaNote简介"></a>2.4 deltaNote简介</h3><h4 id="2-4-1-主界面"><a href="#2-4-1-主界面" class="headerlink" title="2.4.1 主界面"></a>2.4.1 主界面</h4><p>主界面如下图所示<br><img src="https://delta1037.oss-cn-beijing.aliyuncs.com/hexo-blog/deltaNote/main.png" alt="主界面"></p><ul><li>主界面简介：主界面上部有四个按钮，分别是设置，刷新，界面锁和历史记录<ul><li>设置按钮：打开设置面板</li><li>刷新按钮：与服务端进行同步</li><li>界面锁按钮：界面锁打开时，可以对主界面位置进行调整</li><li>历史记录按钮：点击打开查看已做的内容，打开历史记录使用右键可以选择清理历史记录</li></ul></li><li>位置和大小：当界面锁是开启状态时，可以对窗体进行调整，其中<code>1</code>位置可以拖动窗口；<code>2</code>位置可以调整窗体的高度。</li><li>勾选已做：点击每条TODO的前边的小方框，可以将TODO标记为已做，可以在历史记录中查看</li></ul><h4 id="2-4-2-设置"><a href="#2-4-2-设置" class="headerlink" title="2.4.2 设置"></a>2.4.2 设置</h4><p>点击主界面中的设置按钮，可以看到设置界面，如下所示<br><img src="https://delta1037.oss-cn-beijing.aliyuncs.com/hexo-blog/deltaNote/setting.png" alt="设置"></p><ul><li>设置界面简介：<ul><li>服务端地址和端口(目前仅支持IP地址)</li><li>用户名和密码</li><li>调整窗体的透明度</li><li>调整字体大小</li><li>调整主界面宽度</li><li>调整字体和图标颜色</li><li>设置开机启动</li></ul></li></ul><h4 id="2-4-3-创建用户"><a href="#2-4-3-创建用户" class="headerlink" title="2.4.3 创建用户"></a>2.4.3 创建用户</h4><p>点击设置中的创建用户按钮，如下图所示<br><img src="https://delta1037.oss-cn-beijing.aliyuncs.com/hexo-blog/deltaNote/createUser.png" alt="创建用户"></p><p>填入用户名和密码即可创建新用户</p><h2 id="三、问题反馈"><a href="#三、问题反馈" class="headerlink" title="三、问题反馈"></a>三、问题反馈</h2><p><a href="https://github.com/delta1037/deltaNote/issues">问题反馈</a></p><h2 id="四、问题"><a href="#四、问题" class="headerlink" title="四、问题"></a>四、问题</h2><ul><li>window客户端不要安装在C盘，因为安装和运行时没有获取管理员权限</li><li>window客户端开机启动选项打开之后，需要在任务管理器的启动页面禁用再启用</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;deltaNote&quot;&gt;&lt;a href=&quot;#deltaNote&quot; class=&quot;headerlink&quot; title=&quot;deltaNote&quot;&gt;&lt;/a&gt;deltaNote&lt;/h1&gt;&lt;h2 id=&quot;一、资源地址&quot;&gt;&lt;a href=&quot;#一、资源地址&quot; class=&quot;head</summary>
      
    
    
    
    <category term="部署" scheme="https://www.delta1037.cn/categories/%E9%83%A8%E7%BD%B2/"/>
    
    
    <category term="便签" scheme="https://www.delta1037.cn/tags/%E4%BE%BF%E7%AD%BE/"/>
    
  </entry>
  
  <entry>
    <title>MySQL使用MariaDB Audit Plugin实现审计功能</title>
    <link href="https://www.delta1037.cn/2019/Deploy/MySQL%E4%BD%BF%E7%94%A8MariaDB-Audit-Plugin%E5%AE%9E%E7%8E%B0%E5%AE%A1%E8%AE%A1%E5%8A%9F%E8%83%BD/"/>
    <id>https://www.delta1037.cn/2019/Deploy/MySQL%E4%BD%BF%E7%94%A8MariaDB-Audit-Plugin%E5%AE%9E%E7%8E%B0%E5%AE%A1%E8%AE%A1%E5%8A%9F%E8%83%BD/</id>
    <published>2019-10-20T04:35:08.000Z</published>
    <updated>2020-12-11T17:31:02.845Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、安装MariaDB-Audit-Plugin"><a href="#一、安装MariaDB-Audit-Plugin" class="headerlink" title="一、安装MariaDB Audit Plugin"></a>一、安装MariaDB Audit Plugin</h2><h3 id="1-1-准备MariaDB安装环境"><a href="#1-1-准备MariaDB安装环境" class="headerlink" title="1.1 准备MariaDB安装环境"></a>1.1 准备MariaDB安装环境</h3><p>为了不对使用mysql的主机造成影响，建议使用另一台与mysql主机系统一致的主机来安装MariaDB，然后不用执行下面的卸载操作<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get autoremove --purge mysql-\*</span><br><span class="line">sudo rm -rf /var/lib/mysql*</span><br><span class="line">sudo rm -rf /etc/mysql/</span><br></pre></td></tr></table></figure></p><h3 id="1-2-安装MariaDB"><a href="#1-2-安装MariaDB" class="headerlink" title="1.2 安装MariaDB"></a>1.2 安装MariaDB</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install mariadb-server</span><br></pre></td></tr></table></figure><p>安装完成之后在/usr/lib/mysql/plugin目录中有server_audit.so插件，将该插件拷贝出来备用（拷贝到mysql主机的/usr/lib/mysql/plugin目录中）</p><h3 id="1-3-MySQL环境恢复"><a href="#1-3-MySQL环境恢复" class="headerlink" title="1.3 MySQL环境恢复"></a>1.3 MySQL环境恢复</h3><p>如果是在mysql的主机上进行安装MariaDB操作，使用如下命令将MariaDB卸载，并重新安装mysql<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get remove --purge mariadb-\*</span><br><span class="line">sudo rm -rf /etc/mysql/</span><br><span class="line">sudo rm -rf /var/lib/mysql*</span><br><span class="line">sudo apt-get remove --purge mysql-\*</span><br><span class="line">sudo apt-get install mysql-server mysql-client</span><br></pre></td></tr></table></figure></p><h3 id="1-4-添加MySQL配置"><a href="#1-4-添加MySQL配置" class="headerlink" title="1.4 添加MySQL配置"></a>1.4 添加MySQL配置</h3><p>修改/etc/mysql/my.cnf文件，在文件末尾添加如下内容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">log_output&#x3D;FILE</span><br><span class="line">server_audit_file_path&#x3D;&#x2F;var&#x2F;log&#x2F;mysql&#x2F;audit.log</span><br><span class="line">server_audit_events &#x3D; &#39;QUERY_DCL,QUERY_DML_NO_SELECT,QUERY_DML,QUERY_DDL,TABLE,QUERY,CONNECT&#39;</span><br><span class="line">server_audit_logging&#x3D;1</span><br></pre></td></tr></table></figure><br>重新启动MySQL<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service mysql restart</span><br></pre></td></tr></table></figure></p><h2 id="二、Mysql审计日志分析"><a href="#二、Mysql审计日志分析" class="headerlink" title="二、Mysql审计日志分析"></a>二、Mysql审计日志分析</h2><h3 id="2-1-server-audit-events变量过滤功能"><a href="#2-1-server-audit-events变量过滤功能" class="headerlink" title="2.1 server_audit_events变量过滤功能"></a>2.1 server_audit_events变量过滤功能</h3><p>使用mysql -uroot -p登陆数据库，执行如下命令修改变量为如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set global server_audit_events&#x3D;&#39;QUERY_DDL&#39;;</span><br></pre></td></tr></table></figure><br>执行如下SQL语句<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">create database test2;</span><br><span class="line">use test2;</span><br><span class="line">create table table1 (col1 VARCHAR(20));</span><br><span class="line">insert into table1 values (&quot;lili&quot;);</span><br><span class="line">select * from table1;</span><br></pre></td></tr></table></figure><br><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">20191019 </span><span class="number">20</span>:<span class="number">56</span>:<span class="number">50</span>,delta-mysql,root,localhost,<span class="number">16</span>,<span class="number">1300</span>,QUERY,test,<span class="comment">&#x27;create database test2&#x27;,0</span></span><br><span class="line"><span class="symbol">20191019 </span><span class="number">20</span>:<span class="number">57</span>:<span class="number">29</span>,delta-mysql,root,localhost,<span class="number">16</span>,<span class="number">1306</span>,QUERY,test2,<span class="comment">&#x27;create table table1 (col1 VARCHAR(20))&#x27;,0</span></span><br></pre></td></tr></table></figure><br>由上图可见只有create类型的日志被记录下来，insert和select类型的操作日志并没有被记录下来，并且操作类型字段显示为QUERY类型</p><p>使用mysql -uroot -p登陆数据库，执行如下命令修改变量为如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set global server_audit_events&#x3D;&#39;QUERY_DDL,QUERY_DML&#39;;</span><br></pre></td></tr></table></figure><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">create database test3;</span><br><span class="line">use test3;</span><br><span class="line">create table table2 (col1 VARCHAR(20));</span><br><span class="line">insert into table2 values (&quot;lili&quot;);</span><br><span class="line">select * from table2;</span><br></pre></td></tr></table></figure></p><p>前两行是上面的日志，后面的是新产生的日志<br><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">20191019 </span><span class="number">20</span>:<span class="number">56</span>:<span class="number">50</span>,delta-mysql,root,localhost,<span class="number">16</span>,<span class="number">1300</span>,QUERY,test,<span class="comment">&#x27;create database test2&#x27;,0</span></span><br><span class="line"><span class="symbol">20191019 </span><span class="number">20</span>:<span class="number">57</span>:<span class="number">29</span>,delta-mysql,root,localhost,<span class="number">16</span>,<span class="number">1306</span>,QUERY,test2,<span class="comment">&#x27;create table table1 (col1 VARCHAR(20))&#x27;,0</span></span><br><span class="line"><span class="symbol">20191019 </span><span class="number">21</span>:<span class="number">45</span>:<span class="number">18</span>,delta-mysql,root,localhost,<span class="number">16</span>,<span class="number">1312</span>,QUERY,test2,<span class="comment">&#x27;create table table2 (col1 VARCHAR(20))&#x27;,0</span></span><br><span class="line"><span class="symbol">20191019 </span><span class="number">21</span>:<span class="number">45</span>:<span class="number">33</span>,delta-mysql,root,localhost,<span class="number">16</span>,<span class="number">1313</span>,QUERY,test2,<span class="comment">&#x27;insert into table2 values (&quot;lili&quot;)&#x27;,0</span></span><br><span class="line"><span class="symbol">20191019 </span><span class="number">21</span>:<span class="number">45</span>:<span class="number">56</span>,delta-mysql,root,localhost,<span class="number">16</span>,<span class="number">1314</span>,QUERY,test2,<span class="comment">&#x27;select * from table2&#x27;,0</span></span><br><span class="line"><span class="symbol">20191019 </span><span class="number">21</span>:<span class="number">47</span>:<span class="number">52</span>,delta-mysql,root,localhost,<span class="number">16</span>,<span class="number">1316</span>,QUERY,test2,<span class="comment">&#x27;create databse test3&#x27;,1064</span></span><br><span class="line"><span class="symbol">20191019 </span><span class="number">21</span>:<span class="number">47</span>:<span class="number">58</span>,delta-mysql,root,localhost,<span class="number">16</span>,<span class="number">1317</span>,QUERY,test2,<span class="comment">&#x27;create database test3&#x27;,0</span></span><br><span class="line"><span class="symbol">20191019 </span><span class="number">21</span>:<span class="number">48</span>:<span class="number">08</span>,delta-mysql,root,localhost,<span class="number">16</span>,<span class="number">1318</span>,QUERY,test2,<span class="comment">&#x27;SELECT DATABASE()&#x27;,0</span></span><br><span class="line"><span class="symbol">20191019 </span><span class="number">21</span>:<span class="number">48</span>:<span class="number">15</span>,delta-mysql,root,localhost,<span class="number">16</span>,<span class="number">1320</span>,QUERY,test2,<span class="comment">&#x27;SELECT DATABASE()&#x27;,0</span></span><br><span class="line"><span class="symbol">20191019 </span><span class="number">21</span>:<span class="number">48</span>:<span class="number">31</span>,delta-mysql,root,localhost,<span class="number">16</span>,<span class="number">1324</span>,QUERY,test3,<span class="comment">&#x27;create table table2 (col1 VARCHAR(20))&#x27;,0</span></span><br><span class="line"><span class="symbol">20191019 </span><span class="number">21</span>:<span class="number">48</span>:<span class="number">31</span>,delta-mysql,root,localhost,<span class="number">16</span>,<span class="number">1325</span>,QUERY,test3,<span class="comment">&#x27;insert into table2 values (&quot;lili&quot;)&#x27;,0</span></span><br><span class="line"><span class="symbol">20191019 </span><span class="number">21</span>:<span class="number">48</span>:<span class="number">31</span>,delta-mysql,root,localhost,<span class="number">16</span>,<span class="number">1326</span>,QUERY,test3,<span class="comment">&#x27;select * from table2&#x27;,0</span></span><br></pre></td></tr></table></figure></p><p>由上可见，create，select和insert类型的日志均被记录下来，并且操作类型字段均为QUERY类型，并不是QUERY_DDL和QUERY_DML类型</p><p>根据<a href="https://mariadb.com/kb/en/library/mariadb-audit-plugin-log-settings/">官方文档</a>显示，QUERY_DDL操作类型指的是进行CREATE等操作时才产生QUERY_DDL操作类型的日志，QUERY_DML操作类型是进行SELECT等操作时才产生QUERY_DML操作类型的日志。</p><p>综上所述，server_audit_events确实对操作日志起到了过滤作用，但是实际日志中操作类型字段只有QUERY。说明QUERY_DDL确实起到了日志类型过滤作用，实际操作类型字段仍为QUERY。</p><h2 id="2-2TABLE-Event分析"><a href="#2-2TABLE-Event分析" class="headerlink" title="2.2TABLE Event分析"></a>2.2TABLE Event分析</h2><p>按照<a href="https://mariadb.com/kb/en/library/mariadb-audit-plugin-log-settings/">官方文档</a>显示，执行查询操作时会显示操作类型为READ的TABLE事件日志<br><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">20170817 </span><span class="number">16</span>:<span class="number">04</span>:<span class="number">33</span>,ip-<span class="number">172</span>-<span class="number">30</span>-<span class="number">0</span>-<span class="number">38</span>,root,localhost,<span class="number">29</span>,<span class="number">913</span>,<span class="keyword">READ</span>,company,employees,</span><br><span class="line"><span class="symbol">20170817 </span><span class="number">16</span>:<span class="number">04</span>:<span class="number">33</span>,ip-<span class="number">172</span>-<span class="number">30</span>-<span class="number">0</span>-<span class="number">38</span>,root,localhost,<span class="number">29</span>,<span class="number">913</span>,<span class="keyword">READ</span>,company,employees_salaries,</span><br><span class="line"><span class="symbol">20170817 </span><span class="number">16</span>:<span class="number">04</span>:<span class="number">33</span>,ip-<span class="number">172</span>-<span class="number">30</span>-<span class="number">0</span>-<span class="number">38</span>,root,localhost,<span class="number">29</span>,<span class="number">913</span>,<span class="keyword">READ</span>,company,ref_job_titles,</span><br><span class="line"><span class="symbol">20170817 </span><span class="number">16</span>:<span class="number">04</span>:<span class="number">33</span>,ip-<span class="number">172</span>-<span class="number">30</span>-<span class="number">0</span>-<span class="number">38</span>,root,localhost,<span class="number">29</span>,<span class="number">913</span>,<span class="keyword">READ</span>,company,org_departments,</span><br><span class="line"><span class="symbol">20170817 </span><span class="number">16</span>:<span class="number">04</span>:<span class="number">33</span>,ip-<span class="number">172</span>-<span class="number">30</span>-<span class="number">0</span>-<span class="number">38</span>,root,localhost,<span class="number">29</span>,<span class="number">913</span>,QUERY,company,</span><br><span class="line"><span class="comment">&#x27;SELECT * FROM employee_pay WHERE title LIKE \&#x27;%Executive%\&#x27; OR title LIKE \&#x27;%Manager%\&#x27;&#x27;,0</span></span><br></pre></td></tr></table></figure><br>下面是在MySQL中执行查询操作产生的audit日志，由最后一条可以看出，并没有READ类型的操作日志。<br><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">20191020 </span><span class="number">10</span>:<span class="number">48</span>:<span class="number">09</span>,delta-mysql,root,localhost,<span class="number">3</span>,<span class="number">31</span>,QUERY,wordpress,<span class="comment">&#x27;SELECT * FROM wp_options WHERE option_name LIKE \&#x27;%Executive%\&#x27; OR title LIKE \&#x27;%Manager%\&#x27;&#x27;,1054</span></span><br><span class="line"><span class="symbol">20191020 </span><span class="number">10</span>:<span class="number">48</span>:<span class="number">19</span>,delta-mysql,root,localhost,<span class="number">3</span>,<span class="number">32</span>,QUERY,wordpress,<span class="comment">&#x27;SELECT * FROM wp_options WHERE option_name LIKE \&#x27;%Executive%\&#x27; OR option_name LIKE \&#x27;%Manager%\&#x27;&#x27;,0</span></span><br></pre></td></tr></table></figure><br>通过查询<a href="http://www.mysqldbaservices.com/2016/03/11/mysql-mariadb-audit-plugin-installation-and-configuration/">资料</a>，TABLE事件只支持MariaDB 5.5.31 以及更新的版本，MySQL Server不提供MariaDB Audit Plugin需要的信息来追踪TABLE事件。</p><h2 id="三、参考资料"><a href="#三、参考资料" class="headerlink" title="三、参考资料"></a>三、参考资料</h2><p><a href="https://mariadb.com/kb/en/library/mariadb-audit-plugin-log-settings/">MariaDB Audit Plugin 官方文档</a><br><a href="http://www.mysqldbaservices.com/2016/03/11/mysql-mariadb-audit-plugin-installation-and-configuration/">MYSQL-MARIADB AUDIT PLUGIN INSTALLATION AND CONFIGURATION</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、安装MariaDB-Audit-Plugin&quot;&gt;&lt;a href=&quot;#一、安装MariaDB-Audit-Plugin&quot; class=&quot;headerlink&quot; title=&quot;一、安装MariaDB Audit Plugin&quot;&gt;&lt;/a&gt;一、安装MariaDB Au</summary>
      
    
    
    
    <category term="部署" scheme="https://www.delta1037.cn/categories/%E9%83%A8%E7%BD%B2/"/>
    
    
    <category term="MySQL" scheme="https://www.delta1037.cn/tags/MySQL/"/>
    
    <category term="审计" scheme="https://www.delta1037.cn/tags/%E5%AE%A1%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>CentOS 6安装GitLab服务端</title>
    <link href="https://www.delta1037.cn/2019/Deploy/CentOS-6%E5%AE%89%E8%A3%85gitlab%E6%9C%8D%E5%8A%A1%E7%AB%AF/"/>
    <id>https://www.delta1037.cn/2019/Deploy/CentOS-6%E5%AE%89%E8%A3%85gitlab%E6%9C%8D%E5%8A%A1%E7%AB%AF/</id>
    <published>2019-10-18T07:58:34.000Z</published>
    <updated>2020-12-11T17:31:04.083Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、配置基础环境"><a href="#一、配置基础环境" class="headerlink" title="一、配置基础环境"></a>一、配置基础环境</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">yum install openssh-server</span><br><span class="line">yum install postfix</span><br><span class="line">service postfix start</span><br><span class="line">chkconfig postfix on</span><br></pre></td></tr></table></figure><h2 id="二、下载安装gitlab"><a href="#二、下载安装gitlab" class="headerlink" title="二、下载安装gitlab"></a>二、下载安装gitlab</h2><p>gitlab安装包下载地址：<br>centos 6系统的下载地址:<a href="https://mirrors.tuna.tsinghua.edu.cn/gitlab-ce/yum/el6">https://mirrors.tuna.tsinghua.edu.cn/gitlab-ce/yum/el6</a><br>centos 7系统的下载地址:<a href="https://mirrors.tuna.tsinghua.edu.cn/gitlab-ce/yum/el7">https://mirrors.tuna.tsinghua.edu.cn/gitlab-ce/yum/el7</a><br>安装：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -i gitlab-ce-9.5.9-ce.0.el6.x86_64.rpm</span><br></pre></td></tr></table></figure></p><h2 id="三、配置gitlab"><a href="#三、配置gitlab" class="headerlink" title="三、配置gitlab"></a>三、配置gitlab</h2><p>修改gitlab配置文件指定服务器ip和自定义端口，将external_url后面的值修改为<a href="http://ip:port（例如http://192.168.7.89:8010，如果不指定端口则是默认的端口80）">http://ip:port（例如http://192.168.7.89:8010，如果不指定端口则是默认的端口80）</a><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/gitlab/gitlab.rb</span><br></pre></td></tr></table></figure></p><p>如果服务端开启了防火墙，则需要开放相应的端口<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -I INPUT -p tcp --dport 8010 -j ACCEPT</span><br></pre></td></tr></table></figure></p><p>按照新的配置文件重新配置gitlab，并重新启动<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gitlab-ctl reconfigure</span><br><span class="line">gitlab-ctl restart</span><br></pre></td></tr></table></figure><br>查看gitlab运行状态<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">gitlab-ctl status</span><br><span class="line"></span><br><span class="line"><span class="comment"># 得到如下输出</span></span><br><span class="line">run: gitaly: (pid 10798) 24009s; run: <span class="built_in">log</span>: (pid 4490) 24327s</span><br><span class="line">run: gitlab-monitor: (pid 10820) 24009s; run: <span class="built_in">log</span>: (pid 5099) 24297s</span><br><span class="line">run: gitlab-workhorse: (pid 10824) 24008s; run: <span class="built_in">log</span>: (pid 4654) 24321s</span><br><span class="line">run: logrotate: (pid 24622) 2407s; run: <span class="built_in">log</span>: (pid 4894) 24309s</span><br><span class="line">run: nginx: (pid 10887) 24007s; run: <span class="built_in">log</span>: (pid 4803) 24315s</span><br><span class="line">run: node-exporter: (pid 10896) 24007s; run: <span class="built_in">log</span>: (pid 5007) 24303s</span><br><span class="line">run: postgres-exporter: (pid 10908) 24006s; run: <span class="built_in">log</span>: (pid 5383) 24279s</span><br><span class="line">run: postgresql: (pid 10918) 24006s; run: <span class="built_in">log</span>: (pid 3780) 24391s</span><br><span class="line">run: prometheus: (pid 10926) 24005s; run: <span class="built_in">log</span>: (pid 5271) 24285s</span><br><span class="line">run: redis: (pid 10943) 24005s; run: <span class="built_in">log</span>: (pid 3615) 24398s</span><br><span class="line">run: redis-exporter: (pid 10947) 24005s; run: <span class="built_in">log</span>: (pid 5181) 24291s</span><br><span class="line">run: sidekiq: (pid 10959) 24004s; run: <span class="built_in">log</span>: (pid 4393) 24333s</span><br><span class="line">run: unicorn: (pid 10987) 24003s; run: <span class="built_in">log</span>: (pid 4292) 24339s</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><h3 id="bug0-GLIBC-2-14’-not-found"><a href="#bug0-GLIBC-2-14’-not-found" class="headerlink" title="bug0:`GLIBC_2.14’ not found"></a>bug0:`GLIBC_2.14’ not found</h3><p>如果出现报错/lib64/libc.so.6: version `GLIBC_2.14’ not found，则需要升级glibc<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下载安装包</span></span><br><span class="line">wget http://ftp.gnu.org/gnu/glibc/glibc-2.14.tar.gz</span><br><span class="line">tar zxvf glibc-2.14.tar.gz</span><br><span class="line"><span class="built_in">cd</span> glibc-2.14</span><br><span class="line">mkdir build</span><br><span class="line"><span class="built_in">cd</span> build</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译安装</span></span><br><span class="line">../configure --prefix=/opt/glibc-2.14</span><br><span class="line">make -j4</span><br><span class="line">make install</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置链接库目录</span></span><br><span class="line"><span class="built_in">export</span> LD_LIBRARY_PATH=/opt/glibc-2.14/lib</span><br></pre></td></tr></table></figure></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、配置基础环境&quot;&gt;&lt;a href=&quot;#一、配置基础环境&quot; class=&quot;headerlink&quot; title=&quot;一、配置基础环境&quot;&gt;&lt;/a&gt;一、配置基础环境&lt;/h2&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td cla</summary>
      
    
    
    
    <category term="部署" scheme="https://www.delta1037.cn/categories/%E9%83%A8%E7%BD%B2/"/>
    
    
    <category term="GitLab" scheme="https://www.delta1037.cn/tags/GitLab/"/>
    
  </entry>
  
  <entry>
    <title>Install Oracle Database 9i on CentOS 5 (i386)</title>
    <link href="https://www.delta1037.cn/2019/Deploy/Install-Oracle-Database-9i-on-CentOS-5-i386/"/>
    <id>https://www.delta1037.cn/2019/Deploy/Install-Oracle-Database-9i-on-CentOS-5-i386/</id>
    <published>2019-10-14T03:17:38.000Z</published>
    <updated>2020-12-11T17:31:03.224Z</updated>
    
    <content type="html"><![CDATA[<p>Oracle Database 9i的官方安装环境为RHEL3，RHEL4。由于项目需要，需要同时安装Oracle Database 9i和日志采集工具rsyslog，rsyslog仅支持RHEL/CENTOS 5及其以上的版本，最终在<a href="http://archive.kernel.org/centos-vault/5.0/isos/i386/">CentOS 5 (i386)</a>版本上安装成功。</p><h2 id="一、软件下载："><a href="#一、软件下载：" class="headerlink" title="一、软件下载："></a>一、软件下载：</h2><ol><li>Oracle9i Database Release 2 Enterprise/Standard Edition for Intel Linux（ship_9204_linux_disk）：<a href="http://stararly.com/DataBase/3432.html">迅雷</a> <a href="https://pan.baidu.com/s/1cqR1YYu9aBGxq1Kq4AtNvA">百度网盘提取码：ve9y</a></li><li><p>补丁：</p></li><li><p><a href="http://oss.oracle.com/projects/compat-oracle/dist/files/RedHat/compat-libcwait-2.1-1.i386.rpm">compat-libcwait-2.1-1.i386.rpm</a></p></li><li><p><a href="http://oss.oracle.com/projects/compat-oracle/dist/files/RedHat/compat-oracle-rhel4-1.0-5.i386.rpm">compat-oracle-rhel4-1.0-5.i386.rpm</a></p></li><li><p><a href="https://www.oracle.com/java/technologies/java-archive-javase-v13-downloads.html">j2re-1_3_1_19-linux-i586.bin</a></p></li></ol><h2 id="二、开始安装"><a href="#二、开始安装" class="headerlink" title="二、开始安装"></a>二、开始安装</h2><h3 id="1、关闭SELinux"><a href="#1、关闭SELinux" class="headerlink" title="1、关闭SELinux"></a>1、关闭SELinux</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gedit /etc/selinux/config</span><br><span class="line"><span class="built_in">set</span> SELINUX=disabled</span><br></pre></td></tr></table></figure><h3 id="2、-安装JRE"><a href="#2、-安装JRE" class="headerlink" title="2、 安装JRE"></a>2、 安装JRE</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">chmod +x j2re-1_3_1_19-linux-i586.bin</span><br><span class="line">./j2re-1_3_1_19-linux-i586.bin</span><br><span class="line">mv jre1.3.1_19 /usr/<span class="built_in">local</span>/</span><br></pre></td></tr></table></figure><h3 id="3、安装缺少的依赖"><a href="#3、安装缺少的依赖" class="headerlink" title="3、安装缺少的依赖"></a>3、安装缺少的依赖</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 检查依赖缺失</span></span><br><span class="line">rpm -q compat-db compat-gcc-34 compat-gcc-34-c++ \</span><br><span class="line">  compat-libgcc-296 compat-libstdc++-296 compat-libstdc++-33 \</span><br><span class="line">  gcc gcc-c++ glibc glibc-common glibc-devel glibc-headers libgcc make libXp</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用yum安装依赖</span></span><br><span class="line">yum install compat-db*</span><br><span class="line">yum install compat-gcc*</span><br><span class="line">yum install gcc*</span><br><span class="line">yum install compat-libgcc*</span><br><span class="line">yum install compat-libstdc++*</span><br><span class="line">yum install gnome-libs*</span><br><span class="line">yum install libaio*</span><br><span class="line">yum install openmotif*</span><br><span class="line">yum install xorg-x11-deprecated-libs*</span><br><span class="line">yum install glibc-devel*</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装补丁</span></span><br><span class="line">rpm -Uvh compat-libcwait-2.1-1.i386.rpm</span><br><span class="line">rpm -Uvh compat-oracle-rhel4-1.0-5.i386.rpm --nodeps</span><br></pre></td></tr></table></figure><h3 id="4、配置环境"><a href="#4、配置环境" class="headerlink" title="4、配置环境"></a>4、配置环境</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/lib</span><br><span class="line">ln -s libstdc++-3-libc6.2-2-2.10.0.so libstdc++-libc6.1-1.so.2</span><br><span class="line">ln -s libgdbm.so.2.0.0 libdb.so.2</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> /usr/bin</span><br><span class="line">ln -s gcc34 gcc32</span><br></pre></td></tr></table></figure><h3 id="5、添加oracle组和用户"><a href="#5、添加oracle组和用户" class="headerlink" title="5、添加oracle组和用户"></a>5、添加oracle组和用户</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">groupadd oinstall <span class="comment">#添加oinstall组</span></span><br><span class="line">groupadd dba <span class="comment"># 添加dba组</span></span><br><span class="line">useradd -g oinstall -G dba oracle <span class="comment">#新建用户并添加到组</span></span><br><span class="line">passwd oracle <span class="comment">#按照输出设置密码</span></span><br></pre></td></tr></table></figure><h3 id="6、建立安装目录"><a href="#6、建立安装目录" class="headerlink" title="6、建立安装目录"></a>6、建立安装目录</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /opt</span><br><span class="line">mkdir oracle <span class="comment"># 创建oracle目录</span></span><br><span class="line">chown –R oracle.oinstall oracle <span class="comment">#修改oracle目录权限</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> oracle</span><br><span class="line">mkdir 920 <span class="comment"># 创建9i安装目录</span></span><br></pre></td></tr></table></figure><h3 id="7、-配置环境变量和系统设置"><a href="#7、-配置环境变量和系统设置" class="headerlink" title="7、 配置环境变量和系统设置"></a>7、 配置环境变量和系统设置</h3><p>以oracle用户登陆，打开/u01/oracle/.bash_profile，在文件末尾追加如下内容<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ORACLE_BASE=/opt/oracle; <span class="built_in">export</span> ORACLE_BASE</span><br><span class="line">ORACLE_HOME=<span class="variable">$ORACLE_BASE</span>/920; <span class="built_in">export</span> ORACLE_HOME</span><br><span class="line">ORACLE_SID=orcl; <span class="built_in">export</span> ORACLE_SID</span><br><span class="line">LD_LIBRARY_PATH=<span class="variable">$ORACLE_HOME</span>/lib; <span class="built_in">export</span> LD_LIBRARY_PATH</span><br><span class="line">ORACLE_OEM_JAVARUNTIME=/usr/<span class="built_in">local</span>/jre1.3.1_19; <span class="built_in">export</span> ORACLE_OEM_JAVARUNTIME</span><br><span class="line">PATH=<span class="variable">$PATH</span>:<span class="variable">$ORACLE_HOME</span>/bin; <span class="built_in">export</span> PATH</span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$USER</span> = <span class="string">&quot;oracle&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">  <span class="keyword">if</span> [ <span class="variable">$SHELL</span> = <span class="string">&quot;/bin/ksh&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">ulimit</span> -p 16384</span><br><span class="line">    <span class="built_in">ulimit</span> -n 65536</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">ulimit</span> -u 16384 -n 65536</span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><br>以root用户登陆，打开/etc/sysctl.conf，在文件末尾追加如下内容，并执行sysctl -p生效<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">kernel.shmmni = 4096</span><br><span class="line">kernel.sem = 250 32000 100 128</span><br><span class="line">fs.file-max = 65536</span><br><span class="line">net.ipv4.ip_local_port_range = 1024 65000</span><br><span class="line">net.core.rmem_default=262144</span><br><span class="line">net.core.wmem_default=262144</span><br><span class="line">net.core.rmem_max=262144</span><br><span class="line">net.core.wmem_max=262144</span><br></pre></td></tr></table></figure></p><p>打开/etc/security/limits.conf，在文件末尾追加如下内容<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">oracle soft nofile 65536</span><br><span class="line">oracle hard nofile 65536</span><br><span class="line">oracle soft nproc 16384</span><br><span class="line">oracle hard nproc 16384</span><br></pre></td></tr></table></figure></p><h3 id="8、文件准备"><a href="#8、文件准备" class="headerlink" title="8、文件准备"></a>8、文件准备</h3><p>a）从网上下载oracle Database 9i有三个文件<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ship_9204_linux_disk1.cpio.gz</span><br><span class="line">ship_9204_linux_disk2.cpio.gz</span><br><span class="line">ship_9204_linux_disk3.cpio.gz</span><br></pre></td></tr></table></figure></p><p>b）对压缩文件解压<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gunzip ship_9204_linux_disk1.cpio.gz</span><br><span class="line">gunzip ship_9204_linux_disk2.cpio.gz</span><br><span class="line">gunzip ship_9204_linux_disk3.cpio.gz</span><br></pre></td></tr></table></figure></p><p>c）使用如下命令解压得到Disk1、Disk2和Disk3文件夹<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cpio -idmv &lt; ship_9204_linux_disk1.cpio</span><br><span class="line">cpio -idmv &lt; ship_9204_linux_disk2.cpio</span><br><span class="line">cpio -idmv &lt; ship_9204_linux_disk3.cpio</span><br></pre></td></tr></table></figure></p><h3 id="9、-开始安装"><a href="#9、-开始安装" class="headerlink" title="9、 开始安装"></a>9、 开始安装</h3><p>进入Disk1目录，执行./ runInstaller开始图形界面的安装程序，选择自己喜欢的版本进行安装，一路next就可以</p><h4 id="备注："><a href="#备注：" class="headerlink" title="备注："></a>备注：</h4><p>1、终端界面可能出现Inside isCluster, bCluster bfr return is : false，不影响后续使用<br>2、在最后的configuration阶段会发生错误如下</p><p><img src="https://delta1037.oss-cn-beijing.aliyuncs.com/hexo-blog/centos5_install_oracle_9i/centos5_install_oracle_9i.png" alt=""></p><p>此时退出安装程序，进行如下操作</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> <span class="variable">$ORACLE_HOME</span></span><br><span class="line">rm JRE</span><br><span class="line">ln -s <span class="variable">$ORACLE_BASE</span>/jre/1.3.1 JRE</span><br><span class="line"><span class="built_in">cd</span> JRE/bin</span><br><span class="line">ln -s java jre</span><br><span class="line"><span class="built_in">cd</span> i386/native_threads/</span><br><span class="line">ln -s java jre</span><br></pre></td></tr></table></figure><p>然后再执行./ runInstaller走一遍安装流程即可</p><h2 id="三、使用"><a href="#三、使用" class="headerlink" title="三、使用"></a>三、使用</h2><h3 id="1、建立数据库"><a href="#1、建立数据库" class="headerlink" title="1、建立数据库"></a>1、建立数据库</h3><p>进入/u01/oracle/product/bin目录，运行dbca命令，进入建立数据库的图形界面，根据界面提示进行操作</p><h3 id="2、使用过程中可能会遇到的问题"><a href="#2、使用过程中可能会遇到的问题" class="headerlink" title="2、使用过程中可能会遇到的问题"></a>2、使用过程中可能会遇到的问题</h3><p>a）startup 出现LRM-00109: could not open parameter file …：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /opt/oracle /admin/sxf/pfile <span class="comment">#sxf是dbca新建的数据库名</span></span><br><span class="line">cp init.ora.* /opt/oracle/920/dbs/initmyoracle.ora</span><br></pre></td></tr></table></figure></p><p>b）startup出现ORA-01990: error opening password file ‘/opt/oracle/920/dbs/orapw’<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /opt/oracle/920/bin</span><br><span class="line">orapwd file=/opt/oracle/920/dbs/orapw passwd=sxf123 entries=1024</span><br></pre></td></tr></table></figure></p><h2 id="四、个人经验"><a href="#四、个人经验" class="headerlink" title="四、个人经验"></a>四、个人经验</h2><p>1、以CentOS 5（x86_64）无法完成amd64_db_9204_Disk1.cpio.gz的安装<br>2、以CentOS 4（x86_64）可以完成amd64_db_9204_Disk1.cpio.gz的安装</p><h2 id="五、参考文献"><a href="#五、参考文献" class="headerlink" title="五、参考文献"></a>五、参考文献</h2><p>1、<a href="http://nirajkvinit.blogspot.com/2008/10/installing-oracle-9i-on-rhel5.html">Installing Oracle 9i on RHEL5. (x86)</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Oracle Database 9i的官方安装环境为RHEL3，RHEL4。由于项目需要，需要同时安装Oracle Database 9i和日志采集工具rsyslog，rsyslog仅支持RHEL/CENTOS 5及其以上的版本，最终在&lt;a href=&quot;http://arc</summary>
      
    
    
    
    <category term="部署" scheme="https://www.delta1037.cn/categories/%E9%83%A8%E7%BD%B2/"/>
    
    
    <category term="Oracle Database 9i" scheme="https://www.delta1037.cn/tags/Oracle-Database-9i/"/>
    
  </entry>
  
  <entry>
    <title>Linux启动过程分析</title>
    <link href="https://www.delta1037.cn/2019/Linux/Linux%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/"/>
    <id>https://www.delta1037.cn/2019/Linux/Linux%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/</id>
    <published>2019-10-14T03:09:25.000Z</published>
    <updated>2020-12-11T17:31:06.629Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第一阶段-BIOS"><a href="#第一阶段-BIOS" class="headerlink" title="第一阶段-BIOS"></a>第一阶段-BIOS</h2><p>计算机通电后，首先会区读取ROM芯片中的开机程序（基本输入输出系统/BIOS）</p><h3 id="1-1-硬件自检"><a href="#1-1-硬件自检" class="headerlink" title="1.1 硬件自检"></a>1.1 硬件自检</h3><p>BIOS程序首先检查计算机硬件是否满足运行的基本条件—<strong>硬件自检</strong>（POST）</p><p>CMOS：存储硬件的各项参数。</p><h3 id="1-2-启动顺序"><a href="#1-2-启动顺序" class="headerlink" title="1.2 启动顺序"></a>1.2 启动顺序</h3><p>硬件自检完成后，BIOS把控制权交给下一阶段的启动程序。</p><p>这时，BIOS需要知道下一阶段的启动程序在哪个设备，也就是BIOS需要有一个外部存储设备排序，排在前边的设备就是优先转交控制权的设备。这个排序叫<strong>启动顺序</strong>。</p><h2 id="第二阶段-主引导记录"><a href="#第二阶段-主引导记录" class="headerlink" title="第二阶段-主引导记录"></a>第二阶段-主引导记录</h2><p>BIOS把控制权交给排在第一位的存储设备。</p><p>计算机读取此设备的第一个扇区（最前边的512个字节，叫做<strong>主引导记录</strong><Master boot record，缩写为**MBR**>），如果这个扇区最后两个字节是0x55和0xAA，表明设备可以启动；如果不是，表明设备不能启动，控制权交给启动顺序中的下一个 设备。</p><h3 id="2-1-主引导记录结构"><a href="#2-1-主引导记录结构" class="headerlink" title="2.1 主引导记录结构"></a>2.1 主引导记录结构</h3><div class="table-container"><table><thead><tr><th>范围/字节</th><th>作用</th></tr></thead><tbody><tr><td>1-446</td><td>调用操作系统的机器码</td></tr><tr><td>447-510</td><td>分区表：将磁盘分为若干个区</td></tr><tr><td>511-512</td><td>主引导记录签名</td></tr></tbody></table></div><h3 id="2-2-分区表"><a href="#2-2-分区表" class="headerlink" title="2.2 分区表"></a>2.2 分区表</h3><p>考虑到每个区可以安装不同的操作系统，主引导记录必须知道将控制权交给哪个区。</p><p>分区表长度有64个字节，里面分为四项（所以一个硬盘最多有四个一级分区，又叫主分区），每一项16个字节</p><p>主分区16个字节组成：</p><div class="table-container"><table><thead><tr><th>范围/字节</th><th>作用</th></tr></thead><tbody><tr><td>1-1</td><td>如果为0x80，就表示该分区是激活分区，控制权要交给这个分区。四个分区里面只能有一个是激活的</td></tr><tr><td>2-4</td><td>主分区第一个扇区的物理位置（柱面、磁头、扇区号）</td></tr><tr><td>5-5</td><td>主分区类型</td></tr><tr><td>6-8</td><td>主分区最后一个扇区的物理位置</td></tr><tr><td>9-12</td><td>该主分区第一个扇区的逻辑地址</td></tr><tr><td>13-16</td><td>主分区的扇区总数</td></tr></tbody></table></div><h2 id="第三阶段-硬盘启动"><a href="#第三阶段-硬盘启动" class="headerlink" title="第三阶段-硬盘启动"></a>第三阶段-硬盘启动</h2><p>这时，计算机的控制权就交给了硬盘的某个分区了</p><h3 id="3-1-情况A：卷引导记录"><a href="#3-1-情况A：卷引导记录" class="headerlink" title="3.1 情况A：卷引导记录"></a>3.1 情况A：卷引导记录</h3><p>计算机会读取激活分区的第一个扇区，叫做卷引导记录（Volume boot record，VBR）</p><p>卷引导记录告诉计算机，操作系统在这个分区的位置。然后计算机就会加载操作系统了。</p><h3 id="3-2-情况B：扩展分区和逻辑分区"><a href="#3-2-情况B：扩展分区和逻辑分区" class="headerlink" title="3.2 情况B：扩展分区和逻辑分区"></a>3.2 情况B：扩展分区和逻辑分区</h3><p>随着硬盘越来越大，四个分区已经不够了，需要更多分区。于是规定有一个分区可以定义为扩展分区（里面又分了好多个区，叫逻辑分区）。</p><p>计算机首先读取扩展分区的第一个扇区，叫扩展引导记录（EBR）。它里面包含一张64字节的分区表，但是最多只有两项（也就是两个逻辑分区，包括它自身的分区表和下一个分区的分区表）。从里面找到第二个逻辑分区的位置，直到找到一个分区里面只包含它自己的分区表为止。</p><h3 id="3-3-情况C：启动管理器"><a href="#3-3-情况C：启动管理器" class="headerlink" title="3.3 情况C：启动管理器"></a>3.3 情况C：启动管理器</h3><p>在这种情况下，计算机读取主引导记录前446个字节的机器码之后，不把控制权交给某一个分区，而是运行启动管理器（boot loader），由用户选择启动哪一个操作系统。</p><p>Linux环境中，最流行的启动管理器是Grub。</p><h2 id="第四阶段-操作系统"><a href="#第四阶段-操作系统" class="headerlink" title="第四阶段-操作系统"></a>第四阶段-操作系统</h2><p>控制权交给操作系统之后，操作系统的内核首先载入内存。</p><p>所有进程的祖先叫进程0，idle进程，或者由于历史的原因叫做swapper进程。</p><p>start_kernel()函数初始化内核需要的所有数据结构，激活终端，创建另一个叫做进程1的内核线程（一般叫做init进程），创建init进程之后，进程0执行cpu_idle()函数，该函数本质上是在开中断的情况下重复之星hlt汇编指令。当 没有其他进程处于TASK_RUNNING才选择执行进程0。</p><p><strong>多处理器系统</strong>中每个CPU都有一个进程0，计算机启动之后首先启动一个CPU，禁用其他CPU，swapper进程进程初始化内核数据结构，通过copy_process()函数创建另外的swapper进程。</p><p>进程0创建的内核线程执行init()函数，init()依次完成内核初始化。init()调用execve()系统调用装入可执行程序init，结果init内核线程变成了一个普通进程。</p><p>以Linux系统为例，首先载入/boot目录下面的kernel。内核加载成功后（如上），第一个运行的程序是/sbin/init，它根据配置文件产生init进程，pid进程编号为1，其它进程都是它的后代。</p><p>然后init进程加载系统的各个模块，比如窗口和网络程序，直到/bin/login程序，跳出登录页面。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="http://www.ruanyifeng.com/blog/2013/02/booting.html">计算机是如何启动的</a></li><li>深入理解Linux内核</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;第一阶段-BIOS&quot;&gt;&lt;a href=&quot;#第一阶段-BIOS&quot; class=&quot;headerlink&quot; title=&quot;第一阶段-BIOS&quot;&gt;&lt;/a&gt;第一阶段-BIOS&lt;/h2&gt;&lt;p&gt;计算机通电后，首先会区读取ROM芯片中的开机程序（基本输入输出系统/BIOS）&lt;/p</summary>
      
    
    
    
    <category term="Linux" scheme="https://www.delta1037.cn/categories/Linux/"/>
    
    
    <category term="Linux小系统" scheme="https://www.delta1037.cn/tags/Linux%E5%B0%8F%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>点石成金，挥刀琢玉——“双创老太”刘玉那些事儿</title>
    <link href="https://www.delta1037.cn/2019/DianGroup/%E8%8B%B1%E9%9B%84%E4%BC%9A%E5%88%98%E8%80%81%E5%B8%88%E4%BB%8B%E7%BB%8D/"/>
    <id>https://www.delta1037.cn/2019/DianGroup/%E8%8B%B1%E9%9B%84%E4%BC%9A%E5%88%98%E8%80%81%E5%B8%88%E4%BB%8B%E7%BB%8D/</id>
    <published>2019-08-21T11:14:55.000Z</published>
    <updated>2020-12-11T17:31:04.449Z</updated>
    
    <content type="html"><![CDATA[<h1 id="点石成金，挥刀琢玉——“双创老太”刘玉那些事儿"><a href="#点石成金，挥刀琢玉——“双创老太”刘玉那些事儿" class="headerlink" title="点石成金，挥刀琢玉——“双创老太”刘玉那些事儿"></a>点石成金，挥刀琢玉——“双创老太”刘玉那些事儿</h1><p>   高调、爱折腾、不走寻常路、犀利、“毒舌”、超级大忙人，她是被贴满标签的华中大教授——刘玉老师。而其中最响亮，最广为人知的标签，一定非“双创老太”莫属。今天，让我们走近这神秘的刘玉教授，说一说，她的那些事儿——</p><p><span style="font-size:20px;color:white;background-color: red;font-weight:bold;">她是谁——</span></p><ul><li>湖北省创业红娘众创空间        负责人</li><li>武汉创业红娘公益服务中心     理事长</li><li>华中科技大学    电信学院      教   授</li><li>华中科技大学    Dian团队      创始人</li></ul><hr><p><span style="font-size:20px;color:white;background-color: red;font-weight:bold;">她都做过什么——</span></p><p><span style="font-size:16px;color:red;font-weight:bold;">扶弟子创新</span></p><p>   曾指导本科生获全国挑战杯特等奖，Dian团队育人模式获国家教学成果二等奖，教育部大学生创新性实验计划的“源头”之一，央视小崔说事栏目曾以“点亮未来”专题报道，曾应邀到全国高校、中学、企事业等逾百家单位作创新创业报告，引起强烈反响。曾获评“全国师德先进个人”和湖北省“五一劳动奖章”、湖北省教育系统“三育人”奖、 宝钢优秀教师特等奖的提名奖、两次获华中科技大学教学质量优秀一等奖。<br>     在她严格要求和精心培养下，Dian团队出站队员500多人在社会上总体表现优异，近7年涌现出50余家创业公司，其中贝贝网和贝店已成为独角兽，释码大华、ping++、悦然心动等创业公司业绩斐然，4人荣登福布斯中国30位“30岁以下创业者”榜单。</p><p><span style="font-size:16px;color:red;font-weight:bold;">帮他人创业</span></p><p>  2015年3月，刘玉创办“武汉市洪山区创业红娘公益服务中心”，义务为优秀创业项目与投资机构牵线搭桥，创业项目的甄选范围从华中科技大学在校生拓宽至全社会，不分地域、不分年龄、不分学校、不分学历。至今，经刘玉老师推荐的创业项目已超过500个，融资成交率13.2%，促成投资总额2.57亿元。</p><hr><p><span style="font-size:20px;color:white;background-color: red;font-weight:bold;">她的那些事儿——</span></p><ul><li><a href="http://szbold.cjn.cn/cjrb/html/2015-12/25/content_5498033.htm"><span style="color:red;font-size:18px;">刘玉:创客点睛手——《长江日报》</span></a></li></ul><ul><li><a href="https://www.chsi.com.cn/jyzx/200711/20071108/1493323.html"><span style="color:orange;font-size:18px;">创新潜能在实践中尽情释放——《中国教育报》网络版</span></a></li></ul><ul><li><a href="http://hb.people.com.cn/n2/2016/0115/c337099-27552249.html"><span style="color:red;font-size:18px;">人民网专访“创业红娘”刘玉：如何做到人靠谱、事落实、有情怀</span></a></li></ul><ul><li><a href="http://zqb.cyol.com/html/2016-01/19/nw.D110000zgqnb_20160119_2-10.htm"><span style="color:orange;font-size:18px;">刘玉：被“强推转身”的创业红娘——《中国青年报》</span></a></li></ul><ul><li><a href="http://cjrb.cjn.cn/html/2018-04/04/content_67430.htm"><span style="color:red;font-size:18px;">全国布撒“姻缘线”的“创业红娘” ——武汉首个创业服务公益机构实录——《长江日报》</span></a></li></ul><ul><li><a href="http://news.cnhubei.com/xw//sh/201604/t3592740.shtml"><span style="color:orange;font-size:18px;">武汉女教授入选“中国好人” 免费孵出50多家公司——荆楚网</span></a></li></ul><ul><li><a href="http://hb.people.com.cn/n2/2017/0526/c337099-30246043.html"><span style="color:red;font-size:18px;">华科Dian团队15年走出10余家“过亿”企业——人民网</span></a></li></ul><ul><li><a href="http://cppcc.people.com.cn/GB/35377/11493611.html"><span style="color:orange;font-size:18px;">崔永元“说事”设“圈套” 女教授均“化险为夷”——中国政协新闻网</span> </a></li></ul><ul><li><a href="http://www.cnki.com.cn/Article/CJFDTotal-DYXS201409005.htm"><span style="color:red;font-size:18px;">“点”下种子——访谈华中科技大学“点团队”创始人刘玉教授——《大学生》</span></a></li></ul><ul><li><a href="https://www.chsi.com.cn/jyzx/200711/20071108/1493323.html"><span style="color:orange;font-size:18px;">华科创客点睛手刘玉讲述：张小龙在武汉首提微信产品观——荆楚网</span></a></li></ul><ul><li><a href="http://hustxb.cuepa.cn/show_more.php?tkey=&amp;bkey=&amp;doc_id=235846"><span style="color:red;font-size:18px;">刘延东寄语Dian团队———在实践中释放创新潜能</span></a></li></ul><ul><li><a href="http://zqb.cyol.com/html/2014-06/26/nw.D110000zgqnb_20140626_3-07.htm"><span style="color:orange;font-size:18px;">华中科大教授刘玉：人才标准固化扼杀大学生创新热情——《中国青年报》</span></a></li></ul><ul><li><a href="http://archive.wenming.cn/jddzhr/2010-04/02/content_19412216_2.htm"><span style="color:red;font-size:18px;">华中科技大学刘玉教授：未来工程师“点”亮江城 </span></a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;点石成金，挥刀琢玉——“双创老太”刘玉那些事儿&quot;&gt;&lt;a href=&quot;#点石成金，挥刀琢玉——“双创老太”刘玉那些事儿&quot; class=&quot;headerlink&quot; title=&quot;点石成金，挥刀琢玉——“双创老太”刘玉那些事儿&quot;&gt;&lt;/a&gt;点石成金，挥刀琢玉——“双创老太”</summary>
      
    
    
    
    <category term="Dian团队" scheme="https://www.delta1037.cn/categories/Dian%E5%9B%A2%E9%98%9F/"/>
    
    
  </entry>
  
  <entry>
    <title>编译总结</title>
    <link href="https://www.delta1037.cn/2019/C_C++/compile/"/>
    <id>https://www.delta1037.cn/2019/C_C++/compile/</id>
    <published>2019-08-03T11:16:31.000Z</published>
    <updated>2020-12-11T17:31:00.138Z</updated>
    
    <content type="html"><![CDATA[<h1 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h1><h2 id="一、系统环境"><a href="#一、系统环境" class="headerlink" title="一、系统环境"></a>一、系统环境</h2><ul><li><p>CPU：Intel(R) Core(TM) i5-5200U CPU @ 2.20GHz</p></li><li><p>操作系统：Ubuntu 18.04.2 LTS</p></li><li>内核版本：Linux version 4.18.0-25-generic</li><li>GNU GCC版本：gcc version 7.4.0 (Ubuntu 7.4.0-1ubuntu1~18.04.1)<ul><li>C standard revision：C11</li><li><strong>GNU Compiled BY</strong><ul><li>GMP version： 6.1.2</li><li>MPFR version ：4.0.1</li><li>MPC version ： 1.1.0</li><li>isl version ： isl-0.19-GMP</li></ul></li></ul></li><li><p>GNU 汇编器版本：2.30 (x86_64-linux-gnu) using BFD version (GNU Binutils for Ubuntu) 2.30</p></li><li><p>链接器版本：</p><ul><li><a href="https://gcc.gnu.org/onlinedocs/gccint/Collect2.html">collect2</a> version：7.4.0<ul><li>gcc一般是collect2,而不是ld，collect2 是ld链接器的一个封装，最终还是调用ld来完成链接工作</li><li>collect2通过<strong>第一次链接</strong>程序查看链接器输出文件来查找具有特定名称表明是构造函数的符号，如果找得到则会创建一个新的临时‘.c’文件包含这些符号，然后编译这个文件并<strong>第二次链接</strong>程序.The program collect2 works by linking the program once and looking through the linker output file for symbols with particular names indicating they are constructor functions. If it finds any, it creates a new temporary ‘.c’ file containing a table of them, compiles it, and links the program a second time including that file.）</li></ul></li><li>GNU ld (GNU Binutils for Ubuntu)：2.30</li></ul></li></ul><h2 id="二、GCC编译过程"><a href="#二、GCC编译过程" class="headerlink" title="二、GCC编译过程"></a>二、GCC编译过程</h2><h3 id="2-1-GCC编译过程"><a href="#2-1-GCC编译过程" class="headerlink" title="2.1 GCC编译过程"></a>2.1 GCC编译过程</h3><p><img src="https://delta1037.oss-cn-beijing.aliyuncs.com/hexo-blog/Compile/编译过程-简单.png" alt="编译过程-简单"></p><ol><li><p>预处理</p><ul><li>删除所有的#define，展开所有的宏定义</li><li>处理所有的条件预编译指令&lt;#if,#endif,#ifdef,#ifndef,#elif,#else&gt;</li><li>处理#include预编译指令，将包含的文件插入到include的位置（递归进行）</li><li>删除所有的注释</li><li>添加行号和文件名标识（调试时使用）</li><li>保留所有的#pragma编译器指令（编译器需要使用这些指令）</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 单独产生预处理后的文件（本模块假设hello.c是源代码程序,hello.i是hello.c预处理后的文件,hello.s是hello.c编译后的文件，hello.o是hello.c汇编后的文件，hello是hello.c最终的可执行程序）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用gcc命令产生预处理文件</span></span><br><span class="line">$ gcc -E hello.c -o hello.i</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用cpp命令产生预处理文件</span></span><br><span class="line">$ cpp hello.c &gt; hello.i</span><br></pre></td></tr></table></figure></li><li><p>编译：将预处理完的文件进行一系列的词法分析、语法分析、语义分析、中间代码生成、目标代码生成与优化之后产生相应的汇编代码文件</p><ul><li>词法分析：扫描器运行类似于有限状态机的算法将代码的字符序列分割成一系列的记号</li><li>语法分析：语法分析器对扫描器产生的记号进行语法分析，从而产生语法树（以表达式为节点的树）</li><li>语义分析：语义分析器确定语句的意义（比如两个指针做乘法是没有意义的），编译器只能分析静态语义（在编译时能够确定的语义，通常包括声明和类型的匹配，类型的转换；与之相对的动态语义是在运行时才能确定的语义，例如将0作为除数是一个运行期语义错误）</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 编译预处理后的文件产生汇编代码文件</span></span><br><span class="line">$ gcc -S hello.i -o hello.s</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译源文件产生汇编代码文件</span></span><br><span class="line">$ gcc -S hello.c -o hello.s</span><br><span class="line"></span><br><span class="line"><span class="comment"># 现在的gcc编译器将预处理和编译两个步骤合成了一个步骤，使用一个叫cc1的程序来完成这个过程</span></span><br><span class="line">$ /usr/lib/gcc/x86_64-linux-gnu/7/cc1 hello.c -o hello.s</span><br></pre></td></tr></table></figure></li><li><p>汇编：将汇编代码转变成机器可以执行的指令（根据汇编指令和机器指令的对照表一一翻译）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用as处理汇编文件产生目标文件</span></span><br><span class="line">$ as hello.s -o hello.o</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用gcc处理汇编文件产生目标文件</span></span><br><span class="line">$ gcc -c hello.s -o hello.o</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用gcc处理源文件产生目标文件</span></span><br><span class="line">$ gcc -c hello.c -o hello.o</span><br></pre></td></tr></table></figure></li><li><p>链接：将目标文件链接到一起形成可执行文件,主要包括地址和空间分配，符号决议，和重定位等步骤</p><ul><li><p>符号决议：也叫做符号绑定、名称绑定、名称决议等等。从细节上来讲，决议更倾向于静态链接，绑定更倾向与动态链接</p></li><li><p>重定位：编译一个文件时不知道一个要调用的函数或者需要操作的一个变量的地址，就会把这些调用函数或者操作变量的指令目标地址搁置，等到最后链接的时候由链接器去将这些指令的目标地址修正，这个地址修正的过程也被叫做<strong>重定位</strong>，每一个需要修正的地方叫做<strong>重定位入口</strong>。</p></li></ul></li></ol><h3 id="2-2-实际编译过程"><a href="#2-2-实际编译过程" class="headerlink" title="2.2 实际编译过程"></a>2.2 实际编译过程</h3><ol><li><p>使用如下样例，包含hello.c和func.c两个源文件（之后也是用这两个文件进行分析）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* hello.c：主测试程序，包括全局静态变量，局部静态变量，全局变量，局部变量，基本的函数调用 */</span></span><br><span class="line"><span class="comment">// export var</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> export_func_var;</span><br><span class="line"></span><br><span class="line"><span class="comment">// global var</span></span><br><span class="line"><span class="keyword">int</span> global_uninit_var;</span><br><span class="line"><span class="keyword">int</span> global_init_var_0 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> global_init_var_1 = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// const var</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *const_string_var = <span class="string">&quot;const string&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// static global var</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> static_global_uninit_var;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> static_global_init_var_0 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> static_global_init_var_1 = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// func header</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func_call_test</span><span class="params">(<span class="keyword">int</span> num)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="comment">// local var</span></span><br><span class="line">    <span class="keyword">int</span> local_uninit_var;</span><br><span class="line">    <span class="keyword">int</span> local_init_var_0 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> local_init_var_1 = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// static local var</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> static_local_uninit_var;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> static_local_init_var_0 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> static_local_init_var_1 = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// call func</span></span><br><span class="line">    func_call_test(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// export var op</span></span><br><span class="line">    export_func_var = export_func_var * <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* func.c：包含一个简单的被调用函数和一个全局变量 */</span></span><br><span class="line"><span class="keyword">int</span> export_func_var = <span class="number">666</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func_call_test</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> double_num = num * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用<code>gcc -v hello.c func.c</code>编译生成可执行文件a.out，产生如下输出（简化版本）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[delta@delta: code ]$ gcc -v func.c hello.c</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对func.c的预处理和编译过程</span></span><br><span class="line">/usr/lib/gcc/x86_64-linux-gnu/7/cc1 func.c -o /tmp/ccfC6J5E.s</span><br><span class="line"><span class="comment"># 对func.c产生的.s文件汇编产生二进制文件</span></span><br><span class="line">as -v --64 -o /tmp/ccF4Bar0.o /tmp/ccfC6J5E.s</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对hello.c的预处理和编译过程</span></span><br><span class="line">/usr/lib/gcc/x86_64-linux-gnu/7/cc1 hello.c -o /tmp/ccfC6J5E.s</span><br><span class="line"><span class="comment"># 对hello.c产生的.s文件汇编产生二进制文件</span></span><br><span class="line">as -v --64 -o /tmp/cc7UmhQl.o /tmp/ccfC6J5E.s</span><br><span class="line"></span><br><span class="line"><span class="comment"># 链接过程</span></span><br><span class="line">/usr/lib/gcc/x86_64-linux-gnu/7/collect2 -dynamic-linker ld-linux-x86-64.so.2 Scrt1.o crti.o crtbeginS.o /tmp/ccF4Bar0.o /tmp/cc7UmhQl.o crtendS.o crtn.o</span><br></pre></td></tr></table></figure></li></ol><h2 id="三、链接过程解析"><a href="#三、链接过程解析" class="headerlink" title="三、链接过程解析"></a>三、链接过程解析</h2><p><strong>Q:</strong></p><ul><li><p>目标文件的格式是怎样的？</p></li><li><p>多个目标是如何链接到一起的？</p></li></ul><h3 id="3-1-目标文件"><a href="#3-1-目标文件" class="headerlink" title="3.1 目标文件"></a>3.1 目标文件</h3><h4 id="3-1-1目标文件类型"><a href="#3-1-1目标文件类型" class="headerlink" title="3.1.1目标文件类型"></a>3.1.1目标文件类型</h4><ul><li>Window下的PE（Portable Executable）</li><li>Linux下的ELF（Executable Linkable Format）</li></ul><p><em>注：</em></p><ol><li><em>PE和ELF格式都是COFF（Common file format）格式的变种</em></li><li><em>目标文件与可执行文件的内容和结构类似，所以一般采用相同的格式存储。广义上来可以将目标文件和可执行文件看做是同一种类型的文件，在window下统称它们为PE-COFF文件格式，在Linux下统称它们为ELF文件。</em></li><li><em>不止是可执行文件按照可执行文件格式存储，动态链接库（DLL，Dynamic Linking Library）（Window的.dll和Linux的.so）以及静态链接库（Static Linking Library）（Window的.lib和Linux的.a）文件都按照可执行文件的格式存储。（静态链接库稍有不同，它是把很多的目标文件捆绑在一起形成一个文件，再加上一些索引。可以理解为一个包含很多目标文件的文件包）</em></li></ol><h4 id="3-1-2-ELF文件类型"><a href="#3-1-2-ELF文件类型" class="headerlink" title="3.1.2 ELF文件类型"></a>3.1.2 ELF文件类型</h4><div class="table-container"><table><thead><tr><th style="text-align:left">ELF文件类型</th><th style="text-align:left">说明</th><th>实例</th></tr></thead><tbody><tr><td style="text-align:left">可重定位文件（Relocatable File）</td><td style="text-align:left">包含代码和数据，可以被用来链接成可执行文件或者共享目标文件，静态链接库可以归为这一类</td><td>Linux的.o，Window下的.obj</td></tr><tr><td style="text-align:left">可执行文件（Executable File）</td><td style="text-align:left">包含可以直接执行的程序，一般没有扩展名</td><td>Linux的/bin/bash文件，Window的.exe</td></tr><tr><td style="text-align:left">共享目标文件（Shared Object File）</td><td style="text-align:left">包含代码和数据，链接器可以上映这种文件与其他可重定位文件和共享目标文件进行链接产生新的目标文件；动态链接器可以将几个共享目标文件与可执行文件结合，作为进程映像的一部分来运行</td><td>Linux的.so，Window的.dll</td></tr><tr><td style="text-align:left">核心转储文件（Core Dump File）</td><td style="text-align:left">进程意外终止时，系统将该进程的地址空间的内容以及终止时的其它信息转储到核心转储文件</td><td>Linux下的core dump</td></tr></tbody></table></div><h4 id="3-1-3目标文件结构"><a href="#3-1-3目标文件结构" class="headerlink" title="3.1.3目标文件结构"></a>3.1.3目标文件结构</h4><p>目标文件中包含编译后的指令代码、数据，还包括了链接时需要的一些信息（符号表，调试信息和字符串等），一般目标文件将这些信息按照不同的属性，以<strong>节（Section）</strong>的形式存储（有时也称为<strong>段（Segment)</strong>）。如下图所示</p><p><img src="https://delta1037.oss-cn-beijing.aliyuncs.com/hexo-blog/Compile/ELF结构.png" alt="ELF结构"></p><h5 id="3-1-3-1常见的段"><a href="#3-1-3-1常见的段" class="headerlink" title="3.1.3.1常见的段"></a>3.1.3.1<strong>常见的段</strong></h5><div class="table-container"><table><thead><tr><th style="text-align:left">段名</th><th>说明</th></tr></thead><tbody><tr><td style="text-align:left">.text/.code</td><td>代码段，编译后的机器指令</td></tr><tr><td style="text-align:left">.data</td><td>数据段，全局变量和局部静态变量</td></tr><tr><td style="text-align:left">.bss</td><td>未初始化的全局变量和局部静态变量（.bss段只是为未初始化的全局变量和局部静态变量预留位置）</td></tr><tr><td style="text-align:left">.rodata</td><td>只读信息段</td></tr><tr><td style="text-align:left">.rodata1</td><td>存放只读数据，字符串常量，全局const变量。与.rodata一样</td></tr><tr><td style="text-align:left">.comment</td><td>编译器版本信息</td></tr><tr><td style="text-align:left">.debug</td><td>调试信息</td></tr><tr><td style="text-align:left">.dynamic</td><td>动态链接信息</td></tr><tr><td style="text-align:left">.hash</td><td>符号哈希表</td></tr><tr><td style="text-align:left">.line</td><td>调试时的行号表，即源代码行号与编译后的指令的对应表</td></tr><tr><td style="text-align:left">.note</td><td>额外的编译器信息。程序的公司名，发布版本号</td></tr><tr><td style="text-align:left">.strtab</td><td>String Table，字符串表，用来存储ELF文件中用到的各种字符串</td></tr><tr><td style="text-align:left">.symtab</td><td>Symbol Table，符号表</td></tr><tr><td style="text-align:left">.shstrtab</td><td>Section String Table，段名表</td></tr><tr><td style="text-align:left">.plt/.got</td><td>动态链接的跳转表和全局入口表</td></tr><tr><td style="text-align:left">.init/.fini</td><td>程序初始化与终结代码段</td></tr></tbody></table></div><h5 id="3-1-3-2目标文件结构分析"><a href="#3-1-3-2目标文件结构分析" class="headerlink" title="3.1.3.2目标文件结构分析"></a>3.1.3.2目标文件结构分析</h5><ol><li><p>ELF文件头：</p><ul><li><p>使用<code>gcc -c hello.c -o hello.o</code>生成目标文件hello.o，并使用<code>readelf -h hello.o</code>读取目标文件的ELF文件头，可以看出ELF文件头定义了<strong>ELF魔数、文件机器字节长度、数据存储方式、版本，运行平台、ABI版本、ELF重定位类型、硬件平台、硬件平台版本、入口地址、程序入口和长度、段表的位置和长度及段的数量</strong>等，如下图所示</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">ELF Header:</span><br><span class="line">  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00</span><br><span class="line">  Class:                             ELF64</span><br><span class="line">  Data:                              2<span class="string">&#x27;s complement, little endian</span></span><br><span class="line"><span class="string">  Version:                           1 (current)</span></span><br><span class="line"><span class="string">  OS/ABI:                            UNIX - System V</span></span><br><span class="line"><span class="string">  ABI Version:                       0</span></span><br><span class="line"><span class="string">  Type:                              REL (Relocatable file)</span></span><br><span class="line"><span class="string">  Machine:                           Advanced Micro Devices X86-64</span></span><br><span class="line"><span class="string">  Version:                           0x1</span></span><br><span class="line"><span class="string">  Entry point address:               0x0</span></span><br><span class="line"><span class="string">  Start of program headers:          0 (bytes into file)</span></span><br><span class="line"><span class="string">  Start of section headers:          1328 (bytes into file)</span></span><br><span class="line"><span class="string">  Flags:                             0x0</span></span><br><span class="line"><span class="string">  Size of this header:               64 (bytes)</span></span><br><span class="line"><span class="string">  Size of program headers:           0 (bytes)</span></span><br><span class="line"><span class="string">  Number of program headers:         0</span></span><br><span class="line"><span class="string">  Size of section headers:           64 (bytes)</span></span><br><span class="line"><span class="string">  Number of section headers:         15</span></span><br><span class="line"><span class="string">  Section header string table index: 14</span></span><br></pre></td></tr></table></figure></li><li><p>ELF文件头结构体定义在/usr/include/elf.h中，目标文件hello.o的文件头中机器字节长度为ELF64，找到64位版本文件头结构体Elf64_Ehdr定义，如下所示</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span>e_ident[EI_NIDENT];<span class="comment">/* Magic number and other info */</span></span><br><span class="line">  Elf64_Halfe_type;<span class="comment">/* Object file type */</span></span><br><span class="line">  Elf64_Halfe_machine;<span class="comment">/* Architecture */</span></span><br><span class="line">  Elf64_Worde_version;<span class="comment">/* Object file version */</span></span><br><span class="line">  Elf64_Addre_entry;<span class="comment">/* Entry point virtual address */</span></span><br><span class="line">  Elf64_Offe_phoff;<span class="comment">/* Program header table file offset */</span></span><br><span class="line">  Elf64_Offe_shoff;<span class="comment">/* Section header table file offset */</span></span><br><span class="line">  Elf64_Worde_flags;<span class="comment">/* Processor-specific flags */</span></span><br><span class="line">  Elf64_Halfe_ehsize;<span class="comment">/* ELF header size in bytes */</span></span><br><span class="line">  Elf64_Halfe_phentsize;<span class="comment">/* Program header table entry size */</span></span><br><span class="line">  Elf64_Halfe_phnum;<span class="comment">/* Program header table entry count */</span></span><br><span class="line">  Elf64_Halfe_shentsize;<span class="comment">/* Section header table entry size */</span></span><br><span class="line">  Elf64_Halfe_shnum;<span class="comment">/* Section header table entry count */</span></span><br><span class="line">  Elf64_Halfe_shstrndx;<span class="comment">/* Section header string table index */</span></span><br><span class="line">&#125; Elf64_Ehdr;</span><br></pre></td></tr></table></figure></li><li><p>除结构体中的e_ident对应到readelf输出的从Magic到ABI Version部分，其它都是一一对应关系</p></li><li><p><code>e_shstrndx</code>变量表示<code>.shstrtab</code>在段表中的下标</p></li></ul></li></ol><ol><li><p>段表</p><ul><li><p>使用<code>gcc -c hello.c -o hello.o</code>生成目标文件hello.o，并使用<code>readelf -S hello.o</code>读取目标文件的段表部分</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">Section Headers:</span><br><span class="line">  [Nr] Name              Type             Address           Offset</span><br><span class="line">       Size              EntSize          Flags  Link  Info  Align</span><br><span class="line">  [ 0]                   NULL             0000000000000000  00000000</span><br><span class="line">       0000000000000000  0000000000000000           0     0     0</span><br><span class="line">  [ 1] .text             PROGBITS         0000000000000000  00000040</span><br><span class="line">       0000000000000035  0000000000000000  AX       0     0     1</span><br><span class="line">  [ 2] .rela.text        RELA             0000000000000000  00000440</span><br><span class="line">       0000000000000048  0000000000000018   I      12     1     8</span><br><span class="line">  [ 3] .data             PROGBITS         0000000000000000  00000078</span><br><span class="line">       000000000000000c  0000000000000000  WA       0     0     4</span><br><span class="line">  [ 4] .bss              NOBITS           0000000000000000  00000084</span><br><span class="line">       0000000000000014  0000000000000000  WA       0     0     4</span><br><span class="line">  [ 5] .rodata           PROGBITS         0000000000000000  00000084</span><br><span class="line">       000000000000000d  0000000000000000   A       0     0     1</span><br><span class="line">  [ 6] .data.rel.local   PROGBITS         0000000000000000  00000098</span><br><span class="line">       0000000000000008  0000000000000000  WA       0     0     8</span><br><span class="line">  [ 7] .rela.data.rel.lo RELA             0000000000000000  00000488</span><br><span class="line">       0000000000000018  0000000000000018   I      12     6     8</span><br><span class="line">  [ 8] .comment          PROGBITS         0000000000000000  000000a0</span><br><span class="line">       000000000000002c  0000000000000001  MS       0     0     1</span><br><span class="line">  [ 9] .note.GNU-stack   PROGBITS         0000000000000000  000000cc</span><br><span class="line">       0000000000000000  0000000000000000           0     0     1</span><br><span class="line">  [10] .eh_frame         PROGBITS         0000000000000000  000000d0</span><br><span class="line">       0000000000000038  0000000000000000   A       0     0     8</span><br><span class="line">  [11] .rela.eh_frame    RELA             0000000000000000  000004a0</span><br><span class="line">       0000000000000018  0000000000000018   I      12    10     8</span><br><span class="line">  [12] .symtab           SYMTAB           0000000000000000  00000108</span><br><span class="line">       0000000000000240  0000000000000018          13    16     8</span><br><span class="line">  [13] .strtab           STRTAB           0000000000000000  00000348</span><br><span class="line">       00000000000000f6  0000000000000000           0     0     1</span><br><span class="line">  [14] .shstrtab         STRTAB           0000000000000000  000004b8</span><br><span class="line">       0000000000000076  0000000000000000           0     0     1</span><br><span class="line">Key to Flags:</span><br><span class="line">  W (write), A (alloc), X (execute), M (merge), S (strings), I (info),</span><br><span class="line">  L (link order), O (extra OS processing required), G (group), T (TLS),</span><br><span class="line">  C (compressed), x (unknown), o (OS specific), E (exclude),</span><br><span class="line">  l (large), p (processor specific)</span><br></pre></td></tr></table></figure></li><li><p>段表结构体定义在/usr/include/elf.h中，目标文件hello.o的文件头中机器字节长度为ELF64，找到64位版本段表结构体定义Elf64_Shdr（每个Elf64_Shdr对应一个段，Elf64_Shdr又称为<strong>段描述符<Section Descriptor></strong>），如下所示</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Elf64_Wordsh_name;<span class="comment">/* Section name (string tbl index) */</span></span><br><span class="line">  Elf64_Wordsh_type;<span class="comment">/* Section type */</span></span><br><span class="line">  Elf64_Xwordsh_flags;<span class="comment">/* Section flags */</span></span><br><span class="line">  Elf64_Addrsh_addr;<span class="comment">/* Section virtual addr at execution */</span></span><br><span class="line">  Elf64_Offsh_offset;<span class="comment">/* Section file offset */</span></span><br><span class="line">  Elf64_Xwordsh_size;<span class="comment">/* Section size in bytes */</span></span><br><span class="line">  Elf64_Wordsh_link;<span class="comment">/* Link to another section */</span></span><br><span class="line">  Elf64_Wordsh_info;<span class="comment">/* Additional section information */</span></span><br><span class="line">  Elf64_Xwordsh_addralign;<span class="comment">/* Section alignment */</span></span><br><span class="line">  Elf64_Xwordsh_entsize;<span class="comment">/* Entry size if section holds table */</span></span><br><span class="line">&#125; Elf64_Shdr;</span><br></pre></td></tr></table></figure></li><li><p>Elf64_Shdr部分成员解释</p></li></ul></li></ol><div class="table-container"><table><thead><tr><th>变量名</th><th>说明</th></tr></thead><tbody><tr><td>sh_name</td><td>段名是一个字符串，位于一个叫.shstrtab的字符串表中，sh_name是段名字符串在.shstrtab中的偏移</td></tr><tr><td>sh_addr</td><td>段虚拟地址，如果该段可以加载，sh_addr为该段被加载后在进程地址空间的虚拟地址，否则为0</td></tr><tr><td>sh_offset</td><td>段偏移，如果该段存在于文件中则表示该段在文件中的偏移，否则无意义</td></tr><tr><td>sh_link、sh_info</td><td>段链接信息，如果该段的类型是与链接相关的，则该字段有意义</td></tr><tr><td>sh_addralign</td><td>段地址对齐，sh_addralign表示是地址对齐数量的指数，如果sh_addralign为0或者1则该段没有字节对齐要求</td></tr><tr><td>sh_entsize</td><td>对于一些段包含了一些固定大小的项，比如符号表，则sh_entsize表示每个项的大小</td></tr></tbody></table></div><ol><li>重定位表：hello.o中包含一个<code>.rela.text</code>的段，类型为RELA，它是一个重定位表。链接器在处理目标文件时必须对文件中的某些部位进行重定位，这些重定位信息都记录在重定位表中。对于每个需要重定位的代码段或者数据段，都会有一个相应的重定位表。</li></ol><ol><li><p>字符串表</p><ul><li><p>.strtab：字符串表，保存普通的字符串，比如符号的名字</p></li><li><p>.shstrtab：段表字符串表，保存段表中用到的字符串，比如段名</p></li></ul></li></ol><p>   <strong>结论：ELF文件头中的<code>e_shstrndx</code>变量表示<code>.shstrtab</code>在段表中的下标，<code>e_shoff</code>表示段表在文件中的偏移，只有解析ELF文件头，就可以得到段表和段表字符串表的位置，从而解析整个ELF文件</strong></p><h4 id="3-1-4-链接的接口——符号"><a href="#3-1-4-链接的接口——符号" class="headerlink" title="3.1.4 链接的接口——符号"></a>3.1.4 链接的接口——符号</h4><h5 id="3-1-4-1-符号定义"><a href="#3-1-4-1-符号定义" class="headerlink" title="3.1.4.1 符号定义"></a>3.1.4.1 符号定义</h5><ol><li><p><strong>定义：</strong>在链接中，目标文件之间相互拼合实际上是目标文件之间对地址的引用，即对函数和变量地址的引用。在链接中，将函数和变量统称为<strong>符号（Symbol）</strong>，函数名或变量名称为<strong>符号名（Symbol Name）</strong>。</p></li><li><p>每个目标文件都有一个符号表记录了目标文件中用到的所有符号（每个定义的符号都有一个符号值，对于函数和变量来说，符号值就是它们的地址），<strong>常见分类</strong>如下</p></li></ol><div class="table-container"><table><thead><tr><th>符号类型</th><th>说明</th></tr></thead><tbody><tr><td>定义在本目标文件中的全局符号</td><td>可以被其它目标文件引用的符号</td></tr><tr><td>在本目标文件中引用的符号，却没有定义在本目标文件中</td><td>外部符号（External Symbol）</td></tr><tr><td>段名，由编译器产生</td><td>它的值就是该段的起始地址</td></tr><tr><td>局部符号</td><td>只在编译单元内部可见，链接器往往忽略它们</td></tr><tr><td>行号信息</td><td>目标文件指令与代码行的对应关系，可选</td></tr></tbody></table></div><h5 id="3-1-4-2-符号结构分析"><a href="#3-1-4-2-符号结构分析" class="headerlink" title="3.1.4.2 符号结构分析"></a>3.1.4.2 符号结构分析</h5><ul><li><p>符号表结构：符号表结构体定义在/usr/include/elf.h中，如下所示</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Elf64_Wordst_name;<span class="comment">/* Symbol name (string tbl index) */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span>st_info;<span class="comment">/* Symbol type and binding */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span> st_other;<span class="comment">/* Symbol visibility */</span></span><br><span class="line">  Elf64_Sectionst_shndx;<span class="comment">/* Section index */</span></span><br><span class="line">  Elf64_Addrst_value;<span class="comment">/* Symbol value */</span></span><br><span class="line">  Elf64_Xwordst_size;<span class="comment">/* Symbol size */</span></span><br><span class="line">&#125; Elf64_Sym;</span><br></pre></td></tr></table></figure><p>Elf64_Sym成员解释</p></li></ul><div class="table-container"><table><thead><tr><th>变量名</th><th>说明</th></tr></thead><tbody><tr><td>st_name</td><td>符号名在字符串表中的下标</td></tr><tr><td>st_info</td><td>符号类型和绑定信息</td></tr><tr><td>st_other</td><td>符号可见性</td></tr><tr><td>st_shndx</td><td>符号所在的段</td></tr><tr><td>st_value</td><td>符号对应的值</td></tr><tr><td>st_size</td><td>符号大小</td></tr></tbody></table></div><ul><li><p>使用<code>gcc -c hello.c -o hello.o</code>生成目标文件hello.o，并使用<code>readelf -s hello.o</code>读取目标文件的符号表部分</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Symbol table <span class="string">&#x27;.symtab&#x27;</span> contains 24 entries:</span><br><span class="line">   Num:    Value          Size Type    Bind   Vis      Ndx Name</span><br><span class="line">     0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND</span><br><span class="line">     1: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS hello.c</span><br><span class="line">     2: 0000000000000000     0 SECTION LOCAL  DEFAULT    1</span><br><span class="line">     3: 0000000000000000     0 SECTION LOCAL  DEFAULT    3</span><br><span class="line">     4: 0000000000000000     0 SECTION LOCAL  DEFAULT    4</span><br><span class="line">     5: 0000000000000000     0 SECTION LOCAL  DEFAULT    5</span><br><span class="line">     6: 0000000000000000     0 SECTION LOCAL  DEFAULT    6</span><br><span class="line">     7: 0000000000000004     4 OBJECT  LOCAL  DEFAULT    4 static_global_uninit_var</span><br><span class="line">     8: 0000000000000008     4 OBJECT  LOCAL  DEFAULT    4 static_global_init_var_0</span><br><span class="line">     9: 0000000000000004     4 OBJECT  LOCAL  DEFAULT    3 static_global_init_var_1</span><br><span class="line">    10: 0000000000000008     4 OBJECT  LOCAL  DEFAULT    3 static_local_init_var_1.1</span><br><span class="line">    11: 000000000000000c     4 OBJECT  LOCAL  DEFAULT    4 static_local_init_var_0.1</span><br><span class="line">    12: 0000000000000010     4 OBJECT  LOCAL  DEFAULT    4 static_local_uninit_var.1</span><br><span class="line">    13: 0000000000000000     0 SECTION LOCAL  DEFAULT    9</span><br><span class="line">    14: 0000000000000000     0 SECTION LOCAL  DEFAULT   10</span><br><span class="line">    15: 0000000000000000     0 SECTION LOCAL  DEFAULT    8</span><br><span class="line">    16: 0000000000000004     4 OBJECT  GLOBAL DEFAULT  COM global_uninit_var</span><br><span class="line">    17: 0000000000000000     4 OBJECT  GLOBAL DEFAULT    4 global_init_var_0</span><br><span class="line">    18: 0000000000000000     4 OBJECT  GLOBAL DEFAULT    3 global_init_var_1</span><br><span class="line">    19: 0000000000000000     8 OBJECT  GLOBAL DEFAULT    6 const_string_var</span><br><span class="line">    20: 0000000000000000    53 FUNC    GLOBAL DEFAULT    1 main</span><br><span class="line">    21: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND _GLOBAL_OFFSET_TABLE_</span><br><span class="line">    22: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND func_call_test</span><br><span class="line">    23: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND export_func_var</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">注：</span><br><span class="line">1. static_global_uninit_var、static_local_init_var_0和static_local_uninit_var、static_global_init_var_0和global_init_var_0在bss段（因为初始化为0和不初始化是一样的）</span><br><span class="line">2. static_global_init_var_1、static_local_init_var_1和global_init_var_1在data段（初始化的全局变量）</span><br><span class="line">3. static变量的类型均为LOCAL，表明该符号只为该目标文件内部可见；非Static全局变量的类型为GLOBAL，表明该符号外部可见</span><br><span class="line">4. 在hello.c中引用了func_call_test和export_func_var符号，但是没有定义，所以它的Ndx是UND（注：<span class="built_in">export</span>一个变量但是并未使用则符号表中不会出现这个边浪符号信息；<span class="built_in">export</span>一个不存在的变量但是并未使用编译不会报错；<span class="built_in">export</span>一个不存在的变量并使用会报错 &lt;**注意系统环境**&gt; ）</span><br><span class="line">5. 未初始化的全局非静态变量global_uninit_var在COM块中</span><br><span class="line">6. const_string_var在.data.rel.local段中</span><br></pre></td></tr></table></figure></li><li><p>特殊符号：当使用<strong>链接器生成可执行文件时</strong>，会定义很多特殊的符号，这些符号并未在程序中定义，但是可以直接声明并引用它们</p></li></ul><h5 id="3-1-4-3-符号修饰与函数签名"><a href="#3-1-4-3-符号修饰与函数签名" class="headerlink" title="3.1.4.3 符号修饰与函数签名"></a>3.1.4.3 符号修饰与函数签名</h5><p>​        符号修饰与函数签名：在符号名前或者后面加上<code>_</code>修饰符号，防止与库文件和其它目标文件冲突。现在的linux下的GCC编译器中，默认情况下去掉了加上<code>_</code>这种方式，可以通过参数选项打开</p><ul><li><p>C++符号修饰：C++拥有类，继承，重载和命名空间等这些特性，导致符号管理更为复杂。例如重载的情况：函数名相同但是参数不一样。然后就有了符号修饰和符号改编的机制，使用函数签名（包括函数名，参数类型，所在的类和命名空间等信息）来识别不同的函数</p></li><li><p>C++符号修饰栗子</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">C2</span> &#123;</span></span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> N &#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">C</span> &#123;</span></span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">func</span><span class="params">(<span class="keyword">float</span> num)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">C::func</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> C::C2::func(<span class="keyword">int</span> num)&#123;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">N::func</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> N::C::func(<span class="keyword">int</span> num)&#123;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> int_res = func(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">float</span> float_var = <span class="number">1.1</span>;</span><br><span class="line">    <span class="keyword">float</span> float_res = func(float_var);</span><br><span class="line"></span><br><span class="line">    C class_C;</span><br><span class="line">    int_res = class_C.func(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<code>g++ -c hello.cpp -o hello_cpp.o</code>编译产生目标文件hello_cpp.o，使用<code>readelf -a hello_cpp.o</code>查看目标文件中的符号表，如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Symbol table <span class="string">&#x27;.symtab&#x27;</span> contains 18 entries:</span><br><span class="line">   Num:    Value          Size Type    Bind   Vis      Ndx Name</span><br><span class="line">     0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND</span><br><span class="line">     1: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS hello.cpp</span><br><span class="line">     2: 0000000000000000     0 SECTION LOCAL  DEFAULT    1</span><br><span class="line">     3: 0000000000000000     0 SECTION LOCAL  DEFAULT    3</span><br><span class="line">     4: 0000000000000000     0 SECTION LOCAL  DEFAULT    4</span><br><span class="line">     5: 0000000000000000     0 SECTION LOCAL  DEFAULT    5</span><br><span class="line">     6: 0000000000000000     0 SECTION LOCAL  DEFAULT    7</span><br><span class="line">     7: 0000000000000000     0 SECTION LOCAL  DEFAULT    8</span><br><span class="line">     8: 0000000000000000     0 SECTION LOCAL  DEFAULT    6</span><br><span class="line">     9: 0000000000000000    12 FUNC    GLOBAL DEFAULT    1 _Z4funci</span><br><span class="line">    10: 000000000000000c    16 FUNC    GLOBAL DEFAULT    1 _Z4funcf</span><br><span class="line">    11: 000000000000001c    16 FUNC    GLOBAL DEFAULT    1 _ZN1C4funcEi</span><br><span class="line">    12: 000000000000002c    16 FUNC    GLOBAL DEFAULT    1 _ZN1C2C24funcEi</span><br><span class="line">    13: 000000000000003c    12 FUNC    GLOBAL DEFAULT    1 _ZN1N4funcEi</span><br><span class="line">    14: 0000000000000048    16 FUNC    GLOBAL DEFAULT    1 _ZN1N1C4funcEi</span><br><span class="line">    15: 0000000000000058   119 FUNC    GLOBAL DEFAULT    1 main</span><br><span class="line">    16: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND _GLOBAL_OFFSET_TABLE_</span><br><span class="line">    17: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND __stack_chk_fail</span><br></pre></td></tr></table></figure><p>可以看出函数签名与修饰后的名称的对应关系</p></li></ul><div class="table-container"><table><thead><tr><th>函数签名</th><th>修饰后名称（符号名）</th></tr></thead><tbody><tr><td>int func(int)</td><td>_Z4funci</td></tr><tr><td>float func(float)</td><td>_Z4funcf</td></tr><tr><td>int C::func(int)</td><td>_ZN1C4funcEi</td></tr><tr><td>int C::C2::func(int)</td><td>_ZN1C2C24funcEi</td></tr><tr><td>int N::func(int)</td><td>_ZN1N4funcEi</td></tr><tr><td>int N::C::func(int)</td><td>_ZN1N1C4funcEi</td></tr></tbody></table></div><ul><li><p>extern “C”：C++编译器会将在extern C大括号内的内部代码当做C语言代码处理，也就是名称修饰机制将不会起作用。当需要兼容C和C++，例如在C++代码中调用C中的memset函数，可以使用C++的宏<code>__cplusplus</code>，C++在编译程序时会默认定义这个宏</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> “C” &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">memset</span><span class="params">(<span class="keyword">void</span> *, <span class="keyword">int</span>, <span class="keyword">size_t</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>由于<strong>不同的编译器采用不同的名字修饰方法</strong>，必然会导致不同编译器产生的目标文件无法正常互相链接，这是<strong>导致不同编译器之间不能互操作的原因</strong></p></li></ul><h5 id="3-1-4-4-弱符号与强符号"><a href="#3-1-4-4-弱符号与强符号" class="headerlink" title="3.1.4.4 弱符号与强符号"></a>3.1.4.4 弱符号与强符号</h5><p>​        在编程中经常遇到符号重定义的问题，例如hello.c和func.c都定义了一个_global并将它们都初始化，在编译时就会报错。对于C/C++来说，编译器默认函数和初始化的全局变量为强符号，未初始化的全局变量为弱符号。</p><ul><li><p><strong>编译器处理符号规则</strong></p><ul><li>不允许强符号被多次定义</li><li>如果一个符号在一个文件中是强符号，在其它文件中是弱符号，则选择强符号</li><li>如果一个符号在所有的文件中都是弱符号，则选择其中占用空间最大的一个（int型和double型会选择double型）</li></ul></li><li><p><strong>弱引用与强引用</strong>：对外部目标文件中的符号引用在目标文件最终被链接成可执行文件时都哟啊被正确决议，如果没有找到该符号的定义，则会报未定义错误，这种被称为强引用；与之对应的弱引用，在处理弱引用时，如果该符号有定义，则链接器将该符号的引用决议；如果该符号未被定义，则链接器也不会报错。</p></li><li><p><strong>弱符号与弱引用的作用</strong>（对库来说很有用）</p><ul><li>库中定义的弱符号可以被用户定义的强符号所覆盖，从而使程序可以使用自定义版本的函数</li><li>程序可以对某些扩展功能模块的引用定义为弱引用，当扩展模块与程序链接到一起时，功能模块可以正常使用；如果去掉了某些功能模块，则程序也可以正常链接，只是缺少了相应的功能，这使得程序的功能更容易裁剪和组合</li></ul></li></ul><h3 id="3-2-静态链接"><a href="#3-2-静态链接" class="headerlink" title="3.2 静态链接"></a>3.2 静态链接</h3><h4 id="3-2-1-空间和地址分配"><a href="#3-2-1-空间和地址分配" class="headerlink" title="3.2.1 空间和地址分配"></a>3.2.1 空间和地址分配</h4><p>链接器在合并多个目标文件的段时，采用<strong>相似段合并</strong>的方式，并分配地址和空间（虚拟地址空间的分配）</p><p><strong>两步链接法：</strong></p><ol><li>空间和地址分配：扫描所有的目标文件，获得它们的各个段的长度、属性和位置，并且将输入目标文件中的符号表中所有的符号定义和符号引用收集起来，统一放到一个全局符号表，这一步中，链接器将能够获得所有输入目标文件的段长度，并将它们合并，计算输出文件中各个合并之后的段的长度，建立映射关系。</li><li>符号解析与重定位：使用空间和地址分配中收集到的所有信息，读取输入文件中段的数据、重定位信息，并且进行符号解析与重定位、调整代码中的地址等。</li></ol><p>当进行了空间和地址分配之后，各个段的虚拟地址也就确定了，由于各个符号在段内的位置是相对的，所以各个符号的地址也就确定了。</p><h4 id="3-2-2-符号解析与重定位"><a href="#3-2-2-符号解析与重定位" class="headerlink" title="3.2.2 符号解析与重定位"></a>3.2.2 符号解析与重定位</h4><ul><li><p>使用<code>gcc -c hello.c -o hello.o</code>生成目标文件hello.o，并使用<code>objdump -d hello.o</code>读取目标文件的<code>.text</code>的反汇编结果，如下所示（简略部分内容）；同理使用<code>gcc -c func.c -o func.o</code>生成目标文件func.o。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[delta@rabbit: c_code ]$ objdump -d hello.o</span><br><span class="line">Disassembly of section .text:</span><br><span class="line">0000000000000000 &lt;main&gt;:</span><br><span class="line">   0:55                   push   %rbp</span><br><span class="line">   1:48 89 e5             mov    %rsp,%rbp</span><br><span class="line">   4:48 83 ec 10          sub    <span class="variable">$0x10</span>,%rsp</span><br><span class="line">   8:c7 45 f8 00 00 00 00 movl   <span class="variable">$0x0</span>,-0x8(%rbp)</span><br><span class="line">   f:c7 45 <span class="built_in">fc</span> 01 00 00 00 movl   <span class="variable">$0x1</span>,-0x4(%rbp)</span><br><span class="line">  16:bf 08 00 00 00       mov    <span class="variable">$0x8</span>,%edi</span><br><span class="line">  1b:e8 00 00 00 00       callq  20 &lt;main+0x20&gt;</span><br><span class="line">  20:8b 05 00 00 00 00    mov    0x0(%rip),%eax        <span class="comment"># 26 &lt;main+0x26&gt;</span></span><br><span class="line">  26:01 c0                add    %eax,%eax</span><br><span class="line">  28:89 05 00 00 00 00    mov    %eax,0x0(%rip)        <span class="comment"># 2e &lt;main+0x2e&gt;</span></span><br><span class="line">  2e:b8 00 00 00 00       mov    <span class="variable">$0x0</span>,%eax</span><br><span class="line">  33:c9                   leaveq</span><br><span class="line">  34:c3                   retq</span><br></pre></td></tr></table></figure><p><strong>分析：</strong>由以上结果可以看出，在链接之前，main函数在调用func_call_test函数时，使用的地址是0x00000000，根据反汇编结果就是下一条指令（<code>e8 00 00 00 00</code>之中<code>e8</code>是callq的指令码，<code>00 00 00 00</code>是目的地址相对于下一条指令的偏移量）；在使用export_func_var变量时，编译器就将0x0看做是export_func_var的地址</p></li><li><p>使用<code>ld hello.o func.o -e main</code>链接两个目标文件，生成可执行文件a.out（并不能执行，因为缺少部分目标文件，但是符号已经被重新定位；<code>-e main</code>表示将main函数作为程序入口），使用<code>objdump -d a.out</code>查看a.out的<code>.text</code>段反汇编结果，如下图所示（简略部分内容）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">[delta@rabbit: c_code ]$ objdump -d a.out</span><br><span class="line">Disassembly of section .text:</span><br><span class="line">00000000004000e8 &lt;main&gt;:</span><br><span class="line">  4000e8:55                   push   %rbp</span><br><span class="line">  4000e9:48 89 e5             mov    %rsp,%rbp</span><br><span class="line">  4000ec:48 83 ec 10          sub    <span class="variable">$0x10</span>,%rsp</span><br><span class="line">  4000f0:c7 45 f8 00 00 00 00 movl   <span class="variable">$0x0</span>,-0x8(%rbp)</span><br><span class="line">  4000f7:c7 45 <span class="built_in">fc</span> 01 00 00 00 movl   <span class="variable">$0x1</span>,-0x4(%rbp)</span><br><span class="line">  4000fe:bf 08 00 00 00       mov    <span class="variable">$0x8</span>,%edi</span><br><span class="line">  400103:e8 15 00 00 00       callq  40011d &lt;func_call_test&gt;</span><br><span class="line">  400108:8b 05 0a 0f 20 00    mov    0x200f0a(%rip),%eax        <span class="comment"># 601018 &lt;export_func_var&gt;</span></span><br><span class="line">  40010e:01 c0                add    %eax,%eax</span><br><span class="line">  400110:89 05 02 0f 20 00    mov    %eax,0x200f02(%rip)        <span class="comment"># 601018 &lt;export_func_var&gt;</span></span><br><span class="line">  400116:b8 00 00 00 00       mov    <span class="variable">$0x0</span>,%eax</span><br><span class="line">  40011b:c9                   leaveq</span><br><span class="line">  40011c:c3                   retq   </span><br><span class="line"></span><br><span class="line">000000000040011d &lt;func_call_test&gt;:</span><br><span class="line">  40011d:55                   push   %rbp</span><br><span class="line">  40011e:48 89 e5             mov    %rsp,%rbp</span><br><span class="line">  400121:89 7d ec             mov    %edi,-0x14(%rbp)</span><br><span class="line">  400124:8b 45 ec             mov    -0x14(%rbp),%eax</span><br><span class="line">  400127:01 c0                add    %eax,%eax</span><br><span class="line">  400129:89 45 <span class="built_in">fc</span>             mov    %eax,-0x4(%rbp)</span><br><span class="line">  40012c:90                   nop</span><br><span class="line">  40012d:5d                   pop    %rbp</span><br><span class="line">  40012e:c3                   retq</span><br></pre></td></tr></table></figure><p>使用<code>nm a.out</code>查看a.out中的符号信息（简略），可以看到export_func_var的地址为0000000000601018</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[delta@rabbit: c_code ]$ nm a.out</span><br><span class="line">0000000000601018 D export_func_var</span><br></pre></td></tr></table></figure><p><strong>分析：</strong>在链接之后，可以从反汇编中看出main函数的调用func_call_test函数的地方地址已经被修正为func_call_test真正的地址000000000040011d，使用export_func_var变量的地方的地址也修正为export_func_var真正的地址0000000000601018（在nm a.out输出的符号表中）。所以链接器在完成地址空间分配之后就可以确定所有符号的虚拟地址了，链接器就可以根据符号的地址对每个需要重定位的地方进行地址修正。</p></li><li><p><strong>链接器如何知道哪些地址需要修正呢？</strong>有一个重定位表的结构专门保存与重定位相关的信息（比如<code>.text</code>如果有需要重定位的地方，那么就会有一个叫<code>.rela.text</code>的段保存了代码段的重定位信息），使用<code>objdump -r hello.o</code>查看重定位信息如下（简略），可以看到所有需要重定位的地方</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[delta@rabbit: c_code ]$ objdump -r hello.o</span><br><span class="line">RELOCATION RECORDS FOR [.text]:</span><br><span class="line">OFFSET           TYPE              VALUE</span><br><span class="line">000000000000001c R_X86_64_PLT32    func_call_test-0x0000000000000004</span><br><span class="line">0000000000000022 R_X86_64_PC32     export_func_var-0x0000000000000004</span><br><span class="line">000000000000002a R_X86_64_PC32     export_func_var-0x0000000000000004</span><br></pre></td></tr></table></figure></li><li><p><strong>符号解析：</strong>使用<code>nm hello.o</code>可以查看hello.o 中所有的符号信息，如下所示，可以看到export_func_var和func_call_test符号都是未定义状态（U）。所以档链接器扫描完所有的输入目标文件之后，所有的这些未定义的符号都能够在全局符号表中找到，否则就会报<strong>符号未定义（undefined reference to）</strong>错误。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 输出hello.o 中所有的符号信息</span></span><br><span class="line">[delta@rabbit: c_code ]$ nm hello.o</span><br><span class="line">0000000000000000 D const_string_var</span><br><span class="line">                 U export_func_var</span><br><span class="line">                 U func_call_test</span><br><span class="line">0000000000000000 B global_init_var_0</span><br><span class="line">0000000000000000 D global_init_var_1</span><br><span class="line">                 U _GLOBAL_OFFSET_TABLE_</span><br><span class="line">0000000000000004 C global_uninit_var</span><br><span class="line">0000000000000000 T main</span><br><span class="line">0000000000000008 b static_global_init_var_0</span><br><span class="line">0000000000000004 d static_global_init_var_1</span><br><span class="line">0000000000000004 b static_global_uninit_var</span><br><span class="line">000000000000000c b static_local_init_var_0.1809</span><br><span class="line">0000000000000008 d static_local_init_var_1.1810</span><br><span class="line">0000000000000010 b static_local_uninit_var.1808</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 符号未定义错误</span></span><br><span class="line">[delta@rabbit: c_code ]$ ld hello.o</span><br><span class="line">ld: warning: cannot find entry symbol _start; defaulting to 00000000004000e8</span><br><span class="line">hello.o: In <span class="keyword">function</span> `main<span class="string">&#x27;:</span></span><br><span class="line"><span class="string">hello.c:(.text+0x1c): undefined reference to `func_call_test&#x27;</span></span><br><span class="line">hello.c:(.text+0x22): undefined reference to `export_func_var<span class="string">&#x27;</span></span><br><span class="line"><span class="string">hello.c:(.text+0x2a): undefined reference to `export_func_var&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>指令修正方式：</strong>（<strong>A</strong>：保存正在修正位置的值；<strong>P</strong>：被修正的位置&lt;相对于段开始的偏移量或者虚拟地址&gt;；<strong>S</strong>：符号的实际地址；<strong>L</strong>：表示其索引位于重定位条目中的符号的值）<a href="http://www.ucw.cz/~hubicka/papers/abi/node19.html">以下计算参考</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># hello.o中的重定位信息（简略）</span></span><br><span class="line">[delta@rabbit: c_code ]$ objdump -r hello.o</span><br><span class="line">RELOCATION RECORDS FOR [.text]:</span><br><span class="line">OFFSET           TYPE              VALUE</span><br><span class="line">000000000000001c R_X86_64_PLT32    func_call_test-0x0000000000000004</span><br><span class="line">0000000000000022 R_X86_64_PC32     export_func_var-0x0000000000000004</span><br><span class="line">000000000000002a R_X86_64_PC32     export_func_var-0x0000000000000004</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解析：</span></span><br><span class="line"><span class="comment"># 根据输出符号的重定位类型有R_X86_64_PLT32和R_X86_64_PC32</span></span><br><span class="line"><span class="comment"># R_X86_64_PLT32 ： L + A - P（绝对地址修正）</span></span><br><span class="line"><span class="comment"># R_X86_64_PC32： S + A - P（相对寻址修正）</span></span><br><span class="line"><span class="comment"># 其它方式参考：http://www.ucw.cz/~hubicka/papers/abi/node19.html</span></span><br></pre></td></tr></table></figure><ul><li>绝对地址修正：绝对地址修正后的地址为该符号的实际地址，例如调用func_call_test符号的地址被修正成为了绝对地址40011d</li><li>相对地址修正：相对地址修正后的地址为符号距离被修正位置的地址差，例如使用export_func_var符号的地址被修正成为了相对地址0x200f0a，mov指令（第一个mov指令）的下一条地址40010e加上这个偏移量0x200f0a就是export_func_var的绝对地址0x601018</li></ul></li><li><p><strong>COMMON块</strong>：根据<code>nm hello.o</code>的输出，如下所示（简略），可以看到global_uninit_var符号的类型为COMMON类型，<strong>编译器将未初始化的全局变量作为弱符号处理</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[delta@rabbit: c_code ]$ nm hello.o</span><br><span class="line">0000000000000004 C global_uninit_var</span><br></pre></td></tr></table></figure><p><strong>多个符号定义类型情况分析</strong></p><ul><li>两个或以上强符号类型不一致：报重定义错误</li><li>有一个强符号和多个弱符号：取强符号，若是有弱符号比强符号空间大的情况则编译时会出现warning</li><li>两个或者以上弱符号类型不一致：取占用空间最大的弱符号</li></ul><p><strong>注</strong>：当编译器将一个编译单元编译成目标文件时，如果该编译单元包含弱符号（未初始化或者初始化为0的全局变量是典型），那么<strong>该符号所占用的最终空间就是不确定的，所以编译器无法在该阶段为该符号在BSS段分配空间</strong>。但是经过链接之后，任何一个符号的大小都确定了，所以它可以在最终输出文件的BSS段为其分配空间。总体来看，未初始化的全局变量是放在BSS段的</p></li></ul><h4 id="3-2-3-静态库链接"><a href="#3-2-3-静态库链接" class="headerlink" title="3.2.3 静态库链接"></a>3.2.3 静态库链接</h4><ul><li><p><strong>定义</strong>：静态库可以简单地看做是一组目标文件的集合，即很多目标文件经过压缩打包后形成的一个文件（Linux上常用的C语言静态库libc位于/usr/lib/x86_64-linux-gnu/libc.a）</p></li><li><p><strong>静态链接过程</strong>：在链接过程中ld链接器会自动寻找所有需要的符号以及它们所在的目标文件，将这些目标文件从libc.a中“解压”出来，最终将它们链接到一起形成一个可执行文件。使用<code>gcc -v hello.c func.c</code>编译生成可执行文件a.out，可以看到详细的链接过程，产生如下输出（简化版本）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">[delta@delta: code ]$ gcc -v func.c hello.c</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对func.c的预处理和编译过程</span></span><br><span class="line">/usr/lib/gcc/x86_64-linux-gnu/7/cc1 func.c -o /tmp/ccfC6J5E.s</span><br><span class="line"><span class="comment"># 对func.c产生的.s文件汇编产生二进制文件</span></span><br><span class="line">as -v --64 -o /tmp/ccF4Bar0.o /tmp/ccfC6J5E.s</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对hello.c的预处理和编译过程</span></span><br><span class="line">/usr/lib/gcc/x86_64-linux-gnu/7/cc1 hello.c -o /tmp/ccfC6J5E.s</span><br><span class="line"><span class="comment"># 对hello.c产生的.s文件汇编产生二进制文件</span></span><br><span class="line">as -v --64 -o /tmp/cc7UmhQl.o /tmp/ccfC6J5E.s</span><br><span class="line"></span><br><span class="line"><span class="comment"># 链接过程</span></span><br><span class="line">/usr/lib/gcc/x86_64-linux-gnu/7/collect2 -dynamic-linker ld-linux-x86-64.so.2 Scrt1.o crti.o crtbeginS.o /tmp/ccF4Bar0.o /tmp/cc7UmhQl.o crtendS.o crtn.o</span><br><span class="line"></span><br><span class="line"><span class="comment">############################################</span></span><br><span class="line"><span class="comment"># 实际各个目标文件的位置</span></span><br><span class="line">/usr/lib/gcc/x86_64-linux-gnu/7/../../../x86_64-linux-gnu/Scrt1.o</span><br><span class="line">/usr/lib/gcc/x86_64-linux-gnu/7/../../../x86_64-linux-gnu/crti.o</span><br><span class="line">/usr/lib/gcc/x86_64-linux-gnu/7/crtbeginS.o</span><br><span class="line">/tmp/ccF4Bar0.o</span><br><span class="line">/tmp/cc7UmhQl.o</span><br><span class="line">/usr/lib/gcc/x86_64-linux-gnu/7/crtendS.o</span><br><span class="line">/usr/lib/gcc/x86_64-linux-gnu/7/../../../x86_64-linux-gnu/crtn.o</span><br></pre></td></tr></table></figure><p>可以看到Scrt1.o crti.o crtbeginS.o /tmp/ccF4Bar0.o /tmp/cc7UmhQl.o crtendS.o crtn.o被链接入了最终可执行文件</p><p><strong>各个文件的解释</strong>（<a href="https://stackoverflow.com/questions/16436035/whats-the-usage-of-mcrt1-o-and-scrt1-o">来源</a>）</p></li></ul><div class="table-container"><table><thead><tr><th>目标文件</th><th>说明</th></tr></thead><tbody><tr><td>crt0.o</td><td>Older style of the initial runtime code ?  Usually not generated anymore  with Linux toolchains, but often found in bare metal toolchains.  Serves  same purpose as crt1.o (see below).</td></tr><tr><td>crt1.o</td><td>Newer style of the initial runtime code.  Contains the _start symbol which  sets up the env with argc/argv/libc _init/libc _fini before jumping to the  libc main.  glibc calls this file ‘start.S’.</td></tr><tr><td>crti.o</td><td>Defines the function prolog; _init in the .init section and _fini in the  .fini section.  glibc calls this ‘initfini.c’.</td></tr><tr><td>crtn.o</td><td>Defines the function epilog.  glibc calls this ‘initfini.c’.</td></tr><tr><td>scrt1.o</td><td>Used in place of crt1.o when generating PIEs.</td></tr><tr><td>gcrt1.o</td><td>Used in place of crt1.o when generating code with profiling information.  Compile with -pg.  Produces output suitable for the gprof util.</td></tr><tr><td>Mcrt1.o</td><td>Like gcrt1.o, but is used with the prof utility.  glibc installs this as  a dummy file as it’s useless on linux systems.</td></tr><tr><td>crtbegin.o</td><td>GCC uses this to find the start of the constructors.</td></tr><tr><td>crtbeginS.o</td><td>Used in place of crtbegin.o when generating shared objects/PIEs.</td></tr><tr><td>crtbeginT.o</td><td>Used in place of crtbegin.o when generating static executables.</td></tr><tr><td>crtend.o</td><td>GCC uses this to find the start of the destructors.</td></tr><tr><td>crtendS.o</td><td>Used in place of crtend.o when generating shared objects/PIEs.</td></tr></tbody></table></div><p>  <strong>通常链接顺序</strong>：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">crt1.o crti.o crtbegin.o [-L paths] [user objects] [gcc libs] [C libs] [gcc libs] crtend.o crtn.o</span><br></pre></td></tr></table></figure><ul><li><p><strong>链接过程控制</strong>：链接过程需要考虑很多内容：使用哪些目标文件？使用哪些库文件？是否保留调试信息、输出文件格式等等。</p><p><strong>链接器控制链接过程方法</strong>：</p><ul><li>使用命令行来给链接器指定参数</li><li>将链接器指令存放在目标文件里面，编译器通常会使用这种方式向链接器传递指令。</li><li>使用链接控制脚本</li></ul></li></ul><h4 id="3-2-4-BFD库简介"><a href="#3-2-4-BFD库简介" class="headerlink" title="3.2.4 BFD库简介"></a>3.2.4 BFD库简介</h4><ul><li><strong>定义</strong>：由于现代的硬件和软件平台种类繁多，每个平台都有不同的目标文件格式，导致编译器和链接器很难处理不同平台的目标文件。BFD库（Binary File Descriptor library）希望通过统一的接口来处理不同的目标文件格式。</li></ul><p>现代GCC（具体来讲是GNU 汇编器GAS）、链接器、调试器和GDB及binutils的其他工具都是通过BFD库来处理目标文件，而不是直接操作目标文件。</p><h3 id="3-3-装载与动态链接"><a href="#3-3-装载与动态链接" class="headerlink" title="3.3 装载与动态链接"></a>3.3 装载与动态链接</h3><h4 id="3-3-1可执行文件的装载"><a href="#3-3-1可执行文件的装载" class="headerlink" title="3.3.1可执行文件的装载"></a>3.3.1可执行文件的装载</h4><ul><li><p><strong>进程的虚拟地址空间</strong>：每个程序运行起来之后，它将拥有自己独立的虚拟地址空间，这个虚拟地址空间的大小由计算机的硬件平台决定，具体来说是CPU的位数决定（32位平台下的虚拟空间为4G<2^32>，通过<code>cat /proc/cpuinfo</code>可以看到虚拟地址的位数，如本机为<code>address sizes    : 39 bits physical, 48 bits virtual</code>，虚拟地址位数为48位，则虚拟空间为2^48）。</p><ul><li>进程只能使用操作系统分配给进程的地址，否则系统会捕获到这些访问并将其关闭（Window：进程因非法操作需要关闭；Linux：Segment Fault段错误）</li></ul></li><li><p><strong>装载的方式</strong>：程序运行时是有局部性原理的，所以可以将程序最常用的部分驻留在内存中，将不常用的数据存放在磁盘里（动态装入的基本原理）</p><ul><li>覆盖装入（几乎被淘汰）：覆盖装入的方法吧挖掘内存潜力的任务交给了程序员，程序员在编写程序时将程序分为若干块，然后编写一个辅助代码来管理这些这些模块何时应该驻留内存，何时应该被替换掉（在多个模块的情况下，程序员需要手工将它们之间的依赖关系组织成树状结构）</li><li>页映射：页映射不是一下子将指令和数据一下子装入内存，而是将内存和磁盘中的所有数据和指令按照页（Page）为单位划分，之后所有的装载和操作的单位就是页。</li></ul></li><li><p><strong>操作系统角度来看可执行文件的加载</strong>：</p><ol><li><p>创建一个独立的虚拟地址空间：创建映射函数所需要的对应的数据结构</p></li><li><p>读取可执行文件头，建立虚拟空间和可执行文件的映射关系：程序在发生页错误时，操作系统从物理空间分配出来一个物理页，然后将“缺页”从磁盘读取到内存中，并设置缺页的虚拟页与物理页的映射关系，很明显，操作系统捕获到缺页错误时，它应该知道当前所需要的页在可执行文件的哪一个位置。这就是虚拟空间与可执行文件之间的映射关系（这种映射关系只是保存在操作系统内部的一个<strong>数据结构</strong>，Linux中将进程虚拟空间中的一个段叫做虚拟内存区域（VMA））。</p></li><li><p>将CPU的指令寄存器设置成可执行文件的入口地址，启动运行</p><p><em>注：页错误处理：</em></p><ol><li><em>CPU将控制权交给操作系统</em></li><li><em>操作系统查询装载过程 第二部建立起来的数据结构，找到空白页所在的VMA，计算出相应页面在可执行文件中的便宜，然后在物理内存中分配一个物理页面，将进程中该虚拟地页与分配的物理页之间建立映射关系</em></li><li><em>把控制权还给进程</em></li></ol></li></ol></li></ul><h4 id="3-3-2-动态链接"><a href="#3-3-2-动态链接" class="headerlink" title="3.3.2 动态链接"></a>3.3.2 动态链接</h4><ul><li><strong>为什么需要动态链接</strong>：1、静态链接方式对于计算机内存和磁盘空间的浪费非常严重；2、静态链接库对程序的更新部署会带来很多麻烦（如果其中一个依赖进行了更新，那么该程序就要重新链接发布）</li><li><strong>动态链接</strong>：将链接的过程推迟到了运行的时候再进行，通过动态链接器（第二部分GCC编译过程中最后的链接设置了动态链接器参数<code>-dynamic-linker ld-linux-x86-64.so.2</code> ）完成链接工作，通过延迟绑定等来将动态链接损失的性能尽可能的小。<ul><li>动态地选择加载各种程序模块</li><li>加强程序的兼容性：一个程序在不同的平台运行时可以动态地链接到由操作系统提供的动态链接库，这些动态链接库相当于在程序和操作系统之间添加了一个中间层，从而消除程序对不同平台之间依赖的差异性</li></ul></li><li><strong>地址无关代码</strong>：共享对象在编译时不能假设自己在进程虚拟空间中的位置。把指令中那些需要修改的部分分离出来与数据部分放在一起，这样指令部分就可以保持不变，而数据部分可以在每个进程中有一个副本，这种方案就是地址无关代码（PIC，Position-Independent Code）<ul><li>装载时重定位：一旦模块装载地址确定，即目标地址确定，那么系统就对程序中所有的绝对地址进行重定位（静态链接时的重定位叫做链接时重定位；动态链接的重定位叫做装载时重定位 ）</li><li>模块中国各种类型地址类型引用方式：<ul><li>模块内部的函数调用、跳转：采用相对地址调用，不需要重定位</li><li>模块内部的数据访问，比如模块中定义的全局变量，静态变量：采用相对地址访问，获取当前的PC值，加上偏移量就能访问变量了</li><li>模块外部的数据访问，比如其它模块定义的全局变量：ELF的做法是子啊数据段里面建立一个指向这些变量的指针数组，称为全局偏移表（GOT，Global Offset Table）。GOT是放在数据段的，可以在模块装载时被修改，并且每个进程都可以有独立的副本，互相不影响。</li><li>模块外部的函数调用、跳转等：通过GOT中的项进行间接跳转</li></ul></li></ul></li><li><strong>延迟绑定</strong>：当函数第一次被用到才进行绑定（符号查找、重定位等），如果没有用到则不绑定。ELF使用PLT（Procedure Linkage Table）的方式来事先延迟绑定（PLT使解析只会在符号未解析时进行一次）。</li><li>动态链接的步骤<ul><li>动态链接器自举：动态链接器不依赖其它任何共享对象；动态链接器本身所需的全局和静态变量的重定位工作由它本身完成</li><li>装载共享对象：将可执行文件和链接器本身的符号都合并到一个全局符号表中（图的遍历过程），当一个符号需要加入到全局符号表时，如果相同的符号已经存在，则忽略后加入的符号</li><li>重定位与初始化：重新遍历可执行文件和每个共享对象的重定位表，将它们的GOT/PLT中的每个需要重定位的地方进行修正。</li></ul></li></ul><h2 id="四、参考文献"><a href="#四、参考文献" class="headerlink" title="四、参考文献"></a>四、参考文献</h2><p>[0] 程序员的自我修养 ：链接、装载与库 / 俞甲子，石凡，潘爱民著.—北京：电子工业出版社</p><p>[1] GNU ONLINE DOC - collect2 <a href="https://gcc.gnu.org/onlinedocs/gccint/Collect2.html">https://gcc.gnu.org/onlinedocs/gccint/Collect2.html</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;编译&quot;&gt;&lt;a href=&quot;#编译&quot; class=&quot;headerlink&quot; title=&quot;编译&quot;&gt;&lt;/a&gt;编译&lt;/h1&gt;&lt;h2 id=&quot;一、系统环境&quot;&gt;&lt;a href=&quot;#一、系统环境&quot; class=&quot;headerlink&quot; title=&quot;一、系统环境&quot;&gt;&lt;/a&gt;一</summary>
      
    
    
    
    <category term="C/C++" scheme="https://www.delta1037.cn/categories/C-C/"/>
    
    
    <category term="编译" scheme="https://www.delta1037.cn/tags/%E7%BC%96%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>基于NS3的无线链路物理层仿真实验</title>
    <link href="https://www.delta1037.cn/2019/School/%E5%9F%BA%E4%BA%8Ens3%E7%9A%84%E6%97%A0%E7%BA%BF%E9%93%BE%E8%B7%AF%E7%89%A9%E7%90%86%E5%B1%82%E4%BB%BF%E7%9C%9F%E5%AE%9E%E9%AA%8C/"/>
    <id>https://www.delta1037.cn/2019/School/%E5%9F%BA%E4%BA%8Ens3%E7%9A%84%E6%97%A0%E7%BA%BF%E9%93%BE%E8%B7%AF%E7%89%A9%E7%90%86%E5%B1%82%E4%BB%BF%E7%9C%9F%E5%AE%9E%E9%AA%8C/</id>
    <published>2019-02-11T11:21:59.000Z</published>
    <updated>2020-12-11T17:31:09.528Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、实验目的"><a href="#一、实验目的" class="headerlink" title="一、实验目的"></a>一、实验目的</h2><ol><li>掌握NS3的基本仿真方法</li><li>熟悉NS3的无线链路模型</li><li>改进NS3的无线链路模型</li></ol><h2 id="二、实验背景"><a href="#二、实验背景" class="headerlink" title="二、实验背景"></a>二、实验背景</h2><p>在原有的NS3的无线模型中,很难去控制链路的速率，延迟和错误等属性，例如在原有的模型中，错误率是不随距离变化的，即只要在可以传输的范围之内，错误率都是一样的，但是在实际中，随着距离的增加，错误率应该逐渐上升，而不是保持不变，因此我们在现有的模型中做出了一些改进，引入随着距离增加错误率逐渐增加的错误模型，并且引入丢头队列和丢尾队列来模拟不同队列的场景下传输速率的变化，同时加入定向网络的模型，实现定向传输的功能并且支持固定争用模型，即在冲突范围内，随着用户数量的增加，收包率逐渐下降。</p><h2 id="三、实验原理"><a href="#三、实验原理" class="headerlink" title="三、实验原理"></a>三、实验原理</h2><h4 id="1-错误模型"><a href="#1-错误模型" class="headerlink" title="1.错误模型"></a>1.错误模型</h4><p><img src="https://delta1037.oss-cn-beijing.aliyuncs.com/hexo-blog/NS3_wireless_expriment/图一_节点分布图.png" alt=""></p><p>图一:节点分布图</p><p>上图是基于NS3的错误模型节点分布图，如图所示，节点0分布在半径为100的圆的中心，其余100个节点以节点0为中心半径为100的圆内随机分布，同时节点0向周围节点发送数据，传输距离为100. ​ 在NS3原有的错误模型中，节点0向各个节点发送数据的丢包率是一样的，但是实际场景中随着距离的增加，丢包率会逐渐上升，经过研究和调查，我们所构建的丢包率曲线如下图<br><img src="https://delta1037.oss-cn-beijing.aliyuncs.com/hexo-blog/NS3_wireless_expriment/图二_丢包率曲线.png" alt=""></p><p>图二:丢包率曲线</p><h4 id="2-队列模型"><a href="#2-队列模型" class="headerlink" title="2.队列模型"></a>2.队列模型</h4><p>​ 在NS3的原有队列模型中使用的是丢尾队列，当发送数据包的队列已满时，丢尾队列会丢弃队列的最后的数据包，以控制数据包的发送率，我们引入了丢头队列，即当队列已满时，主动丢弃队列的头部的数据包，因为当队列已满时，表明队列的头部数据包非常的大，导致发送时间过长，使得后面的数据包处于等待过程中。因此丢头队列机制也会使得数据包的发送速率提升。</p><h4 id="3-定向网络"><a href="#3-定向网络" class="headerlink" title="3.定向网络"></a>3.定向网络</h4><p>​ 在NS3现有的模型中,无线网络采用的时广播的方式，中心节点发送数据之后，其余的节点都会收到数据包，我们引入了定向网路的模型，即在显示场景中，通过摆放天线的朝向，可以定向的向部分节点发送数据，两者对比如图：<br><img src="https://delta1037.oss-cn-beijing.aliyuncs.com/hexo-blog/NS3_wireless_expriment/图三_定向网络和非定向网络对比.png" alt=""></p><p>图三：定向网络和非定向网络对比</p><p>​ 在NS3中构造如上图所示的场景，在定向网络中只有定向的节点才会收到数据包，其余节点则不回收到数据包，而在非定向网络中，则是全部节点都会收到数据包，因此在两种场景下统计各个节点收到的数据包的数量就可以对比两者的特性。</p><h4 id="4-固定争用"><a href="#4-固定争用" class="headerlink" title="4.固定争用"></a>4.固定争用</h4><p>​ 实际场景中，在可传输的范围内，随着用户数量的增多，用户之间发生冲突的几率会逐渐增加，网络的性能将会逐渐下降，吞吐量逐渐下降，丢包率逐渐上升。<br><img src="https://delta1037.oss-cn-beijing.aliyuncs.com/hexo-blog/NS3_wireless_expriment/图四：固定争用.png" alt=""></p><p>图四：固定争用</p><p>​ 如图所示，仍然采用错误模型中的节点分布，中心节点向周围节点发送数据，同时不断扩大冲突范围，随着冲突范围的不断扩大，覆盖的用户数量就会不断的增加，吞吐量应该会逐渐下降，因此统计各个节点的丢包率应该会观察到随着冲突范围的增加，丢包率在逐渐上升。</p><h2 id="四、实验过程"><a href="#四、实验过程" class="headerlink" title="四、实验过程"></a>四、实验过程</h2><h4 id="1-错误模型测试"><a href="#1-错误模型测试" class="headerlink" title="1.错误模型测试"></a>1.错误模型测试</h4><p><img src="https://delta1037.oss-cn-beijing.aliyuncs.com/hexo-blog/NS3_wireless_expriment/图一_节点分布图.png" alt=""></p><p>图五：节点分布图</p><p>​ 采用如图五中的节点分布，一共有101个节点，节点0在中心，另外一百个节点随机分布在半径为100的圆内，令中心节点向周围节点发送数据，统计各个节点收到的数据包。<br><img src="https://delta1037.oss-cn-beijing.aliyuncs.com/hexo-blog/NS3_wireless_expriment/图二_丢包率曲线.png" alt=""></p><p>图六:测试所得丢包率曲线</p><p>​ 采用所构造的错误模型曲线，统计丢包率，测试结果如图六所示，测试结果显示随着距离的增加，丢包率在逐渐的上升，因此符合预期要求。<br><img src="https://delta1037.oss-cn-beijing.aliyuncs.com/hexo-blog/NS3_wireless_expriment/图七_测试所得丢包率曲线.png" alt=""></p><p>图七:测试所得丢包率曲线</p><p>​ 另一方面，减少节点数量为21个，统计统计节点的收包特性图，如图七所示，图中绿色的部分表明节点正在收到数据包，其余表示因发生错误导致节点处于空闲状态，结果表明由于节点所处的距离不同，任何两个节点的收包特性是不一样的，因此也从另一方面验证了所构造的模型的合理性和正确性。</p><h4 id="2-数据包队列测试"><a href="#2-数据包队列测试" class="headerlink" title="2.数据包队列测试"></a>2.数据包队列测试</h4><p><img src="https://delta1037.oss-cn-beijing.aliyuncs.com/hexo-blog/NS3_wireless_expriment/图八_丢头队列和丢为队列.png" alt=""> ​</p><p>图八:丢头队列和丢为队列</p><p>​ 采用两种类型的队列机制:丢头队列和丢为队列，测试的机制如图八所示，一共有两个节点，节点0向节点1发送数据包，并分别采用两种队列机制，然后统计节点1的收包特性。<br><img src="https://delta1037.oss-cn-beijing.aliyuncs.com/hexo-blog/NS3_wireless_expriment/图九_测试所得丢包率曲线.png" alt=""> ​</p><p>图九:测试所得丢包率曲线</p><p>​ 如图所示为测试结果，测试结果表明，丢头队列和丢尾队列都可以改变丢包率，并且可以看出丢头队列的延迟比丢尾队列的延迟更小。<br><img src="https://delta1037.oss-cn-beijing.aliyuncs.com/hexo-blog/NS3_wireless_expriment/图十_队列优先级测试曲线.png" alt=""> ​</p><p>图十:队列优先级测试曲线</p><p>​ 如图所示曲线为队列有限级的测试曲线，所发送的数据包分为数据包和控制包</p><h4 id="3-定向传输测试"><a href="#3-定向传输测试" class="headerlink" title="3.定向传输测试"></a>3.定向传输测试</h4><p><img src="https://delta1037.oss-cn-beijing.aliyuncs.com/hexo-blog/NS3_wireless_expriment/图十一_定向传输测试模型.png" alt=""></p><p>图十一:定向传输测试模型</p><p>​ 上图为测试定向网络时的节点分布图，其中节点1，3，4，7，10，11为定向网络节点，当使用定向网络传输模式时，中心节点0向这些节点定向传输数据，其余节点则应不能收到数据包，而当使用非定向网络传输模式时，所有节点都应该可以收到数据包。<br><img src="https://delta1037.oss-cn-beijing.aliyuncs.com/hexo-blog/NS3_wireless_expriment/图三_定向网络和非定向网络对比.png" alt=""></p><p>图十二:定向传输测试结果</p><p>​ 测试结果如上图，蓝色为非定向网络，黄色为定向网络，结果表明，当使用非定向网络时，全部节点都可以收到数据包，当使用定向网络时，只有定向网络节点才可以收到数据包，非定向网络节点无法收到数据包。</p><h4 id="4-固定争用测试"><a href="#4-固定争用测试" class="headerlink" title="4.固定争用测试"></a>4.固定争用测试</h4><p><img src="https://delta1037.oss-cn-beijing.aliyuncs.com/hexo-blog/NS3_wireless_expriment/图四：固定争用.png" alt=""></p><p>图十三：固定争用测试结果</p><p>​ 如图所示，横轴为冲突范围所覆盖的用户数量，测试结果表明：随着冲突范围的不断扩大，覆盖的用户数量逐渐增多，因此导致的冲突逐渐增多，丢包率逐渐上升，收包率逐渐下降。</p><h2 id="五、实验小结"><a href="#五、实验小结" class="headerlink" title="五、实验小结"></a>五、实验小结</h2><p>​ 实验过程中，我们遇到了很多的问题，首先在实验环境的搭建过程中，刚开始搭建的是基于NS3-dev的环境，在代码测试的过程中遇到了很多的问题，之后又搭建了NS3-dce的环境进行测试。同时，在测试代码的时候也有很多的问题，由于机器的处理速度有限，仿真测试结果往往需要很长时间才会出来，也花费了我们很多的精力。 ​ 在之后的过程中，我们将继续改进这个模型，构建宏基站和微基站的体系架构，并在此架构上面探索单小区模型和大规模网络场景模型下的基站调度策略。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、实验目的&quot;&gt;&lt;a href=&quot;#一、实验目的&quot; class=&quot;headerlink&quot; title=&quot;一、实验目的&quot;&gt;&lt;/a&gt;一、实验目的&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;掌握NS3的基本仿真方法&lt;/li&gt;
&lt;li&gt;熟悉NS3的无线链路模型&lt;/li&gt;
&lt;li&gt;改进NS</summary>
      
    
    
    
    <category term="课程" scheme="https://www.delta1037.cn/categories/%E8%AF%BE%E7%A8%8B/"/>
    
    
    <category term="NS-3" scheme="https://www.delta1037.cn/tags/NS-3/"/>
    
  </entry>
  
</feed>
