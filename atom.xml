<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Delta1037</title>
  
  <subtitle>技术是纯净的</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.delta1037.cn/"/>
  <updated>2020-04-25T03:19:45.944Z</updated>
  <id>https://www.delta1037.cn/</id>
  
  <author>
    <name>delta1037</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>C++ 类型转换</title>
    <link href="https://www.delta1037.cn/2020/C_C++/C-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"/>
    <id>https://www.delta1037.cn/2020/C_C++/C-类型转换/</id>
    <published>2020-04-25T03:19:45.000Z</published>
    <updated>2020-04-25T03:19:45.944Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>deltaNoteSite</title>
    <link href="https://www.delta1037.cn/2019/Deploy/deltaNoteSite/"/>
    <id>https://www.delta1037.cn/2019/Deploy/deltaNoteSite/</id>
    <published>2019-11-23T07:00:59.000Z</published>
    <updated>2020-11-15T13:37:50.319Z</updated>
    
    <content type="html"><![CDATA[<h1 id="deltaNote"><a href="#deltaNote" class="headerlink" title="deltaNote"></a>deltaNote</h1><h2 id="一、资源地址"><a href="#一、资源地址" class="headerlink" title="一、资源地址"></a>一、资源地址</h2><p><a href="https://github.com/delta1037/deltaNote" target="_blank" rel="noopener">项目github地址</a><br><a href="https://github.com/delta1037/deltaNote/releases" target="_blank" rel="noopener">发行版下载地址</a></p><h2 id="二、使用说明"><a href="#二、使用说明" class="headerlink" title="二、使用说明"></a>二、使用说明</h2><h3 id="2-1-Linux服务端安装"><a href="#2-1-Linux服务端安装" class="headerlink" title="2.1 Linux服务端安装"></a>2.1 Linux服务端安装</h3><p>1、从<a href="https://github.com/delta1037/deltaNote/releases" target="_blank" rel="noopener">发行版下载地址</a>下载服务端，解压<br>2、进入解压后的目录，使用<code>./deltaNote</code>命令运行，可以使用<code>netstat -anpt | grep 8888</code>看到服务端已在运行<br>3、可以使用<code>vim deltaNote</code>修改端口等参数</p><ul><li>目前测试服务端：<code>39.96.162.190:8888</code></li></ul><h3 id="2-2-Linux客户端安装"><a href="#2-2-Linux客户端安装" class="headerlink" title="2.2 Linux客户端安装"></a>2.2 Linux客户端安装</h3><p>1、下载压缩包之后，解压<br>2、执行<code>sudo ./install.sh</code>即可安装到<code>/usr/local/deltaNote</code><br>3、执行<code>sudo ./uninstall.sh</code>即可卸载</p><h3 id="2-3-window客户端安装"><a href="#2-3-window客户端安装" class="headerlink" title="2.3 window客户端安装"></a>2.3 window客户端安装</h3><p>1、下载压缩包，解压<br>2、双击<code>*.exe</code>运行安装程序（目前不支持安装在C盘）</p><h3 id="2-4-deltaNote简介"><a href="#2-4-deltaNote简介" class="headerlink" title="2.4 deltaNote简介"></a>2.4 deltaNote简介</h3><h4 id="2-4-1-主界面"><a href="#2-4-1-主界面" class="headerlink" title="2.4.1 主界面"></a>2.4.1 主界面</h4><p>主界面如下图所示<br><img src="https://delta1037.oss-cn-beijing.aliyuncs.com/hexo-blog/deltaNote/main.png" alt="主界面"></p><ul><li>主界面简介：主界面上部有四个按钮，分别是设置，刷新，界面锁和历史记录<ul><li>设置按钮：打开设置面板</li><li>刷新按钮：与服务端进行同步</li><li>界面锁按钮：界面锁打开时，可以对主界面位置进行调整</li><li>历史记录按钮：点击打开查看已做的内容，打开历史记录使用右键可以选择清理历史记录</li></ul></li><li>位置和大小：当界面锁是开启状态时，可以对窗体进行调整，其中<code>1</code>位置可以拖动窗口；<code>2</code>位置可以调整窗体的高度。</li><li>勾选已做：点击每条TODO的前边的小方框，可以将TODO标记为已做，可以在历史记录中查看</li></ul><h4 id="2-4-2-设置"><a href="#2-4-2-设置" class="headerlink" title="2.4.2 设置"></a>2.4.2 设置</h4><p>点击主界面中的设置按钮，可以看到设置界面，如下所示<br><img src="https://delta1037.oss-cn-beijing.aliyuncs.com/hexo-blog/deltaNote/setting.png" alt="设置"></p><ul><li>设置界面简介：<ul><li>服务端地址和端口(目前仅支持IP地址)</li><li>用户名和密码</li><li>调整窗体的透明度</li><li>调整字体大小</li><li>调整主界面宽度</li><li>调整字体和图标颜色</li><li>设置开机启动</li></ul></li></ul><h4 id="2-4-3-创建用户"><a href="#2-4-3-创建用户" class="headerlink" title="2.4.3 创建用户"></a>2.4.3 创建用户</h4><p>点击设置中的创建用户按钮，如下图所示<br><img src="https://delta1037.oss-cn-beijing.aliyuncs.com/hexo-blog/deltaNote/createUser.png" alt="创建用户"></p><p>填入用户名和密码即可创建新用户</p><h2 id="三、问题反馈"><a href="#三、问题反馈" class="headerlink" title="三、问题反馈"></a>三、问题反馈</h2><p><a href="https://github.com/delta1037/deltaNote/issues" target="_blank" rel="noopener">问题反馈</a></p><h2 id="四、问题"><a href="#四、问题" class="headerlink" title="四、问题"></a>四、问题</h2><ul><li>window客户端不要安装在C盘，因为安装和运行时没有获取管理员权限</li><li>window客户端开机启动选项打开之后，需要在任务管理器的启动页面禁用再启用</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;deltaNote&quot;&gt;&lt;a href=&quot;#deltaNote&quot; class=&quot;headerlink&quot; title=&quot;deltaNote&quot;&gt;&lt;/a&gt;deltaNote&lt;/h1&gt;&lt;h2 id=&quot;一、资源地址&quot;&gt;&lt;a href=&quot;#一、资源地址&quot; class=&quot;head
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>MySQL使用MariaDB Audit Plugin实现审计功能</title>
    <link href="https://www.delta1037.cn/2019/Deploy/MySQL%E4%BD%BF%E7%94%A8MariaDB-Audit-Plugin%E5%AE%9E%E7%8E%B0%E5%AE%A1%E8%AE%A1%E5%8A%9F%E8%83%BD/"/>
    <id>https://www.delta1037.cn/2019/Deploy/MySQL使用MariaDB-Audit-Plugin实现审计功能/</id>
    <published>2019-10-20T04:35:08.000Z</published>
    <updated>2019-10-20T04:35:41.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、安装MariaDB-Audit-Plugin"><a href="#一、安装MariaDB-Audit-Plugin" class="headerlink" title="一、安装MariaDB Audit Plugin"></a>一、安装MariaDB Audit Plugin</h2><h3 id="1-1-准备MariaDB安装环境"><a href="#1-1-准备MariaDB安装环境" class="headerlink" title="1.1 准备MariaDB安装环境"></a>1.1 准备MariaDB安装环境</h3><p>为了不对使用mysql的主机造成影响，建议使用另一台与mysql主机系统一致的主机来安装MariaDB，然后不用执行下面的卸载操作<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get autoremove --purge mysql-\*</span><br><span class="line">sudo rm -rf /var/lib/mysql*</span><br><span class="line">sudo rm -rf /etc/mysql/</span><br></pre></td></tr></table></figure></p><h3 id="1-2-安装MariaDB"><a href="#1-2-安装MariaDB" class="headerlink" title="1.2 安装MariaDB"></a>1.2 安装MariaDB</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install mariadb-server</span><br></pre></td></tr></table></figure><p>安装完成之后在/usr/lib/mysql/plugin目录中有server_audit.so插件，将该插件拷贝出来备用（拷贝到mysql主机的/usr/lib/mysql/plugin目录中）</p><h3 id="1-3-MySQL环境恢复"><a href="#1-3-MySQL环境恢复" class="headerlink" title="1.3 MySQL环境恢复"></a>1.3 MySQL环境恢复</h3><p>如果是在mysql的主机上进行安装MariaDB操作，使用如下命令将MariaDB卸载，并重新安装mysql<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get remove --purge mariadb-\*</span><br><span class="line">sudo rm -rf /etc/mysql/</span><br><span class="line">sudo rm -rf /var/lib/mysql*</span><br><span class="line">sudo apt-get remove --purge mysql-\*</span><br><span class="line">sudo apt-get install mysql-server mysql-client</span><br></pre></td></tr></table></figure></p><h3 id="1-4-添加MySQL配置"><a href="#1-4-添加MySQL配置" class="headerlink" title="1.4 添加MySQL配置"></a>1.4 添加MySQL配置</h3><p>修改/etc/mysql/my.cnf文件，在文件末尾添加如下内容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">log_output=FILE</span><br><span class="line">server_audit_file_path=/var/log/mysql/audit.log</span><br><span class="line">server_audit_events = &apos;QUERY_DCL,QUERY_DML_NO_SELECT,QUERY_DML,QUERY_DDL,TABLE,QUERY,CONNECT&apos;</span><br><span class="line">server_audit_logging=1</span><br></pre></td></tr></table></figure></p><p>重新启动MySQL<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service mysql restart</span><br></pre></td></tr></table></figure></p><h2 id="二、Mysql审计日志分析"><a href="#二、Mysql审计日志分析" class="headerlink" title="二、Mysql审计日志分析"></a>二、Mysql审计日志分析</h2><h3 id="2-1-server-audit-events变量过滤功能"><a href="#2-1-server-audit-events变量过滤功能" class="headerlink" title="2.1 server_audit_events变量过滤功能"></a>2.1 server_audit_events变量过滤功能</h3><p>使用mysql -uroot -p登陆数据库，执行如下命令修改变量为如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set global server_audit_events=&apos;QUERY_DDL&apos;;</span><br></pre></td></tr></table></figure></p><p>执行如下SQL语句<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">create database test2;</span><br><span class="line">use test2;</span><br><span class="line">create table table1 (col1 VARCHAR(20));</span><br><span class="line">insert into table1 values (&quot;lili&quot;);</span><br><span class="line">select * from table1;</span><br></pre></td></tr></table></figure></p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">20191019 </span><span class="number">20</span>:<span class="number">56</span>:<span class="number">50</span>,delta-mysql,root,localhost,<span class="number">16</span>,<span class="number">1300</span>,QUERY,test,<span class="comment">'create database test2',0</span></span><br><span class="line"><span class="symbol">20191019 </span><span class="number">20</span>:<span class="number">57</span>:<span class="number">29</span>,delta-mysql,root,localhost,<span class="number">16</span>,<span class="number">1306</span>,QUERY,test2,<span class="comment">'create table table1 (col1 VARCHAR(20))',0</span></span><br></pre></td></tr></table></figure><p>由上图可见只有create类型的日志被记录下来，insert和select类型的操作日志并没有被记录下来，并且操作类型字段显示为QUERY类型</p><p>使用mysql -uroot -p登陆数据库，执行如下命令修改变量为如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set global server_audit_events=&apos;QUERY_DDL,QUERY_DML&apos;;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">create database test3;</span><br><span class="line">use test3;</span><br><span class="line">create table table2 (col1 VARCHAR(20));</span><br><span class="line">insert into table2 values (&quot;lili&quot;);</span><br><span class="line">select * from table2;</span><br></pre></td></tr></table></figure><p>前两行是上面的日志，后面的是新产生的日志<br><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">20191019 </span><span class="number">20</span>:<span class="number">56</span>:<span class="number">50</span>,delta-mysql,root,localhost,<span class="number">16</span>,<span class="number">1300</span>,QUERY,test,<span class="comment">'create database test2',0</span></span><br><span class="line"><span class="symbol">20191019 </span><span class="number">20</span>:<span class="number">57</span>:<span class="number">29</span>,delta-mysql,root,localhost,<span class="number">16</span>,<span class="number">1306</span>,QUERY,test2,<span class="comment">'create table table1 (col1 VARCHAR(20))',0</span></span><br><span class="line"><span class="symbol">20191019 </span><span class="number">21</span>:<span class="number">45</span>:<span class="number">18</span>,delta-mysql,root,localhost,<span class="number">16</span>,<span class="number">1312</span>,QUERY,test2,<span class="comment">'create table table2 (col1 VARCHAR(20))',0</span></span><br><span class="line"><span class="symbol">20191019 </span><span class="number">21</span>:<span class="number">45</span>:<span class="number">33</span>,delta-mysql,root,localhost,<span class="number">16</span>,<span class="number">1313</span>,QUERY,test2,<span class="comment">'insert into table2 values ("lili")',0</span></span><br><span class="line"><span class="symbol">20191019 </span><span class="number">21</span>:<span class="number">45</span>:<span class="number">56</span>,delta-mysql,root,localhost,<span class="number">16</span>,<span class="number">1314</span>,QUERY,test2,<span class="comment">'select * from table2',0</span></span><br><span class="line"><span class="symbol">20191019 </span><span class="number">21</span>:<span class="number">47</span>:<span class="number">52</span>,delta-mysql,root,localhost,<span class="number">16</span>,<span class="number">1316</span>,QUERY,test2,<span class="comment">'create databse test3',1064</span></span><br><span class="line"><span class="symbol">20191019 </span><span class="number">21</span>:<span class="number">47</span>:<span class="number">58</span>,delta-mysql,root,localhost,<span class="number">16</span>,<span class="number">1317</span>,QUERY,test2,<span class="comment">'create database test3',0</span></span><br><span class="line"><span class="symbol">20191019 </span><span class="number">21</span>:<span class="number">48</span>:<span class="number">08</span>,delta-mysql,root,localhost,<span class="number">16</span>,<span class="number">1318</span>,QUERY,test2,<span class="comment">'SELECT DATABASE()',0</span></span><br><span class="line"><span class="symbol">20191019 </span><span class="number">21</span>:<span class="number">48</span>:<span class="number">15</span>,delta-mysql,root,localhost,<span class="number">16</span>,<span class="number">1320</span>,QUERY,test2,<span class="comment">'SELECT DATABASE()',0</span></span><br><span class="line"><span class="symbol">20191019 </span><span class="number">21</span>:<span class="number">48</span>:<span class="number">31</span>,delta-mysql,root,localhost,<span class="number">16</span>,<span class="number">1324</span>,QUERY,test3,<span class="comment">'create table table2 (col1 VARCHAR(20))',0</span></span><br><span class="line"><span class="symbol">20191019 </span><span class="number">21</span>:<span class="number">48</span>:<span class="number">31</span>,delta-mysql,root,localhost,<span class="number">16</span>,<span class="number">1325</span>,QUERY,test3,<span class="comment">'insert into table2 values ("lili")',0</span></span><br><span class="line"><span class="symbol">20191019 </span><span class="number">21</span>:<span class="number">48</span>:<span class="number">31</span>,delta-mysql,root,localhost,<span class="number">16</span>,<span class="number">1326</span>,QUERY,test3,<span class="comment">'select * from table2',0</span></span><br></pre></td></tr></table></figure></p><p>由上可见，create，select和insert类型的日志均被记录下来，并且操作类型字段均为QUERY类型，并不是QUERY_DDL和QUERY_DML类型</p><p>根据<a href="https://mariadb.com/kb/en/library/mariadb-audit-plugin-log-settings/" target="_blank" rel="noopener">官方文档</a>显示，QUERY_DDL操作类型指的是进行CREATE等操作时才产生QUERY_DDL操作类型的日志，QUERY_DML操作类型是进行SELECT等操作时才产生QUERY_DML操作类型的日志。</p><p>综上所述，server_audit_events确实对操作日志起到了过滤作用，但是实际日志中操作类型字段只有QUERY。说明QUERY_DDL确实起到了日志类型过滤作用，实际操作类型字段仍为QUERY。</p><h2 id="2-2TABLE-Event分析"><a href="#2-2TABLE-Event分析" class="headerlink" title="2.2TABLE Event分析"></a>2.2TABLE Event分析</h2><p>按照<a href="https://mariadb.com/kb/en/library/mariadb-audit-plugin-log-settings/" target="_blank" rel="noopener">官方文档</a>显示，执行查询操作时会显示操作类型为READ的TABLE事件日志<br><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">20170817 </span><span class="number">16</span>:<span class="number">04</span>:<span class="number">33</span>,ip-<span class="number">172</span>-<span class="number">30</span>-<span class="number">0</span>-<span class="number">38</span>,root,localhost,<span class="number">29</span>,<span class="number">913</span>,<span class="keyword">READ</span>,company,employees,</span><br><span class="line"><span class="symbol">20170817 </span><span class="number">16</span>:<span class="number">04</span>:<span class="number">33</span>,ip-<span class="number">172</span>-<span class="number">30</span>-<span class="number">0</span>-<span class="number">38</span>,root,localhost,<span class="number">29</span>,<span class="number">913</span>,<span class="keyword">READ</span>,company,employees_salaries,</span><br><span class="line"><span class="symbol">20170817 </span><span class="number">16</span>:<span class="number">04</span>:<span class="number">33</span>,ip-<span class="number">172</span>-<span class="number">30</span>-<span class="number">0</span>-<span class="number">38</span>,root,localhost,<span class="number">29</span>,<span class="number">913</span>,<span class="keyword">READ</span>,company,ref_job_titles,</span><br><span class="line"><span class="symbol">20170817 </span><span class="number">16</span>:<span class="number">04</span>:<span class="number">33</span>,ip-<span class="number">172</span>-<span class="number">30</span>-<span class="number">0</span>-<span class="number">38</span>,root,localhost,<span class="number">29</span>,<span class="number">913</span>,<span class="keyword">READ</span>,company,org_departments,</span><br><span class="line"><span class="symbol">20170817 </span><span class="number">16</span>:<span class="number">04</span>:<span class="number">33</span>,ip-<span class="number">172</span>-<span class="number">30</span>-<span class="number">0</span>-<span class="number">38</span>,root,localhost,<span class="number">29</span>,<span class="number">913</span>,QUERY,company,</span><br><span class="line"><span class="comment">'SELECT * FROM employee_pay WHERE title LIKE \'%Executive%\' OR title LIKE \'%Manager%\'',0</span></span><br></pre></td></tr></table></figure></p><p>下面是在MySQL中执行查询操作产生的audit日志，由最后一条可以看出，并没有READ类型的操作日志。<br><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">20191020 </span><span class="number">10</span>:<span class="number">48</span>:<span class="number">09</span>,delta-mysql,root,localhost,<span class="number">3</span>,<span class="number">31</span>,QUERY,wordpress,<span class="comment">'SELECT * FROM wp_options WHERE option_name LIKE \'%Executive%\' OR title LIKE \'%Manager%\'',1054</span></span><br><span class="line"><span class="symbol">20191020 </span><span class="number">10</span>:<span class="number">48</span>:<span class="number">19</span>,delta-mysql,root,localhost,<span class="number">3</span>,<span class="number">32</span>,QUERY,wordpress,<span class="comment">'SELECT * FROM wp_options WHERE option_name LIKE \'%Executive%\' OR option_name LIKE \'%Manager%\'',0</span></span><br></pre></td></tr></table></figure></p><p>通过查询<a href="http://www.mysqldbaservices.com/2016/03/11/mysql-mariadb-audit-plugin-installation-and-configuration/" target="_blank" rel="noopener">资料</a>，TABLE事件只支持MariaDB 5.5.31 以及更新的版本，MySQL Server不提供MariaDB Audit Plugin需要的信息来追踪TABLE事件。</p><h2 id="三、参考资料"><a href="#三、参考资料" class="headerlink" title="三、参考资料"></a>三、参考资料</h2><p><a href="https://mariadb.com/kb/en/library/mariadb-audit-plugin-log-settings/" target="_blank" rel="noopener">MariaDB Audit Plugin 官方文档</a><br><a href="http://www.mysqldbaservices.com/2016/03/11/mysql-mariadb-audit-plugin-installation-and-configuration/" target="_blank" rel="noopener">MYSQL-MARIADB AUDIT PLUGIN INSTALLATION AND CONFIGURATION</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、安装MariaDB-Audit-Plugin&quot;&gt;&lt;a href=&quot;#一、安装MariaDB-Audit-Plugin&quot; class=&quot;headerlink&quot; title=&quot;一、安装MariaDB Audit Plugin&quot;&gt;&lt;/a&gt;一、安装MariaDB Au
      
    
    </summary>
    
    
    
      <category term="log" scheme="https://www.delta1037.cn/tags/log/"/>
    
  </entry>
  
  <entry>
    <title>CentOS 6安装gitlab服务端</title>
    <link href="https://www.delta1037.cn/2019/Deploy/CentOS-6%E5%AE%89%E8%A3%85gitlab%E6%9C%8D%E5%8A%A1%E7%AB%AF/"/>
    <id>https://www.delta1037.cn/2019/Deploy/CentOS-6安装gitlab服务端/</id>
    <published>2019-10-18T07:58:34.000Z</published>
    <updated>2019-10-18T09:00:51.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、配置基础环境"><a href="#一、配置基础环境" class="headerlink" title="一、配置基础环境"></a>一、配置基础环境</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">yum install openssh-server</span><br><span class="line">yum install postfix</span><br><span class="line">service postfix start</span><br><span class="line">chkconfig postfix on</span><br></pre></td></tr></table></figure><h2 id="二、下载安装gitlab"><a href="#二、下载安装gitlab" class="headerlink" title="二、下载安装gitlab"></a>二、下载安装gitlab</h2><p>gitlab安装包下载地址：<br>centos 6系统的下载地址:<a href="https://mirrors.tuna.tsinghua.edu.cn/gitlab-ce/yum/el6" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/gitlab-ce/yum/el6</a><br>centos 7系统的下载地址:<a href="https://mirrors.tuna.tsinghua.edu.cn/gitlab-ce/yum/el7" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/gitlab-ce/yum/el7</a><br>安装：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -i gitlab-ce-9.5.9-ce.0.el6.x86_64.rpm</span><br></pre></td></tr></table></figure></p><h2 id="三、配置gitlab"><a href="#三、配置gitlab" class="headerlink" title="三、配置gitlab"></a>三、配置gitlab</h2><p>修改gitlab配置文件指定服务器ip和自定义端口，将external_url后面的值修改为<a href="http://ip:port（例如http://192.168.7.89:8010，如果不指定端口则是默认的端口80）" target="_blank" rel="noopener">http://ip:port（例如http://192.168.7.89:8010，如果不指定端口则是默认的端口80）</a><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/gitlab/gitlab.rb</span><br></pre></td></tr></table></figure></p><p>如果服务端开启了防火墙，则需要开放相应的端口<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -I INPUT -p tcp --dport 8010 -j ACCEPT</span><br></pre></td></tr></table></figure></p><p>按照新的配置文件重新配置gitlab，并重新启动<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gitlab-ctl reconfigure</span><br><span class="line">gitlab-ctl restart</span><br></pre></td></tr></table></figure></p><p>查看gitlab运行状态<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">gitlab-ctl status</span><br><span class="line"></span><br><span class="line"><span class="comment"># 得到如下输出</span></span><br><span class="line">run: gitaly: (pid 10798) 24009s; run: <span class="built_in">log</span>: (pid 4490) 24327s</span><br><span class="line">run: gitlab-monitor: (pid 10820) 24009s; run: <span class="built_in">log</span>: (pid 5099) 24297s</span><br><span class="line">run: gitlab-workhorse: (pid 10824) 24008s; run: <span class="built_in">log</span>: (pid 4654) 24321s</span><br><span class="line">run: logrotate: (pid 24622) 2407s; run: <span class="built_in">log</span>: (pid 4894) 24309s</span><br><span class="line">run: nginx: (pid 10887) 24007s; run: <span class="built_in">log</span>: (pid 4803) 24315s</span><br><span class="line">run: node-exporter: (pid 10896) 24007s; run: <span class="built_in">log</span>: (pid 5007) 24303s</span><br><span class="line">run: postgres-exporter: (pid 10908) 24006s; run: <span class="built_in">log</span>: (pid 5383) 24279s</span><br><span class="line">run: postgresql: (pid 10918) 24006s; run: <span class="built_in">log</span>: (pid 3780) 24391s</span><br><span class="line">run: prometheus: (pid 10926) 24005s; run: <span class="built_in">log</span>: (pid 5271) 24285s</span><br><span class="line">run: redis: (pid 10943) 24005s; run: <span class="built_in">log</span>: (pid 3615) 24398s</span><br><span class="line">run: redis-exporter: (pid 10947) 24005s; run: <span class="built_in">log</span>: (pid 5181) 24291s</span><br><span class="line">run: sidekiq: (pid 10959) 24004s; run: <span class="built_in">log</span>: (pid 4393) 24333s</span><br><span class="line">run: unicorn: (pid 10987) 24003s; run: <span class="built_in">log</span>: (pid 4292) 24339s</span><br></pre></td></tr></table></figure></p><h3 id="bug0-GLIBC-2-14’-not-found"><a href="#bug0-GLIBC-2-14’-not-found" class="headerlink" title="bug0:`GLIBC_2.14’ not found"></a>bug0:`GLIBC_2.14’ not found</h3><p>如果出现报错/lib64/libc.so.6: version `GLIBC_2.14’ not found，则需要升级glibc<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下载安装包</span></span><br><span class="line">wget http://ftp.gnu.org/gnu/glibc/glibc-2.14.tar.gz</span><br><span class="line">tar zxvf glibc-2.14.tar.gz</span><br><span class="line"><span class="built_in">cd</span> glibc-2.14</span><br><span class="line">mkdir build</span><br><span class="line"><span class="built_in">cd</span> build</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译安装</span></span><br><span class="line">../configure --prefix=/opt/glibc-2.14</span><br><span class="line">make -j4</span><br><span class="line">make install</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置链接库目录</span></span><br><span class="line"><span class="built_in">export</span> LD_LIBRARY_PATH=/opt/glibc-2.14/lib</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、配置基础环境&quot;&gt;&lt;a href=&quot;#一、配置基础环境&quot; class=&quot;headerlink&quot; title=&quot;一、配置基础环境&quot;&gt;&lt;/a&gt;一、配置基础环境&lt;/h2&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td cla
      
    
    </summary>
    
    
      <category term="服务器" scheme="https://www.delta1037.cn/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
      <category term="gitlab" scheme="https://www.delta1037.cn/tags/gitlab/"/>
    
  </entry>
  
  <entry>
    <title>Install Oracle Database 9i on CentOS 5 (i386)</title>
    <link href="https://www.delta1037.cn/2019/Deploy/Install-Oracle-Database-9i-on-CentOS-5-i386/"/>
    <id>https://www.delta1037.cn/2019/Deploy/Install-Oracle-Database-9i-on-CentOS-5-i386/</id>
    <published>2019-10-14T03:17:38.000Z</published>
    <updated>2019-10-18T08:39:41.000Z</updated>
    
    <content type="html"><![CDATA[<p>Oracle Database 9i的官方安装环境为RHEL3，RHEL4。由于项目需要，需要同时安装Oracle Database 9i和日志采集工具rsyslog，rsyslog仅支持RHEL/CENTOS 5及其以上的版本，最终在<a href="http://archive.kernel.org/centos-vault/5.0/isos/i386/" target="_blank" rel="noopener">CentOS 5 (i386)</a>版本上安装成功。</p><h2 id="一、软件下载："><a href="#一、软件下载：" class="headerlink" title="一、软件下载："></a>一、软件下载：</h2><ol><li>Oracle9i Database Release 2 Enterprise/Standard Edition for Intel Linux（ship_9204_linux_disk）：<a href="http://stararly.com/DataBase/3432.html" target="_blank" rel="noopener">迅雷</a> <a href="https://pan.baidu.com/s/1cqR1YYu9aBGxq1Kq4AtNvA" target="_blank" rel="noopener">百度网盘提取码：ve9y</a></li><li><p>补丁：</p></li><li><p><a href="http://oss.oracle.com/projects/compat-oracle/dist/files/RedHat/compat-libcwait-2.1-1.i386.rpm" target="_blank" rel="noopener">compat-libcwait-2.1-1.i386.rpm</a></p></li><li><p><a href="http://oss.oracle.com/projects/compat-oracle/dist/files/RedHat/compat-oracle-rhel4-1.0-5.i386.rpm" target="_blank" rel="noopener">compat-oracle-rhel4-1.0-5.i386.rpm</a></p></li><li><p><a href="https://www.oracle.com/java/technologies/java-archive-javase-v13-downloads.html" target="_blank" rel="noopener">j2re-1_3_1_19-linux-i586.bin</a></p></li></ol><h2 id="二、开始安装"><a href="#二、开始安装" class="headerlink" title="二、开始安装"></a>二、开始安装</h2><h3 id="1、关闭SELinux"><a href="#1、关闭SELinux" class="headerlink" title="1、关闭SELinux"></a>1、关闭SELinux</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gedit /etc/selinux/config</span><br><span class="line"><span class="built_in">set</span> SELINUX=disabled</span><br></pre></td></tr></table></figure><h3 id="2、-安装JRE"><a href="#2、-安装JRE" class="headerlink" title="2、 安装JRE"></a>2、 安装JRE</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">chmod +x j2re-1_3_1_19-linux-i586.bin</span><br><span class="line">./j2re-1_3_1_19-linux-i586.bin</span><br><span class="line">mv jre1.3.1_19 /usr/<span class="built_in">local</span>/</span><br></pre></td></tr></table></figure><h3 id="3、安装缺少的依赖"><a href="#3、安装缺少的依赖" class="headerlink" title="3、安装缺少的依赖"></a>3、安装缺少的依赖</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 检查依赖缺失</span></span><br><span class="line">rpm -q compat-db compat-gcc-34 compat-gcc-34-c++ \</span><br><span class="line">  compat-libgcc-296 compat-libstdc++-296 compat-libstdc++-33 \</span><br><span class="line">  gcc gcc-c++ glibc glibc-common glibc-devel glibc-headers libgcc make libXp</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用yum安装依赖</span></span><br><span class="line">yum install compat-db*</span><br><span class="line">yum install compat-gcc*</span><br><span class="line">yum install gcc*</span><br><span class="line">yum install compat-libgcc*</span><br><span class="line">yum install compat-libstdc++*</span><br><span class="line">yum install gnome-libs*</span><br><span class="line">yum install libaio*</span><br><span class="line">yum install openmotif*</span><br><span class="line">yum install xorg-x11-deprecated-libs*</span><br><span class="line">yum install glibc-devel*</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装补丁</span></span><br><span class="line">rpm -Uvh compat-libcwait-2.1-1.i386.rpm</span><br><span class="line">rpm -Uvh compat-oracle-rhel4-1.0-5.i386.rpm --nodeps</span><br></pre></td></tr></table></figure><h3 id="4、配置环境"><a href="#4、配置环境" class="headerlink" title="4、配置环境"></a>4、配置环境</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/lib</span><br><span class="line">ln -s libstdc++-3-libc6.2-2-2.10.0.so libstdc++-libc6.1-1.so.2</span><br><span class="line">ln -s libgdbm.so.2.0.0 libdb.so.2</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> /usr/bin</span><br><span class="line">ln -s gcc34 gcc32</span><br></pre></td></tr></table></figure><h3 id="5、添加oracle组和用户"><a href="#5、添加oracle组和用户" class="headerlink" title="5、添加oracle组和用户"></a>5、添加oracle组和用户</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">groupadd oinstall <span class="comment">#添加oinstall组</span></span><br><span class="line">groupadd dba <span class="comment"># 添加dba组</span></span><br><span class="line">useradd -g oinstall -G dba oracle <span class="comment">#新建用户并添加到组</span></span><br><span class="line">passwd oracle <span class="comment">#按照输出设置密码</span></span><br></pre></td></tr></table></figure><h3 id="6、建立安装目录"><a href="#6、建立安装目录" class="headerlink" title="6、建立安装目录"></a>6、建立安装目录</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /opt</span><br><span class="line">mkdir oracle <span class="comment"># 创建oracle目录</span></span><br><span class="line">chown –R oracle.oinstall oracle <span class="comment">#修改oracle目录权限</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> oracle</span><br><span class="line">mkdir 920 <span class="comment"># 创建9i安装目录</span></span><br></pre></td></tr></table></figure><h3 id="7、-配置环境变量和系统设置"><a href="#7、-配置环境变量和系统设置" class="headerlink" title="7、 配置环境变量和系统设置"></a>7、 配置环境变量和系统设置</h3><p>以oracle用户登陆，打开/u01/oracle/.bash_profile，在文件末尾追加如下内容<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ORACLE_BASE=/opt/oracle; <span class="built_in">export</span> ORACLE_BASE</span><br><span class="line">ORACLE_HOME=<span class="variable">$ORACLE_BASE</span>/920; <span class="built_in">export</span> ORACLE_HOME</span><br><span class="line">ORACLE_SID=orcl; <span class="built_in">export</span> ORACLE_SID</span><br><span class="line">LD_LIBRARY_PATH=<span class="variable">$ORACLE_HOME</span>/lib; <span class="built_in">export</span> LD_LIBRARY_PATH</span><br><span class="line">ORACLE_OEM_JAVARUNTIME=/usr/<span class="built_in">local</span>/jre1.3.1_19; <span class="built_in">export</span> ORACLE_OEM_JAVARUNTIME</span><br><span class="line">PATH=<span class="variable">$PATH</span>:<span class="variable">$ORACLE_HOME</span>/bin; <span class="built_in">export</span> PATH</span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$USER</span> = <span class="string">"oracle"</span> ]; <span class="keyword">then</span></span><br><span class="line">  <span class="keyword">if</span> [ <span class="variable">$SHELL</span> = <span class="string">"/bin/ksh"</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">ulimit</span> -p 16384</span><br><span class="line">    <span class="built_in">ulimit</span> -n 65536</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">ulimit</span> -u 16384 -n 65536</span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure></p><p>以root用户登陆，打开/etc/sysctl.conf，在文件末尾追加如下内容，并执行sysctl -p生效<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">kernel.shmmni = 4096</span><br><span class="line">kernel.sem = 250 32000 100 128</span><br><span class="line">fs.file-max = 65536</span><br><span class="line">net.ipv4.ip_local_port_range = 1024 65000</span><br><span class="line">net.core.rmem_default=262144</span><br><span class="line">net.core.wmem_default=262144</span><br><span class="line">net.core.rmem_max=262144</span><br><span class="line">net.core.wmem_max=262144</span><br></pre></td></tr></table></figure></p><p>打开/etc/security/limits.conf，在文件末尾追加如下内容<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">oracle soft nofile 65536</span><br><span class="line">oracle hard nofile 65536</span><br><span class="line">oracle soft nproc 16384</span><br><span class="line">oracle hard nproc 16384</span><br></pre></td></tr></table></figure></p><h3 id="8、文件准备"><a href="#8、文件准备" class="headerlink" title="8、文件准备"></a>8、文件准备</h3><p>a）从网上下载oracle Database 9i有三个文件<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ship_9204_linux_disk1.cpio.gz</span><br><span class="line">ship_9204_linux_disk2.cpio.gz</span><br><span class="line">ship_9204_linux_disk3.cpio.gz</span><br></pre></td></tr></table></figure></p><p>b）对压缩文件解压<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gunzip ship_9204_linux_disk1.cpio.gz</span><br><span class="line">gunzip ship_9204_linux_disk2.cpio.gz</span><br><span class="line">gunzip ship_9204_linux_disk3.cpio.gz</span><br></pre></td></tr></table></figure></p><p>c）使用如下命令解压得到Disk1、Disk2和Disk3文件夹<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cpio -idmv &lt; ship_9204_linux_disk1.cpio</span><br><span class="line">cpio -idmv &lt; ship_9204_linux_disk2.cpio</span><br><span class="line">cpio -idmv &lt; ship_9204_linux_disk3.cpio</span><br></pre></td></tr></table></figure></p><h3 id="9、-开始安装"><a href="#9、-开始安装" class="headerlink" title="9、 开始安装"></a>9、 开始安装</h3><p>进入Disk1目录，执行./ runInstaller开始图形界面的安装程序，选择自己喜欢的版本进行安装，一路next就可以</p><h4 id="备注："><a href="#备注：" class="headerlink" title="备注："></a>备注：</h4><p>1、终端界面可能出现Inside isCluster, bCluster bfr return is : false，不影响后续使用<br>2、在最后的configuration阶段会发生错误如下</p><p><img src="https://upload-images.jianshu.io/upload_images/8198886-0cc151fcc8904b9e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>此时退出安装程序，进行如下操作</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> <span class="variable">$ORACLE_HOME</span></span><br><span class="line">rm JRE</span><br><span class="line">ln -s <span class="variable">$ORACLE_BASE</span>/jre/1.3.1 JRE</span><br><span class="line"><span class="built_in">cd</span> JRE/bin</span><br><span class="line">ln -s java jre</span><br><span class="line"><span class="built_in">cd</span> i386/native_threads/</span><br><span class="line">ln -s java jre</span><br></pre></td></tr></table></figure><p>然后再执行./ runInstaller走一遍安装流程即可</p><h2 id="三、使用"><a href="#三、使用" class="headerlink" title="三、使用"></a>三、使用</h2><h3 id="1、建立数据库"><a href="#1、建立数据库" class="headerlink" title="1、建立数据库"></a>1、建立数据库</h3><p>进入/u01/oracle/product/bin目录，运行dbca命令，进入建立数据库的图形界面，根据界面提示进行操作</p><h3 id="2、使用过程中可能会遇到的问题"><a href="#2、使用过程中可能会遇到的问题" class="headerlink" title="2、使用过程中可能会遇到的问题"></a>2、使用过程中可能会遇到的问题</h3><p>a）startup 出现LRM-00109: could not open parameter file …：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /opt/oracle /admin/sxf/pfile <span class="comment">#sxf是dbca新建的数据库名</span></span><br><span class="line">cp init.ora.* /opt/oracle/920/dbs/initmyoracle.ora</span><br></pre></td></tr></table></figure></p><p>b）startup出现ORA-01990: error opening password file ‘/opt/oracle/920/dbs/orapw’<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /opt/oracle/920/bin</span><br><span class="line">orapwd file=/opt/oracle/920/dbs/orapw passwd=sxf123 entries=1024</span><br></pre></td></tr></table></figure></p><h2 id="四、个人经验"><a href="#四、个人经验" class="headerlink" title="四、个人经验"></a>四、个人经验</h2><p>1、以CentOS 5（x86_64）无法完成amd64_db_9204_Disk1.cpio.gz的安装<br>2、以CentOS 4（x86_64）可以完成amd64_db_9204_Disk1.cpio.gz的安装</p><h2 id="五、参考文献"><a href="#五、参考文献" class="headerlink" title="五、参考文献"></a>五、参考文献</h2><p>1、<a href="http://nirajkvinit.blogspot.com/2008/10/installing-oracle-9i-on-rhel5.html" target="_blank" rel="noopener">Installing Oracle 9i on RHEL5. (x86)</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Oracle Database 9i的官方安装环境为RHEL3，RHEL4。由于项目需要，需要同时安装Oracle Database 9i和日志采集工具rsyslog，rsyslog仅支持RHEL/CENTOS 5及其以上的版本，最终在&lt;a href=&quot;http://arc
      
    
    </summary>
    
    
      <category term="环境配置" scheme="https://www.delta1037.cn/categories/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    
    
      <category term="Oracle Database 9i" scheme="https://www.delta1037.cn/tags/Oracle-Database-9i/"/>
    
      <category term="CentOS 5" scheme="https://www.delta1037.cn/tags/CentOS-5/"/>
    
  </entry>
  
  <entry>
    <title>Linux启动过程分析</title>
    <link href="https://www.delta1037.cn/2019/Linux/Linux%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/"/>
    <id>https://www.delta1037.cn/2019/Linux/Linux启动过程分析/</id>
    <published>2019-10-14T03:09:25.000Z</published>
    <updated>2019-10-14T03:16:23.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第一阶段-BIOS"><a href="#第一阶段-BIOS" class="headerlink" title="第一阶段-BIOS"></a>第一阶段-BIOS</h2><p>计算机通电后，首先会区读取ROM芯片中的开机程序（基本输入输出系统/BIOS）</p><h3 id="1-1-硬件自检"><a href="#1-1-硬件自检" class="headerlink" title="1.1 硬件自检"></a>1.1 硬件自检</h3><p>BIOS程序首先检查计算机硬件是否满足运行的基本条件–<strong>硬件自检</strong>（POST）</p><p>CMOS：存储硬件的各项参数。</p><h3 id="1-2-启动顺序"><a href="#1-2-启动顺序" class="headerlink" title="1.2 启动顺序"></a>1.2 启动顺序</h3><p>硬件自检完成后，BIOS把控制权交给下一阶段的启动程序。</p><p>这时，BIOS需要知道下一阶段的启动程序在哪个设备，也就是BIOS需要有一个外部存储设备排序，排在前边的设备就是优先转交控制权的设备。这个排序叫<strong>启动顺序</strong>。</p><h2 id="第二阶段-主引导记录"><a href="#第二阶段-主引导记录" class="headerlink" title="第二阶段-主引导记录"></a>第二阶段-主引导记录</h2><p>BIOS把控制权交给排在第一位的存储设备。</p><p>计算机读取此设备的第一个扇区（最前边的512个字节，叫做<strong>主引导记录</strong><master boot record，缩写为**mbr**>），如果这个扇区最后两个字节是0x55和0xAA，表明设备可以启动；如果不是，表明设备不能启动，控制权交给启动顺序中的下一个 设备。</master></p><h3 id="2-1-主引导记录结构"><a href="#2-1-主引导记录结构" class="headerlink" title="2.1 主引导记录结构"></a>2.1 主引导记录结构</h3><table><thead><tr><th>范围/字节</th><th>作用</th></tr></thead><tbody><tr><td>1-446</td><td>调用操作系统的机器码</td></tr><tr><td>447-510</td><td>分区表：将磁盘分为若干个区</td></tr><tr><td>511-512</td><td>主引导记录签名</td></tr></tbody></table><h3 id="2-2-分区表"><a href="#2-2-分区表" class="headerlink" title="2.2 分区表"></a>2.2 分区表</h3><p>考虑到每个区可以安装不同的操作系统，主引导记录必须知道将控制权交给哪个区。</p><p>分区表长度有64个字节，里面分为四项（所以一个硬盘最多有四个一级分区，又叫主分区），每一项16个字节</p><p>主分区16个字节组成：</p><table><thead><tr><th>范围/字节</th><th>作用</th></tr></thead><tbody><tr><td>1-1</td><td>如果为0x80，就表示该分区是激活分区，控制权要交给这个分区。四个分区里面只能有一个是激活的</td></tr><tr><td>2-4</td><td>主分区第一个扇区的物理位置（柱面、磁头、扇区号）</td></tr><tr><td>5-5</td><td>主分区类型</td></tr><tr><td>6-8</td><td>主分区最后一个扇区的物理位置</td></tr><tr><td>9-12</td><td>该主分区第一个扇区的逻辑地址</td></tr><tr><td>13-16</td><td>主分区的扇区总数</td></tr></tbody></table><h2 id="第三阶段-硬盘启动"><a href="#第三阶段-硬盘启动" class="headerlink" title="第三阶段-硬盘启动"></a>第三阶段-硬盘启动</h2><p>这时，计算机的控制权就交给了硬盘的某个分区了</p><h3 id="3-1-情况A：卷引导记录"><a href="#3-1-情况A：卷引导记录" class="headerlink" title="3.1 情况A：卷引导记录"></a>3.1 情况A：卷引导记录</h3><p>计算机会读取激活分区的第一个扇区，叫做卷引导记录（Volume boot record，VBR）</p><p>卷引导记录告诉计算机，操作系统在这个分区的位置。然后计算机就会加载操作系统了。</p><h3 id="3-2-情况B：扩展分区和逻辑分区"><a href="#3-2-情况B：扩展分区和逻辑分区" class="headerlink" title="3.2 情况B：扩展分区和逻辑分区"></a>3.2 情况B：扩展分区和逻辑分区</h3><p>随着硬盘越来越大，四个分区已经不够了，需要更多分区。于是规定有一个分区可以定义为扩展分区（里面又分了好多个区，叫逻辑分区）。</p><p>计算机首先读取扩展分区的第一个扇区，叫扩展引导记录（EBR）。它里面包含一张64字节的分区表，但是最多只有两项（也就是两个逻辑分区，包括它自身的分区表和下一个分区的分区表）。从里面找到第二个逻辑分区的位置，直到找到一个分区里面只包含它自己的分区表为止。</p><h3 id="3-3-情况C：启动管理器"><a href="#3-3-情况C：启动管理器" class="headerlink" title="3.3 情况C：启动管理器"></a>3.3 情况C：启动管理器</h3><p>在这种情况下，计算机读取主引导记录前446个字节的机器码之后，不把控制权交给某一个分区，而是运行启动管理器（boot loader），由用户选择启动哪一个操作系统。</p><p>Linux环境中，最流行的启动管理器是Grub。</p><h2 id="第四阶段-操作系统"><a href="#第四阶段-操作系统" class="headerlink" title="第四阶段-操作系统"></a>第四阶段-操作系统</h2><p>控制权交给操作系统之后，操作系统的内核首先载入内存。</p><p>所有进程的祖先叫进程0，idle进程，或者由于历史的原因叫做swapper进程。</p><p>start_kernel()函数初始化内核需要的所有数据结构，激活终端，创建另一个叫做进程1的内核线程（一般叫做init进程），创建init进程之后，进程0执行cpu_idle()函数，该函数本质上是在开中断的情况下重复之星hlt汇编指令。当 没有其他进程处于TASK_RUNNING才选择执行进程0。</p><p><strong>多处理器系统</strong>中每个CPU都有一个进程0，计算机启动之后首先启动一个CPU，禁用其他CPU，swapper进程进程初始化内核数据结构，通过copy_process()函数创建另外的swapper进程。</p><p>进程0创建的内核线程执行init()函数，init()依次完成内核初始化。init()调用execve()系统调用装入可执行程序init，结果init内核线程变成了一个普通进程。</p><p>以Linux系统为例，首先载入/boot目录下面的kernel。内核加载成功后（如上），第一个运行的程序是/sbin/init，它根据配置文件产生init进程，pid进程编号为1，其它进程都是它的后代。</p><p>然后init进程加载系统的各个模块，比如窗口和网络程序，直到/bin/login程序，跳出登录页面。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol><li><a href="http://www.ruanyifeng.com/blog/2013/02/booting.html" target="_blank" rel="noopener">计算机是如何启动的</a></li><li>深入理解Linux内核</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;第一阶段-BIOS&quot;&gt;&lt;a href=&quot;#第一阶段-BIOS&quot; class=&quot;headerlink&quot; title=&quot;第一阶段-BIOS&quot;&gt;&lt;/a&gt;第一阶段-BIOS&lt;/h2&gt;&lt;p&gt;计算机通电后，首先会区读取ROM芯片中的开机程序（基本输入输出系统/BIOS）&lt;/p
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.delta1037.cn/categories/Linux/"/>
    
    
      <category term="Linux启动" scheme="https://www.delta1037.cn/tags/Linux%E5%90%AF%E5%8A%A8/"/>
    
  </entry>
  
  <entry>
    <title>点石成金，挥刀琢玉——“双创老太”刘玉那些事儿</title>
    <link href="https://www.delta1037.cn/2019/DianGroup/%E8%8B%B1%E9%9B%84%E4%BC%9A%E5%88%98%E8%80%81%E5%B8%88%E4%BB%8B%E7%BB%8D/"/>
    <id>https://www.delta1037.cn/2019/DianGroup/英雄会刘老师介绍/</id>
    <published>2019-08-21T11:14:55.000Z</published>
    <updated>2019-10-18T08:56:41.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="点石成金，挥刀琢玉——“双创老太”刘玉那些事儿"><a href="#点石成金，挥刀琢玉——“双创老太”刘玉那些事儿" class="headerlink" title="点石成金，挥刀琢玉——“双创老太”刘玉那些事儿"></a>点石成金，挥刀琢玉——“双创老太”刘玉那些事儿</h1><p>   高调、爱折腾、不走寻常路、犀利、“毒舌”、超级大忙人，她是被贴满标签的华中大教授——刘玉老师。而其中最响亮，最广为人知的标签，一定非“双创老太”莫属。今天，让我们走近这神秘的刘玉教授，说一说，她的那些事儿——</p><p><span style="font-size:20px;color:white;background-color: red;font-weight:bold;">她是谁——</span></p><ul><li>湖北省创业红娘众创空间        负责人</li><li>武汉创业红娘公益服务中心     理事长 </li><li>华中科技大学    电信学院      教   授 </li><li>华中科技大学    Dian团队      创始人 </li></ul><hr><p><span style="font-size:20px;color:white;background-color: red;font-weight:bold;">她都做过什么——</span></p><p><span style="font-size:16px;color:red;font-weight:bold;">扶弟子创新</span></p><p>   曾指导本科生获全国挑战杯特等奖，Dian团队育人模式获国家教学成果二等奖，教育部大学生创新性实验计划的“源头”之一，央视小崔说事栏目曾以“点亮未来”专题报道，曾应邀到全国高校、中学、企事业等逾百家单位作创新创业报告，引起强烈反响。曾获评“全国师德先进个人”和湖北省“五一劳动奖章”、湖北省教育系统“三育人”奖、 宝钢优秀教师特等奖的提名奖、两次获华中科技大学教学质量优秀一等奖。<br>     在她严格要求和精心培养下，Dian团队出站队员500多人在社会上总体表现优异，近7年涌现出50余家创业公司，其中贝贝网和贝店已成为独角兽，释码大华、ping++、悦然心动等创业公司业绩斐然，4人荣登福布斯中国30位“30岁以下创业者”榜单。</p><p><span style="font-size:16px;color:red;font-weight:bold;">帮他人创业</span></p><p>  2015年3月，刘玉创办“武汉市洪山区创业红娘公益服务中心”，义务为优秀创业项目与投资机构牵线搭桥，创业项目的甄选范围从华中科技大学在校生拓宽至全社会，不分地域、不分年龄、不分学校、不分学历。至今，经刘玉老师推荐的创业项目已超过500个，融资成交率13.2%，促成投资总额2.57亿元。</p><hr><p><span style="font-size:20px;color:white;background-color: red;font-weight:bold;">她的那些事儿——</span></p><ul><li><a href="http://szbold.cjn.cn/cjrb/html/2015-12/25/content_5498033.htm" target="_blank" rel="noopener"><span style="color:red;font-size:18px;">刘玉:创客点睛手——《长江日报》</span></a></li></ul><ul><li><a href="https://www.chsi.com.cn/jyzx/200711/20071108/1493323.html" target="_blank" rel="noopener"><span style="color:orange;font-size:18px;">创新潜能在实践中尽情释放——《中国教育报》网络版</span></a></li></ul><ul><li><a href="http://hb.people.com.cn/n2/2016/0115/c337099-27552249.html" target="_blank" rel="noopener"><span style="color:red;font-size:18px;">人民网专访“创业红娘”刘玉：如何做到人靠谱、事落实、有情怀</span></a></li></ul><ul><li><a href="http://zqb.cyol.com/html/2016-01/19/nw.D110000zgqnb_20160119_2-10.htm" target="_blank" rel="noopener"><span style="color:orange;font-size:18px;">刘玉：被“强推转身”的创业红娘——《中国青年报》</span></a></li></ul><ul><li><a href="http://cjrb.cjn.cn/html/2018-04/04/content_67430.htm" target="_blank" rel="noopener"><span style="color:red;font-size:18px;">全国布撒“姻缘线”的“创业红娘” ——武汉首个创业服务公益机构实录——《长江日报》</span></a></li></ul><ul><li><a href="http://news.cnhubei.com/xw//sh/201604/t3592740.shtml" target="_blank" rel="noopener"><span style="color:orange;font-size:18px;">武汉女教授入选“中国好人” 免费孵出50多家公司——荆楚网</span></a></li></ul><ul><li><a href="http://hb.people.com.cn/n2/2017/0526/c337099-30246043.html" target="_blank" rel="noopener"><span style="color:red;font-size:18px;">华科Dian团队15年走出10余家“过亿”企业——人民网</span></a></li></ul><ul><li><a href="http://cppcc.people.com.cn/GB/35377/11493611.html" target="_blank" rel="noopener"><span style="color:orange;font-size:18px;">崔永元“说事”设“圈套” 女教授均“化险为夷”——中国政协新闻网</span> </a></li></ul><ul><li><a href="http://www.cnki.com.cn/Article/CJFDTotal-DYXS201409005.htm" target="_blank" rel="noopener"><span style="color:red;font-size:18px;">“点”下种子——访谈华中科技大学“点团队”创始人刘玉教授——《大学生》</span></a></li></ul><ul><li><a href="https://www.chsi.com.cn/jyzx/200711/20071108/1493323.html" target="_blank" rel="noopener"><span style="color:orange;font-size:18px;">华科创客点睛手刘玉讲述：张小龙在武汉首提微信产品观——荆楚网</span></a></li></ul><ul><li><a href="http://hustxb.cuepa.cn/show_more.php?tkey=&amp;bkey=&amp;doc_id=235846" target="_blank" rel="noopener"><span style="color:red;font-size:18px;">刘延东寄语Dian团队———在实践中释放创新潜能</span></a></li></ul><ul><li><a href="http://zqb.cyol.com/html/2014-06/26/nw.D110000zgqnb_20140626_3-07.htm" target="_blank" rel="noopener"><span style="color:orange;font-size:18px;">华中科大教授刘玉：人才标准固化扼杀大学生创新热情——《中国青年报》</span></a></li></ul><ul><li><a href="http://archive.wenming.cn/jddzhr/2010-04/02/content_19412216_2.htm" target="_blank" rel="noopener"><span style="color:red;font-size:18px;">华中科技大学刘玉教授：未来工程师“点”亮江城 </span></a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;点石成金，挥刀琢玉——“双创老太”刘玉那些事儿&quot;&gt;&lt;a href=&quot;#点石成金，挥刀琢玉——“双创老太”刘玉那些事儿&quot; class=&quot;headerlink&quot; title=&quot;点石成金，挥刀琢玉——“双创老太”刘玉那些事儿&quot;&gt;&lt;/a&gt;点石成金，挥刀琢玉——“双创老太”
      
    
    </summary>
    
    
      <category term="Dian团队" scheme="https://www.delta1037.cn/categories/Dian%E5%9B%A2%E9%98%9F/"/>
    
    
      <category term="点石" scheme="https://www.delta1037.cn/tags/%E7%82%B9%E7%9F%B3/"/>
    
  </entry>
  
  <entry>
    <title>编译总结</title>
    <link href="https://www.delta1037.cn/2019/C_C++/compile/"/>
    <id>https://www.delta1037.cn/2019/C_C++/compile/</id>
    <published>2019-08-03T11:16:31.000Z</published>
    <updated>2019-10-18T08:37:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="编译"><a href="#编译" class="headerlink" title="编译"></a><a href="http://39.96.162.190/compile_img/compile.pdf" target="_blank" rel="noopener">编译</a></h1><hr><h2 id="一、系统环境"><a href="#一、系统环境" class="headerlink" title="一、系统环境"></a>一、系统环境</h2><ul><li><p>CPU：Intel(R) Core(TM) i5-5200U CPU @ 2.20GHz</p></li><li><p>操作系统：Ubuntu 18.04.2 LTS</p></li><li>内核版本：Linux version 4.18.0-25-generic</li><li>GNU GCC版本：gcc version 7.4.0 (Ubuntu 7.4.0-1ubuntu1~18.04.1)<ul><li>C standard revision：C11</li><li><strong>GNU Compiled BY</strong><ul><li>GMP version： 6.1.2</li><li>MPFR version ：4.0.1</li><li>MPC version ： 1.1.0</li><li>isl version ： isl-0.19-GMP</li></ul></li></ul></li><li><p>GNU 汇编器版本：2.30 (x86_64-linux-gnu) using BFD version (GNU Binutils for Ubuntu) 2.30</p></li><li><p>链接器版本：</p><ul><li><a href="https://gcc.gnu.org/onlinedocs/gccint/Collect2.html" target="_blank" rel="noopener">collect2</a> version：7.4.0 <ul><li>gcc一般是collect2,而不是ld，collect2 是ld链接器的一个封装，最终还是调用ld来完成链接工作</li><li>collect2通过<strong>第一次链接</strong>程序查看链接器输出文件来查找具有特定名称表明是构造函数的符号，如果找得到则会创建一个新的临时‘.c’文件包含这些符号，然后编译这个文件并<strong>第二次链接</strong>程序.The program collect2 works by linking the program once and looking through the linker output file for symbols with particular names indicating they are constructor functions. If it finds any, it creates a new temporary ‘.c’ file containing a table of them, compiles it, and links the program a second time including that file.）</li></ul></li><li>GNU ld (GNU Binutils for Ubuntu)：2.30</li></ul></li></ul><h2 id="二、GCC编译过程"><a href="#二、GCC编译过程" class="headerlink" title="二、GCC编译过程"></a>二、GCC编译过程</h2><h3 id="2-1-GCC编译过程"><a href="#2-1-GCC编译过程" class="headerlink" title="2.1 GCC编译过程"></a>2.1 GCC编译过程</h3><p><img src="http://39.96.162.190/compile_img/编译过程-简单.png" alt="编译过程-简单"></p><ol><li><p>预处理</p><ul><li>删除所有的#define，展开所有的宏定义</li><li>处理所有的条件预编译指令&lt;#if,#endif,#ifdef,#ifndef,#elif,#else&gt;</li><li>处理#include预编译指令，将包含的文件插入到include的位置（递归进行）</li><li>删除所有的注释</li><li>添加行号和文件名标识（调试时使用）</li><li>保留所有的#pragma编译器指令（编译器需要使用这些指令）</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 单独产生预处理后的文件（本模块假设hello.c是源代码程序,hello.i是hello.c预处理后的文件,hello.s是hello.c编译后的文件，hello.o是hello.c汇编后的文件，hello是hello.c最终的可执行程序）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用gcc命令产生预处理文件</span></span><br><span class="line">$ gcc -E hello.c -o hello.i</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用cpp命令产生预处理文件</span></span><br><span class="line">$ cpp hello.c &gt; hello.i</span><br></pre></td></tr></table></figure></li><li><p>编译：将预处理完的文件进行一系列的词法分析、语法分析、语义分析、中间代码生成、目标代码生成与优化之后产生相应的汇编代码文件</p><ul><li>词法分析：扫描器运行类似于有限状态机的算法将代码的字符序列分割成一系列的记号</li><li>语法分析：语法分析器对扫描器产生的记号进行语法分析，从而产生语法树（以表达式为节点的树）</li><li>语义分析：语义分析器确定语句的意义（比如两个指针做乘法是没有意义的），编译器只能分析静态语义（在编译时能够确定的语义，通常包括声明和类型的匹配，类型的转换；与之相对的动态语义是在运行时才能确定的语义，例如将0作为除数是一个运行期语义错误）</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 编译预处理后的文件产生汇编代码文件</span></span><br><span class="line">$ gcc -S hello.i -o hello.s</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译源文件产生汇编代码文件</span></span><br><span class="line">$ gcc -S hello.c -o hello.s</span><br><span class="line"></span><br><span class="line"><span class="comment"># 现在的gcc编译器将预处理和编译两个步骤合成了一个步骤，使用一个叫cc1的程序来完成这个过程</span></span><br><span class="line">$ /usr/lib/gcc/x86_64-linux-gnu/7/cc1 hello.c -o hello.s</span><br></pre></td></tr></table></figure></li><li><p>汇编：将汇编代码转变成机器可以执行的指令（根据汇编指令和机器指令的对照表一一翻译）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用as处理汇编文件产生目标文件</span></span><br><span class="line">$ as hello.s -o hello.o</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用gcc处理汇编文件产生目标文件</span></span><br><span class="line">$ gcc -c hello.s -o hello.o</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用gcc处理源文件产生目标文件</span></span><br><span class="line">$ gcc -c hello.c -o hello.o</span><br></pre></td></tr></table></figure></li><li><p>链接：将目标文件链接到一起形成可执行文件,主要包括地址和空间分配，符号决议，和重定位等步骤</p><ul><li><p>符号决议：也叫做符号绑定、名称绑定、名称决议等等。从细节上来讲，决议更倾向于静态链接，绑定更倾向与动态链接</p></li><li><p>重定位：编译一个文件时不知道一个要调用的函数或者需要操作的一个变量的地址，就会把这些调用函数或者操作变量的指令目标地址搁置，等到最后链接的时候由链接器去将这些指令的目标地址修正，这个地址修正的过程也被叫做<strong>重定位</strong>，每一个需要修正的地方叫做<strong>重定位入口</strong>。</p></li></ul></li></ol><h3 id="2-2-实际编译过程"><a href="#2-2-实际编译过程" class="headerlink" title="2.2 实际编译过程"></a>2.2 实际编译过程</h3><ol><li><p>使用如下样例，包含hello.c和func.c两个源文件（之后也是用这两个文件进行分析）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* hello.c：主测试程序，包括全局静态变量，局部静态变量，全局变量，局部变量，基本的函数调用 */</span></span><br><span class="line"><span class="comment">// export var</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> export_func_var;</span><br><span class="line"></span><br><span class="line"><span class="comment">// global var</span></span><br><span class="line"><span class="keyword">int</span> global_uninit_var;</span><br><span class="line"><span class="keyword">int</span> global_init_var_0 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> global_init_var_1 = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// const var</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *const_string_var = <span class="string">"const string"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// static global var</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> static_global_uninit_var;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> static_global_init_var_0 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> static_global_init_var_1 = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// func header</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func_call_test</span><span class="params">(<span class="keyword">int</span> num)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="comment">// local var</span></span><br><span class="line">    <span class="keyword">int</span> local_uninit_var;</span><br><span class="line">    <span class="keyword">int</span> local_init_var_0 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> local_init_var_1 = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// static local var</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> static_local_uninit_var;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> static_local_init_var_0 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> static_local_init_var_1 = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// call func</span></span><br><span class="line">    func_call_test(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// export var op</span></span><br><span class="line">    export_func_var = export_func_var * <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* func.c：包含一个简单的被调用函数和一个全局变量 */</span></span><br><span class="line"><span class="keyword">int</span> export_func_var = <span class="number">666</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func_call_test</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> double_num = num * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用<code>gcc -v hello.c func.c</code>编译生成可执行文件a.out，产生如下输出（简化版本）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[delta@delta: code ]$ gcc -v func.c hello.c</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对func.c的预处理和编译过程</span></span><br><span class="line">/usr/lib/gcc/x86_64-linux-gnu/7/cc1 func.c -o /tmp/ccfC6J5E.s</span><br><span class="line"><span class="comment"># 对func.c产生的.s文件汇编产生二进制文件</span></span><br><span class="line">as -v --64 -o /tmp/ccF4Bar0.o /tmp/ccfC6J5E.s</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对hello.c的预处理和编译过程</span></span><br><span class="line">/usr/lib/gcc/x86_64-linux-gnu/7/cc1 hello.c -o /tmp/ccfC6J5E.s</span><br><span class="line"><span class="comment"># 对hello.c产生的.s文件汇编产生二进制文件</span></span><br><span class="line">as -v --64 -o /tmp/cc7UmhQl.o /tmp/ccfC6J5E.s</span><br><span class="line"></span><br><span class="line"><span class="comment"># 链接过程</span></span><br><span class="line">/usr/lib/gcc/x86_64-linux-gnu/7/collect2 -dynamic-linker ld-linux-x86-64.so.2 Scrt1.o crti.o crtbeginS.o /tmp/ccF4Bar0.o /tmp/cc7UmhQl.o crtendS.o crtn.o</span><br></pre></td></tr></table></figure></li></ol><h2 id="三、链接过程解析"><a href="#三、链接过程解析" class="headerlink" title="三、链接过程解析"></a>三、链接过程解析</h2><p><strong>Q:</strong></p><ul><li><p>目标文件的格式是怎样的？</p></li><li><p>多个目标是如何链接到一起的？</p></li></ul><h3 id="3-1-目标文件"><a href="#3-1-目标文件" class="headerlink" title="3.1 目标文件"></a>3.1 目标文件</h3><h4 id="3-1-1目标文件类型"><a href="#3-1-1目标文件类型" class="headerlink" title="3.1.1目标文件类型"></a>3.1.1目标文件类型</h4><ul><li>Window下的PE（Portable Executable）</li><li>Linux下的ELF（Executable Linkable Format）</li></ul><p><em>注：</em></p><ol><li><em>PE和ELF格式都是COFF（Common file format）格式的变种</em></li><li><em>目标文件与可执行文件的内容和结构类似，所以一般采用相同的格式存储。广义上来可以将目标文件和可执行文件看做是同一种类型的文件，在window下统称它们为PE-COFF文件格式，在Linux下统称它们为ELF文件。</em></li><li><em>不止是可执行文件按照可执行文件格式存储，动态链接库（DLL，Dynamic Linking Library）（Window的.dll和Linux的.so）以及静态链接库（Static Linking Library）（Window的.lib和Linux的.a）文件都按照可执行文件的格式存储。（静态链接库稍有不同，它是把很多的目标文件捆绑在一起形成一个文件，再加上一些索引。可以理解为一个包含很多目标文件的文件包）</em></li></ol><h4 id="3-1-2-ELF文件类型"><a href="#3-1-2-ELF文件类型" class="headerlink" title="3.1.2 ELF文件类型"></a>3.1.2 ELF文件类型</h4><table><thead><tr><th style="text-align:left">ELF文件类型</th><th style="text-align:left">说明</th><th>实例</th></tr></thead><tbody><tr><td style="text-align:left">可重定位文件（Relocatable File）</td><td style="text-align:left">包含代码和数据，可以被用来链接成可执行文件或者共享目标文件，静态链接库可以归为这一类</td><td>Linux的.o，Window下的.obj</td></tr><tr><td style="text-align:left">可执行文件（Executable File）</td><td style="text-align:left">包含可以直接执行的程序，一般没有扩展名</td><td>Linux的/bin/bash文件，Window的.exe</td></tr><tr><td style="text-align:left">共享目标文件（Shared Object File）</td><td style="text-align:left">包含代码和数据，链接器可以上映这种文件与其他可重定位文件和共享目标文件进行链接产生新的目标文件；动态链接器可以将几个共享目标文件与可执行文件结合，作为进程映像的一部分来运行</td><td>Linux的.so，Window的.dll</td></tr><tr><td style="text-align:left">核心转储文件（Core Dump File）</td><td style="text-align:left">进程意外终止时，系统将该进程的地址空间的内容以及终止时的其它信息转储到核心转储文件</td><td>Linux下的core dump</td></tr></tbody></table><h4 id="3-1-3目标文件结构"><a href="#3-1-3目标文件结构" class="headerlink" title="3.1.3目标文件结构"></a>3.1.3目标文件结构</h4><p>目标文件中包含编译后的指令代码、数据，还包括了链接时需要的一些信息（符号表，调试信息和字符串等），一般目标文件将这些信息按照不同的属性，以<strong>节（Section）</strong>的形式存储（有时也称为<strong>段（Segment)</strong>）。如下图所示</p><p><img src="http://39.96.162.190/compile_img/ELF%E7%BB%93%E6%9E%84.png" alt="ELF结构"></p><h5 id="3-1-3-1常见的段"><a href="#3-1-3-1常见的段" class="headerlink" title="3.1.3.1常见的段"></a>3.1.3.1<strong>常见的段</strong></h5><table><thead><tr><th style="text-align:left">段名</th><th>说明</th></tr></thead><tbody><tr><td style="text-align:left">.text/.code</td><td>代码段，编译后的机器指令</td></tr><tr><td style="text-align:left">.data</td><td>数据段，全局变量和局部静态变量</td></tr><tr><td style="text-align:left">.bss</td><td>未初始化的全局变量和局部静态变量（.bss段只是为未初始化的全局变量和局部静态变量预留位置）</td></tr><tr><td style="text-align:left">.rodata</td><td>只读信息段</td></tr><tr><td style="text-align:left">.rodata1</td><td>存放只读数据，字符串常量，全局const变量。与.rodata一样</td></tr><tr><td style="text-align:left">.comment</td><td>编译器版本信息</td></tr><tr><td style="text-align:left">.debug</td><td>调试信息</td></tr><tr><td style="text-align:left">.dynamic</td><td>动态链接信息</td></tr><tr><td style="text-align:left">.hash</td><td>符号哈希表</td></tr><tr><td style="text-align:left">.line</td><td>调试时的行号表，即源代码行号与编译后的指令的对应表</td></tr><tr><td style="text-align:left">.note</td><td>额外的编译器信息。程序的公司名，发布版本号</td></tr><tr><td style="text-align:left">.strtab</td><td>String Table，字符串表，用来存储ELF文件中用到的各种字符串</td></tr><tr><td style="text-align:left">.symtab</td><td>Symbol Table，符号表</td></tr><tr><td style="text-align:left">.shstrtab</td><td>Section String Table，段名表</td></tr><tr><td style="text-align:left">.plt/.got</td><td>动态链接的跳转表和全局入口表</td></tr><tr><td style="text-align:left">.init/.fini</td><td>程序初始化与终结代码段</td></tr></tbody></table><h5 id="3-1-3-2目标文件结构分析"><a href="#3-1-3-2目标文件结构分析" class="headerlink" title="3.1.3.2目标文件结构分析"></a>3.1.3.2目标文件结构分析</h5><ol><li><p>ELF文件头：</p><ul><li><p>使用<code>gcc -c hello.c -o hello.o</code>生成目标文件hello.o，并使用<code>readelf -h hello.o</code>读取目标文件的ELF文件头，可以看出ELF文件头定义了<strong>ELF魔数、文件机器字节长度、数据存储方式、版本，运行平台、ABI版本、ELF重定位类型、硬件平台、硬件平台版本、入口地址、程序入口和长度、段表的位置和长度及段的数量</strong>等，如下图所示</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">ELF Header:</span><br><span class="line">  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 </span><br><span class="line">  Class:                             ELF64</span><br><span class="line">  Data:                              2<span class="string">'s complement, little endian</span></span><br><span class="line"><span class="string">  Version:                           1 (current)</span></span><br><span class="line"><span class="string">  OS/ABI:                            UNIX - System V</span></span><br><span class="line"><span class="string">  ABI Version:                       0</span></span><br><span class="line"><span class="string">  Type:                              REL (Relocatable file)</span></span><br><span class="line"><span class="string">  Machine:                           Advanced Micro Devices X86-64</span></span><br><span class="line"><span class="string">  Version:                           0x1</span></span><br><span class="line"><span class="string">  Entry point address:               0x0</span></span><br><span class="line"><span class="string">  Start of program headers:          0 (bytes into file)</span></span><br><span class="line"><span class="string">  Start of section headers:          1328 (bytes into file)</span></span><br><span class="line"><span class="string">  Flags:                             0x0</span></span><br><span class="line"><span class="string">  Size of this header:               64 (bytes)</span></span><br><span class="line"><span class="string">  Size of program headers:           0 (bytes)</span></span><br><span class="line"><span class="string">  Number of program headers:         0</span></span><br><span class="line"><span class="string">  Size of section headers:           64 (bytes)</span></span><br><span class="line"><span class="string">  Number of section headers:         15</span></span><br><span class="line"><span class="string">  Section header string table index: 14</span></span><br></pre></td></tr></table></figure></li><li><p>ELF文件头结构体定义在/usr/include/elf.h中，目标文件hello.o的文件头中机器字节长度为ELF64，找到64位版本文件头结构体Elf64_Ehdr定义，如下所示</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span>e_ident[EI_NIDENT];<span class="comment">/* Magic number and other info */</span></span><br><span class="line">  Elf64_Halfe_type;<span class="comment">/* Object file type */</span></span><br><span class="line">  Elf64_Halfe_machine;<span class="comment">/* Architecture */</span></span><br><span class="line">  Elf64_Worde_version;<span class="comment">/* Object file version */</span></span><br><span class="line">  Elf64_Addre_entry;<span class="comment">/* Entry point virtual address */</span></span><br><span class="line">  Elf64_Offe_phoff;<span class="comment">/* Program header table file offset */</span></span><br><span class="line">  Elf64_Offe_shoff;<span class="comment">/* Section header table file offset */</span></span><br><span class="line">  Elf64_Worde_flags;<span class="comment">/* Processor-specific flags */</span></span><br><span class="line">  Elf64_Halfe_ehsize;<span class="comment">/* ELF header size in bytes */</span></span><br><span class="line">  Elf64_Halfe_phentsize;<span class="comment">/* Program header table entry size */</span></span><br><span class="line">  Elf64_Halfe_phnum;<span class="comment">/* Program header table entry count */</span></span><br><span class="line">  Elf64_Halfe_shentsize;<span class="comment">/* Section header table entry size */</span></span><br><span class="line">  Elf64_Halfe_shnum;<span class="comment">/* Section header table entry count */</span></span><br><span class="line">  Elf64_Halfe_shstrndx;<span class="comment">/* Section header string table index */</span></span><br><span class="line">&#125; Elf64_Ehdr;</span><br></pre></td></tr></table></figure></li><li><p>除结构体中的e_ident对应到readelf输出的从Magic到ABI Version部分，其它都是一一对应关系</p></li><li><p><code>e_shstrndx</code>变量表示<code>.shstrtab</code>在段表中的下标</p></li></ul></li></ol><ol start="2"><li><p>段表</p><ul><li><p>使用<code>gcc -c hello.c -o hello.o</code>生成目标文件hello.o，并使用<code>readelf -S hello.o</code>读取目标文件的段表部分</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">Section Headers:</span><br><span class="line">  [Nr] Name              Type             Address           Offset</span><br><span class="line">       Size              EntSize          Flags  Link  Info  Align</span><br><span class="line">  [ 0]                   NULL             0000000000000000  00000000</span><br><span class="line">       0000000000000000  0000000000000000           0     0     0</span><br><span class="line">  [ 1] .text             PROGBITS         0000000000000000  00000040</span><br><span class="line">       0000000000000035  0000000000000000  AX       0     0     1</span><br><span class="line">  [ 2] .rela.text        RELA             0000000000000000  00000440</span><br><span class="line">       0000000000000048  0000000000000018   I      12     1     8</span><br><span class="line">  [ 3] .data             PROGBITS         0000000000000000  00000078</span><br><span class="line">       000000000000000c  0000000000000000  WA       0     0     4</span><br><span class="line">  [ 4] .bss              NOBITS           0000000000000000  00000084</span><br><span class="line">       0000000000000014  0000000000000000  WA       0     0     4</span><br><span class="line">  [ 5] .rodata           PROGBITS         0000000000000000  00000084</span><br><span class="line">       000000000000000d  0000000000000000   A       0     0     1</span><br><span class="line">  [ 6] .data.rel.local   PROGBITS         0000000000000000  00000098</span><br><span class="line">       0000000000000008  0000000000000000  WA       0     0     8</span><br><span class="line">  [ 7] .rela.data.rel.lo RELA             0000000000000000  00000488</span><br><span class="line">       0000000000000018  0000000000000018   I      12     6     8</span><br><span class="line">  [ 8] .comment          PROGBITS         0000000000000000  000000a0</span><br><span class="line">       000000000000002c  0000000000000001  MS       0     0     1</span><br><span class="line">  [ 9] .note.GNU-stack   PROGBITS         0000000000000000  000000cc</span><br><span class="line">       0000000000000000  0000000000000000           0     0     1</span><br><span class="line">  [10] .eh_frame         PROGBITS         0000000000000000  000000d0</span><br><span class="line">       0000000000000038  0000000000000000   A       0     0     8</span><br><span class="line">  [11] .rela.eh_frame    RELA             0000000000000000  000004a0</span><br><span class="line">       0000000000000018  0000000000000018   I      12    10     8</span><br><span class="line">  [12] .symtab           SYMTAB           0000000000000000  00000108</span><br><span class="line">       0000000000000240  0000000000000018          13    16     8</span><br><span class="line">  [13] .strtab           STRTAB           0000000000000000  00000348</span><br><span class="line">       00000000000000f6  0000000000000000           0     0     1</span><br><span class="line">  [14] .shstrtab         STRTAB           0000000000000000  000004b8</span><br><span class="line">       0000000000000076  0000000000000000           0     0     1</span><br><span class="line">Key to Flags:</span><br><span class="line">  W (write), A (alloc), X (execute), M (merge), S (strings), I (info),</span><br><span class="line">  L (link order), O (extra OS processing required), G (group), T (TLS),</span><br><span class="line">  C (compressed), x (unknown), o (OS specific), E (exclude),</span><br><span class="line">  l (large), p (processor specific)</span><br></pre></td></tr></table></figure></li><li><p>段表结构体定义在/usr/include/elf.h中，目标文件hello.o的文件头中机器字节长度为ELF64，找到64位版本段表结构体定义Elf64_Shdr（每个Elf64_Shdr对应一个段，Elf64_Shdr又称为<strong>段描述符<section descriptor></section></strong>），如下所示</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Elf64_Wordsh_name;<span class="comment">/* Section name (string tbl index) */</span></span><br><span class="line">  Elf64_Wordsh_type;<span class="comment">/* Section type */</span></span><br><span class="line">  Elf64_Xwordsh_flags;<span class="comment">/* Section flags */</span></span><br><span class="line">  Elf64_Addrsh_addr;<span class="comment">/* Section virtual addr at execution */</span></span><br><span class="line">  Elf64_Offsh_offset;<span class="comment">/* Section file offset */</span></span><br><span class="line">  Elf64_Xwordsh_size;<span class="comment">/* Section size in bytes */</span></span><br><span class="line">  Elf64_Wordsh_link;<span class="comment">/* Link to another section */</span></span><br><span class="line">  Elf64_Wordsh_info;<span class="comment">/* Additional section information */</span></span><br><span class="line">  Elf64_Xwordsh_addralign;<span class="comment">/* Section alignment */</span></span><br><span class="line">  Elf64_Xwordsh_entsize;<span class="comment">/* Entry size if section holds table */</span></span><br><span class="line">&#125; Elf64_Shdr;</span><br></pre></td></tr></table></figure></li><li><p>Elf64_Shdr部分成员解释</p></li></ul></li></ol><table><thead><tr><th>变量名</th><th>说明</th></tr></thead><tbody><tr><td>sh_name</td><td>段名是一个字符串，位于一个叫.shstrtab的字符串表中，sh_name是段名字符串在.shstrtab中的偏移</td></tr><tr><td>sh_addr</td><td>段虚拟地址，如果该段可以加载，sh_addr为该段被加载后在进程地址空间的虚拟地址，否则为0</td></tr><tr><td>sh_offset</td><td>段偏移，如果该段存在于文件中则表示该段在文件中的偏移，否则无意义</td></tr><tr><td>sh_link、sh_info</td><td>段链接信息，如果该段的类型是与链接相关的，则该字段有意义</td></tr><tr><td>sh_addralign</td><td>段地址对齐，sh_addralign表示是地址对齐数量的指数，如果sh_addralign为0或者1则该段没有字节对齐要求</td></tr><tr><td>sh_entsize</td><td>对于一些段包含了一些固定大小的项，比如符号表，则sh_entsize表示每个项的大小</td></tr></tbody></table><ol start="3"><li>重定位表：hello.o中包含一个<code>.rela.text</code>的段，类型为RELA，它是一个重定位表。链接器在处理目标文件时必须对文件中的某些部位进行重定位，这些重定位信息都记录在重定位表中。对于每个需要重定位的代码段或者数据段，都会有一个相应的重定位表。</li></ol><ol start="4"><li><p>字符串表</p><ul><li><p>.strtab：字符串表，保存普通的字符串，比如符号的名字</p></li><li><p>.shstrtab：段表字符串表，保存段表中用到的字符串，比如段名</p></li></ul></li></ol><p>   <strong>结论：ELF文件头中的<code>e_shstrndx</code>变量表示<code>.shstrtab</code>在段表中的下标，<code>e_shoff</code>表示段表在文件中的偏移，只有解析ELF文件头，就可以得到段表和段表字符串表的位置，从而解析整个ELF文件</strong></p><h4 id="3-1-4-链接的接口——符号"><a href="#3-1-4-链接的接口——符号" class="headerlink" title="3.1.4 链接的接口——符号"></a>3.1.4 链接的接口——符号</h4><h5 id="3-1-4-1-符号定义"><a href="#3-1-4-1-符号定义" class="headerlink" title="3.1.4.1 符号定义"></a>3.1.4.1 符号定义</h5><ol><li><p><strong>定义：</strong>在链接中，目标文件之间相互拼合实际上是目标文件之间对地址的引用，即对函数和变量地址的引用。在链接中，将函数和变量统称为<strong>符号（Symbol）</strong>，函数名或变量名称为<strong>符号名（Symbol Name）</strong>。</p></li><li><p>每个目标文件都有一个符号表记录了目标文件中用到的所有符号（每个定义的符号都有一个符号值，对于函数和变量来说，符号值就是它们的地址），<strong>常见分类</strong>如下</p></li></ol><table><thead><tr><th>符号类型</th><th>说明</th></tr></thead><tbody><tr><td>定义在本目标文件中的全局符号</td><td>可以被其它目标文件引用的符号</td></tr><tr><td>在本目标文件中引用的符号，却没有定义在本目标文件中</td><td>外部符号（External Symbol）</td></tr><tr><td>段名，由编译器产生</td><td>它的值就是该段的起始地址</td></tr><tr><td>局部符号</td><td>只在编译单元内部可见，链接器往往忽略它们</td></tr><tr><td>行号信息</td><td>目标文件指令与代码行的对应关系，可选</td></tr></tbody></table><h5 id="3-1-4-2-符号结构分析"><a href="#3-1-4-2-符号结构分析" class="headerlink" title="3.1.4.2 符号结构分析"></a>3.1.4.2 符号结构分析</h5><ul><li><p>符号表结构：符号表结构体定义在/usr/include/elf.h中，如下所示</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Elf64_Wordst_name;<span class="comment">/* Symbol name (string tbl index) */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span>st_info;<span class="comment">/* Symbol type and binding */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span> st_other;<span class="comment">/* Symbol visibility */</span></span><br><span class="line">  Elf64_Sectionst_shndx;<span class="comment">/* Section index */</span></span><br><span class="line">  Elf64_Addrst_value;<span class="comment">/* Symbol value */</span></span><br><span class="line">  Elf64_Xwordst_size;<span class="comment">/* Symbol size */</span></span><br><span class="line">&#125; Elf64_Sym;</span><br></pre></td></tr></table></figure><p>Elf64_Sym成员解释</p></li></ul><table><thead><tr><th>变量名</th><th>说明</th></tr></thead><tbody><tr><td>st_name</td><td>符号名在字符串表中的下标</td></tr><tr><td>st_info</td><td>符号类型和绑定信息</td></tr><tr><td>st_other</td><td>符号可见性</td></tr><tr><td>st_shndx</td><td>符号所在的段</td></tr><tr><td>st_value</td><td>符号对应的值</td></tr><tr><td>st_size</td><td>符号大小</td></tr></tbody></table><ul><li><p>使用<code>gcc -c hello.c -o hello.o</code>生成目标文件hello.o，并使用<code>readelf -s hello.o</code>读取目标文件的符号表部分</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Symbol table <span class="string">'.symtab'</span> contains 24 entries:</span><br><span class="line">   Num:    Value          Size Type    Bind   Vis      Ndx Name</span><br><span class="line">     0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND </span><br><span class="line">     1: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS hello.c</span><br><span class="line">     2: 0000000000000000     0 SECTION LOCAL  DEFAULT    1 </span><br><span class="line">     3: 0000000000000000     0 SECTION LOCAL  DEFAULT    3 </span><br><span class="line">     4: 0000000000000000     0 SECTION LOCAL  DEFAULT    4 </span><br><span class="line">     5: 0000000000000000     0 SECTION LOCAL  DEFAULT    5 </span><br><span class="line">     6: 0000000000000000     0 SECTION LOCAL  DEFAULT    6 </span><br><span class="line">     7: 0000000000000004     4 OBJECT  LOCAL  DEFAULT    4 static_global_uninit_var</span><br><span class="line">     8: 0000000000000008     4 OBJECT  LOCAL  DEFAULT    4 static_global_init_var_0</span><br><span class="line">     9: 0000000000000004     4 OBJECT  LOCAL  DEFAULT    3 static_global_init_var_1</span><br><span class="line">    10: 0000000000000008     4 OBJECT  LOCAL  DEFAULT    3 static_local_init_var_1.1</span><br><span class="line">    11: 000000000000000c     4 OBJECT  LOCAL  DEFAULT    4 static_local_init_var_0.1</span><br><span class="line">    12: 0000000000000010     4 OBJECT  LOCAL  DEFAULT    4 static_local_uninit_var.1</span><br><span class="line">    13: 0000000000000000     0 SECTION LOCAL  DEFAULT    9 </span><br><span class="line">    14: 0000000000000000     0 SECTION LOCAL  DEFAULT   10 </span><br><span class="line">    15: 0000000000000000     0 SECTION LOCAL  DEFAULT    8 </span><br><span class="line">    16: 0000000000000004     4 OBJECT  GLOBAL DEFAULT  COM global_uninit_var</span><br><span class="line">    17: 0000000000000000     4 OBJECT  GLOBAL DEFAULT    4 global_init_var_0</span><br><span class="line">    18: 0000000000000000     4 OBJECT  GLOBAL DEFAULT    3 global_init_var_1</span><br><span class="line">    19: 0000000000000000     8 OBJECT  GLOBAL DEFAULT    6 const_string_var</span><br><span class="line">    20: 0000000000000000    53 FUNC    GLOBAL DEFAULT    1 main</span><br><span class="line">    21: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND _GLOBAL_OFFSET_TABLE_</span><br><span class="line">    22: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND func_call_test</span><br><span class="line">    23: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND export_func_var</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">注：</span><br><span class="line">1. static_global_uninit_var、static_local_init_var_0和static_local_uninit_var、static_global_init_var_0和global_init_var_0在bss段（因为初始化为0和不初始化是一样的）</span><br><span class="line">2. static_global_init_var_1、static_local_init_var_1和global_init_var_1在data段（初始化的全局变量）</span><br><span class="line">3. static变量的类型均为LOCAL，表明该符号只为该目标文件内部可见；非Static全局变量的类型为GLOBAL，表明该符号外部可见</span><br><span class="line">4. 在hello.c中引用了func_call_test和export_func_var符号，但是没有定义，所以它的Ndx是UND（注：<span class="built_in">export</span>一个变量但是并未使用则符号表中不会出现这个边浪符号信息；<span class="built_in">export</span>一个不存在的变量但是并未使用编译不会报错；<span class="built_in">export</span>一个不存在的变量并使用会报错 &lt;**注意系统环境**&gt; ）</span><br><span class="line">5. 未初始化的全局非静态变量global_uninit_var在COM块中</span><br><span class="line">6. const_string_var在.data.rel.local段中</span><br></pre></td></tr></table></figure></li><li><p>特殊符号：当使用<strong>链接器生成可执行文件时</strong>，会定义很多特殊的符号，这些符号并未在程序中定义，但是可以直接声明并引用它们</p></li></ul><h5 id="3-1-4-3-符号修饰与函数签名"><a href="#3-1-4-3-符号修饰与函数签名" class="headerlink" title="3.1.4.3 符号修饰与函数签名"></a>3.1.4.3 符号修饰与函数签名</h5><p>​        符号修饰与函数签名：在符号名前或者后面加上<code>_</code>修饰符号，防止与库文件和其它目标文件冲突。现在的linux下的GCC编译器中，默认情况下去掉了加上<code>_</code>这种方式，可以通过参数选项打开</p><ul><li><p>C++符号修饰：C++拥有类，继承，重载和命名空间等这些特性，导致符号管理更为复杂。例如重载的情况：函数名相同但是参数不一样。然后就有了符号修饰和符号改编的机制，使用函数签名（包括函数名，参数类型，所在的类和命名空间等信息）来识别不同的函数</p></li><li><p>C++符号修饰栗子</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">C2</span> &#123;</span></span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> N &#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">C</span> &#123;</span></span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">func</span><span class="params">(<span class="keyword">float</span> num)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> C::func(<span class="keyword">int</span> num)&#123;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> C::C2::func(<span class="keyword">int</span> num)&#123;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> N::func(<span class="keyword">int</span> num)&#123;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> N::C::func(<span class="keyword">int</span> num)&#123;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> int_res = func(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">float</span> float_var = <span class="number">1.1</span>;</span><br><span class="line">    <span class="keyword">float</span> float_res = func(float_var);</span><br><span class="line"></span><br><span class="line">    C class_C;</span><br><span class="line">    int_res = class_C.func(<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<code>g++ -c hello.cpp -o hello_cpp.o</code>编译产生目标文件hello_cpp.o，使用<code>readelf -a hello_cpp.o</code>查看目标文件中的符号表，如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Symbol table <span class="string">'.symtab'</span> contains 18 entries:</span><br><span class="line">   Num:    Value          Size Type    Bind   Vis      Ndx Name</span><br><span class="line">     0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND </span><br><span class="line">     1: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS hello.cpp</span><br><span class="line">     2: 0000000000000000     0 SECTION LOCAL  DEFAULT    1 </span><br><span class="line">     3: 0000000000000000     0 SECTION LOCAL  DEFAULT    3 </span><br><span class="line">     4: 0000000000000000     0 SECTION LOCAL  DEFAULT    4 </span><br><span class="line">     5: 0000000000000000     0 SECTION LOCAL  DEFAULT    5 </span><br><span class="line">     6: 0000000000000000     0 SECTION LOCAL  DEFAULT    7 </span><br><span class="line">     7: 0000000000000000     0 SECTION LOCAL  DEFAULT    8 </span><br><span class="line">     8: 0000000000000000     0 SECTION LOCAL  DEFAULT    6 </span><br><span class="line">     9: 0000000000000000    12 FUNC    GLOBAL DEFAULT    1 _Z4funci</span><br><span class="line">    10: 000000000000000c    16 FUNC    GLOBAL DEFAULT    1 _Z4funcf</span><br><span class="line">    11: 000000000000001c    16 FUNC    GLOBAL DEFAULT    1 _ZN1C4funcEi</span><br><span class="line">    12: 000000000000002c    16 FUNC    GLOBAL DEFAULT    1 _ZN1C2C24funcEi</span><br><span class="line">    13: 000000000000003c    12 FUNC    GLOBAL DEFAULT    1 _ZN1N4funcEi</span><br><span class="line">    14: 0000000000000048    16 FUNC    GLOBAL DEFAULT    1 _ZN1N1C4funcEi</span><br><span class="line">    15: 0000000000000058   119 FUNC    GLOBAL DEFAULT    1 main</span><br><span class="line">    16: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND _GLOBAL_OFFSET_TABLE_</span><br><span class="line">    17: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND __stack_chk_fail</span><br></pre></td></tr></table></figure><p>可以看出函数签名与修饰后的名称的对应关系</p></li></ul><table><thead><tr><th>函数签名</th><th>修饰后名称（符号名）</th></tr></thead><tbody><tr><td>int func(int)</td><td>_Z4funci</td></tr><tr><td>float func(float)</td><td>_Z4funcf</td></tr><tr><td>int C::func(int)</td><td>_ZN1C4funcEi</td></tr><tr><td>int C::C2::func(int)</td><td>_ZN1C2C24funcEi</td></tr><tr><td>int N::func(int)</td><td>_ZN1N4funcEi</td></tr><tr><td>int N::C::func(int)</td><td>_ZN1N1C4funcEi</td></tr></tbody></table><ul><li><p>extern “C”：C++编译器会将在extern C大括号内的内部代码当做C语言代码处理，也就是名称修饰机制将不会起作用。当需要兼容C和C++，例如在C++代码中调用C中的memset函数，可以使用C++的宏<code>__cplusplus</code>，C++在编译程序时会默认定义这个宏</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> “C” &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">memset</span><span class="params">(<span class="keyword">void</span> *, <span class="keyword">int</span>, <span class="keyword">size_t</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></li></ul><p>  由于<strong>不同的编译器采用不同的名字修饰方法</strong>，必然会导致不同编译器产生的目标文件无法正常互相链接，这是<strong>导致不同编译器之间不能互操作的原因</strong></p><h5 id="3-1-4-4-弱符号与强符号"><a href="#3-1-4-4-弱符号与强符号" class="headerlink" title="3.1.4.4 弱符号与强符号"></a>3.1.4.4 弱符号与强符号</h5><p>​        在编程中经常遇到符号重定义的问题，例如hello.c和func.c都定义了一个_global并将它们都初始化，在编译时就会报错。对于C/C++来说，编译器默认函数和初始化的全局变量为强符号，未初始化的全局变量为弱符号。</p><ul><li><p><strong>编译器处理符号规则</strong></p><ul><li>不允许强符号被多次定义</li><li>如果一个符号在一个文件中是强符号，在其它文件中是弱符号，则选择强符号</li><li>如果一个符号在所有的文件中都是弱符号，则选择其中占用空间最大的一个（int型和double型会选择double型）</li></ul></li><li><p><strong>弱引用与强引用</strong>：对外部目标文件中的符号引用在目标文件最终被链接成可执行文件时都哟啊被正确决议，如果没有找到该符号的定义，则会报未定义错误，这种被称为强引用；与之对应的弱引用，在处理弱引用时，如果该符号有定义，则链接器将该符号的引用决议；如果该符号未被定义，则链接器也不会报错。</p></li><li><p><strong>弱符号与弱引用的作用</strong>（对库来说很有用）</p><ul><li>库中定义的弱符号可以被用户定义的强符号所覆盖，从而使程序可以使用自定义版本的函数</li><li>程序可以对某些扩展功能模块的引用定义为弱引用，当扩展模块与程序链接到一起时，功能模块可以正常使用；如果去掉了某些功能模块，则程序也可以正常链接，只是缺少了相应的功能，这使得程序的功能更容易裁剪和组合</li></ul></li></ul><h3 id="3-2-静态链接"><a href="#3-2-静态链接" class="headerlink" title="3.2 静态链接"></a>3.2 静态链接</h3><h4 id="3-2-1-空间和地址分配"><a href="#3-2-1-空间和地址分配" class="headerlink" title="3.2.1 空间和地址分配"></a>3.2.1 空间和地址分配</h4><p>链接器在合并多个目标文件的段时，采用<strong>相似段合并</strong>的方式，并分配地址和空间（虚拟地址空间的分配）</p><p><strong>两步链接法：</strong></p><ol><li>空间和地址分配：扫描所有的目标文件，获得它们的各个段的长度、属性和位置，并且将输入目标文件中的符号表中所有的符号定义和符号引用收集起来，统一放到一个全局符号表，这一步中，链接器将能够获得所有输入目标文件的段长度，并将它们合并，计算输出文件中各个合并之后的段的长度，建立映射关系。</li><li>符号解析与重定位：使用空间和地址分配中收集到的所有信息，读取输入文件中段的数据、重定位信息，并且进行符号解析与重定位、调整代码中的地址等。</li></ol><p>当进行了空间和地址分配之后，各个段的虚拟地址也就确定了，由于各个符号在段内的位置是相对的，所以各个符号的地址也就确定了。</p><h4 id="3-2-2-符号解析与重定位"><a href="#3-2-2-符号解析与重定位" class="headerlink" title="3.2.2 符号解析与重定位"></a>3.2.2 符号解析与重定位</h4><ul><li><p>使用<code>gcc -c hello.c -o hello.o</code>生成目标文件hello.o，并使用<code>objdump -d hello.o</code>读取目标文件的<code>.text</code>的反汇编结果，如下所示（简略部分内容）；同理使用<code>gcc -c func.c -o func.o</code>生成目标文件func.o。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[delta@rabbit: c_code ]$ objdump -d hello.o</span><br><span class="line">Disassembly of section .text:</span><br><span class="line">0000000000000000 &lt;main&gt;:</span><br><span class="line">   0:55                   push   %rbp</span><br><span class="line">   1:48 89 e5             mov    %rsp,%rbp</span><br><span class="line">   4:48 83 ec 10          sub    <span class="variable">$0x10</span>,%rsp</span><br><span class="line">   8:c7 45 f8 00 00 00 00 movl   <span class="variable">$0x0</span>,-0x8(%rbp)</span><br><span class="line">   f:c7 45 <span class="built_in">fc</span> 01 00 00 00 movl   <span class="variable">$0x1</span>,-0x4(%rbp)</span><br><span class="line">  16:bf 08 00 00 00       mov    <span class="variable">$0x8</span>,%edi</span><br><span class="line">  1b:e8 00 00 00 00       callq  20 &lt;main+0x20&gt;</span><br><span class="line">  20:8b 05 00 00 00 00    mov    0x0(%rip),%eax        <span class="comment"># 26 &lt;main+0x26&gt;</span></span><br><span class="line">  26:01 c0                add    %eax,%eax</span><br><span class="line">  28:89 05 00 00 00 00    mov    %eax,0x0(%rip)        <span class="comment"># 2e &lt;main+0x2e&gt;</span></span><br><span class="line">  2e:b8 00 00 00 00       mov    <span class="variable">$0x0</span>,%eax</span><br><span class="line">  33:c9                   leaveq </span><br><span class="line">  34:c3                   retq</span><br></pre></td></tr></table></figure><p><strong>分析：</strong>由以上结果可以看出，在链接之前，main函数在调用func_call_test函数时，使用的地址是0x00000000，根据反汇编结果就是下一条指令（<code>e8 00 00 00 00</code>之中<code>e8</code>是callq的指令码，<code>00 00 00 00</code>是目的地址相对于下一条指令的偏移量）；在使用export_func_var变量时，编译器就将0x0看做是export_func_var的地址</p></li><li><p>使用<code>ld hello.o func.o -e main</code>链接两个目标文件，生成可执行文件a.out（并不能执行，因为缺少部分目标文件，但是符号已经被重新定位；<code>-e main</code>表示将main函数作为程序入口），使用<code>objdump -d a.out</code>查看a.out的<code>.text</code>段反汇编结果，如下图所示（简略部分内容）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">[delta@rabbit: c_code ]$ objdump -d a.out </span><br><span class="line">Disassembly of section .text:</span><br><span class="line">00000000004000e8 &lt;main&gt;:</span><br><span class="line">  4000e8:55                   push   %rbp</span><br><span class="line">  4000e9:48 89 e5             mov    %rsp,%rbp</span><br><span class="line">  4000ec:48 83 ec 10          sub    <span class="variable">$0x10</span>,%rsp</span><br><span class="line">  4000f0:c7 45 f8 00 00 00 00 movl   <span class="variable">$0x0</span>,-0x8(%rbp)</span><br><span class="line">  4000f7:c7 45 <span class="built_in">fc</span> 01 00 00 00 movl   <span class="variable">$0x1</span>,-0x4(%rbp)</span><br><span class="line">  4000fe:bf 08 00 00 00       mov    <span class="variable">$0x8</span>,%edi</span><br><span class="line">  400103:e8 15 00 00 00       callq  40011d &lt;func_call_test&gt;</span><br><span class="line">  400108:8b 05 0a 0f 20 00    mov    0x200f0a(%rip),%eax        <span class="comment"># 601018 &lt;export_func_var&gt;</span></span><br><span class="line">  40010e:01 c0                add    %eax,%eax</span><br><span class="line">  400110:89 05 02 0f 20 00    mov    %eax,0x200f02(%rip)        <span class="comment"># 601018 &lt;export_func_var&gt;</span></span><br><span class="line">  400116:b8 00 00 00 00       mov    <span class="variable">$0x0</span>,%eax</span><br><span class="line">  40011b:c9                   leaveq </span><br><span class="line">  40011c:c3                   retq   </span><br><span class="line"></span><br><span class="line">000000000040011d &lt;func_call_test&gt;:</span><br><span class="line">  40011d:55                   push   %rbp</span><br><span class="line">  40011e:48 89 e5             mov    %rsp,%rbp</span><br><span class="line">  400121:89 7d ec             mov    %edi,-0x14(%rbp)</span><br><span class="line">  400124:8b 45 ec             mov    -0x14(%rbp),%eax</span><br><span class="line">  400127:01 c0                add    %eax,%eax</span><br><span class="line">  400129:89 45 <span class="built_in">fc</span>             mov    %eax,-0x4(%rbp)</span><br><span class="line">  40012c:90                   nop</span><br><span class="line">  40012d:5d                   pop    %rbp</span><br><span class="line">  40012e:c3                   retq</span><br></pre></td></tr></table></figure><p>使用<code>nm a.out</code>查看a.out中的符号信息（简略），可以看到export_func_var的地址为0000000000601018</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[delta@rabbit: c_code ]$ nm a.out </span><br><span class="line">0000000000601018 D export_func_var</span><br></pre></td></tr></table></figure></li></ul><p>  <strong>分析：</strong>在链接之后，可以从反汇编中看出main函数的调用func_call_test函数的地方地址已经被修正为func_call_test真正的地址000000000040011d，使用export_func_var变量的地方的地址也修正为export_func_var真正的地址0000000000601018（在nm a.out输出的符号表中）。所以链接器在完成地址空间分配之后就可以确定所有符号的虚拟地址了，链接器就可以根据符号的地址对每个需要重定位的地方进行地址修正。</p><ul><li><p><strong>链接器如何知道哪些地址需要修正呢？</strong>有一个重定位表的结构专门保存与重定位相关的信息（比如<code>.text</code>如果有需要重定位的地方，那么就会有一个叫<code>.rela.text</code>的段保存了代码段的重定位信息），使用<code>objdump -r hello.o</code>查看重定位信息如下（简略），可以看到所有需要重定位的地方</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[delta@rabbit: c_code ]$ objdump -r hello.o </span><br><span class="line">RELOCATION RECORDS FOR [.text]:</span><br><span class="line">OFFSET           TYPE              VALUE </span><br><span class="line">000000000000001c R_X86_64_PLT32    func_call_test-0x0000000000000004</span><br><span class="line">0000000000000022 R_X86_64_PC32     export_func_var-0x0000000000000004</span><br><span class="line">000000000000002a R_X86_64_PC32     export_func_var-0x0000000000000004</span><br></pre></td></tr></table></figure></li><li><p><strong>符号解析：</strong>使用<code>nm hello.o</code>可以查看hello.o 中所有的符号信息，如下所示，可以看到export_func_var和func_call_test符号都是未定义状态（U）。所以档链接器扫描完所有的输入目标文件之后，所有的这些未定义的符号都能够在全局符号表中找到，否则就会报<strong>符号未定义（undefined reference to）</strong>错误。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 输出hello.o 中所有的符号信息</span></span><br><span class="line">[delta@rabbit: c_code ]$ nm hello.o </span><br><span class="line">0000000000000000 D const_string_var</span><br><span class="line">                 U export_func_var</span><br><span class="line">                 U func_call_test</span><br><span class="line">0000000000000000 B global_init_var_0</span><br><span class="line">0000000000000000 D global_init_var_1</span><br><span class="line">                 U _GLOBAL_OFFSET_TABLE_</span><br><span class="line">0000000000000004 C global_uninit_var</span><br><span class="line">0000000000000000 T main</span><br><span class="line">0000000000000008 b static_global_init_var_0</span><br><span class="line">0000000000000004 d static_global_init_var_1</span><br><span class="line">0000000000000004 b static_global_uninit_var</span><br><span class="line">000000000000000c b static_local_init_var_0.1809</span><br><span class="line">0000000000000008 d static_local_init_var_1.1810</span><br><span class="line">0000000000000010 b static_local_uninit_var.1808</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 符号未定义错误</span></span><br><span class="line">[delta@rabbit: c_code ]$ ld hello.o </span><br><span class="line">ld: warning: cannot find entry symbol _start; defaulting to 00000000004000e8</span><br><span class="line">hello.o: In <span class="keyword">function</span> `main<span class="string">':</span></span><br><span class="line"><span class="string">hello.c:(.text+0x1c): undefined reference to `func_call_test'</span></span><br><span class="line">hello.c:(.text+0x22): undefined reference to `export_func_var<span class="string">'</span></span><br><span class="line"><span class="string">hello.c:(.text+0x2a): undefined reference to `export_func_var'</span></span><br></pre></td></tr></table></figure></li><li><p><strong>指令修正方式：</strong>（<strong>A</strong>：保存正在修正位置的值；<strong>P</strong>：被修正的位置&lt;相对于段开始的偏移量或者虚拟地址&gt;；<strong>S</strong>：符号的实际地址；<strong>L</strong>：表示其索引位于重定位条目中的符号的值）<a href="http://www.ucw.cz/~hubicka/papers/abi/node19.html" target="_blank" rel="noopener">以下计算参考</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># hello.o中的重定位信息（简略）</span></span><br><span class="line">[delta@rabbit: c_code ]$ objdump -r hello.o </span><br><span class="line">RELOCATION RECORDS FOR [.text]:</span><br><span class="line">OFFSET           TYPE              VALUE </span><br><span class="line">000000000000001c R_X86_64_PLT32    func_call_test-0x0000000000000004</span><br><span class="line">0000000000000022 R_X86_64_PC32     export_func_var-0x0000000000000004</span><br><span class="line">000000000000002a R_X86_64_PC32     export_func_var-0x0000000000000004</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解析：</span></span><br><span class="line"><span class="comment"># 根据输出符号的重定位类型有R_X86_64_PLT32和R_X86_64_PC32</span></span><br><span class="line"><span class="comment"># R_X86_64_PLT32 ： L + A - P（绝对地址修正）</span></span><br><span class="line"><span class="comment"># R_X86_64_PC32： S + A - P（相对寻址修正）</span></span><br><span class="line"><span class="comment"># 其它方式参考：http://www.ucw.cz/~hubicka/papers/abi/node19.html</span></span><br></pre></td></tr></table></figure><ul><li>绝对地址修正：绝对地址修正后的地址为该符号的实际地址，例如调用func_call_test符号的地址被修正成为了绝对地址40011d</li><li>相对地址修正：相对地址修正后的地址为符号距离被修正位置的地址差，例如使用export_func_var符号的地址被修正成为了相对地址0x200f0a，mov指令（第一个mov指令）的下一条地址40010e加上这个偏移量0x200f0a就是export_func_var的绝对地址0x601018</li></ul></li><li><p><strong>COMMON块</strong>：根据<code>nm hello.o</code>的输出，如下所示（简略），可以看到global_uninit_var符号的类型为COMMON类型，<strong>编译器将未初始化的全局变量作为弱符号处理</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[delta@rabbit: c_code ]$ nm hello.o </span><br><span class="line">0000000000000004 C global_uninit_var</span><br></pre></td></tr></table></figure><p><strong>多个符号定义类型情况分析</strong></p><ul><li>两个或以上强符号类型不一致：报重定义错误</li><li>有一个强符号和多个弱符号：取强符号，若是有弱符号比强符号空间大的情况则编译时会出现warning</li><li>两个或者以上弱符号类型不一致：取占用空间最大的弱符号</li></ul><p><strong>注</strong>：当编译器将一个编译单元编译成目标文件时，如果该编译单元包含弱符号（未初始化或者初始化为0的全局变量是典型），那么<strong>该符号所占用的最终空间就是不确定的，所以编译器无法在该阶段为该符号在BSS段分配空间</strong>。但是经过链接之后，任何一个符号的大小都确定了，所以它可以在最终输出文件的BSS段为其分配空间。总体来看，未初始化的全局变量是放在BSS段的</p></li></ul><h4 id="3-2-3-静态库链接"><a href="#3-2-3-静态库链接" class="headerlink" title="3.2.3 静态库链接"></a>3.2.3 静态库链接</h4><ul><li><p><strong>定义</strong>：静态库可以简单地看做是一组目标文件的集合，即很多目标文件经过压缩打包后形成的一个文件（Linux上常用的C语言静态库libc位于/usr/lib/x86_64-linux-gnu/libc.a）</p></li><li><p><strong>静态链接过程</strong>：在链接过程中ld链接器会自动寻找所有需要的符号以及它们所在的目标文件，将这些目标文件从libc.a中“解压”出来，最终将它们链接到一起形成一个可执行文件。使用<code>gcc -v hello.c func.c</code>编译生成可执行文件a.out，可以看到详细的链接过程，产生如下输出（简化版本）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">[delta@delta: code ]$ gcc -v func.c hello.c</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对func.c的预处理和编译过程</span></span><br><span class="line">/usr/lib/gcc/x86_64-linux-gnu/7/cc1 func.c -o /tmp/ccfC6J5E.s</span><br><span class="line"><span class="comment"># 对func.c产生的.s文件汇编产生二进制文件</span></span><br><span class="line">as -v --64 -o /tmp/ccF4Bar0.o /tmp/ccfC6J5E.s</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对hello.c的预处理和编译过程</span></span><br><span class="line">/usr/lib/gcc/x86_64-linux-gnu/7/cc1 hello.c -o /tmp/ccfC6J5E.s</span><br><span class="line"><span class="comment"># 对hello.c产生的.s文件汇编产生二进制文件</span></span><br><span class="line">as -v --64 -o /tmp/cc7UmhQl.o /tmp/ccfC6J5E.s</span><br><span class="line"></span><br><span class="line"><span class="comment"># 链接过程</span></span><br><span class="line">/usr/lib/gcc/x86_64-linux-gnu/7/collect2 -dynamic-linker ld-linux-x86-64.so.2 Scrt1.o crti.o crtbeginS.o /tmp/ccF4Bar0.o /tmp/cc7UmhQl.o crtendS.o crtn.o</span><br><span class="line"></span><br><span class="line"><span class="comment">############################################</span></span><br><span class="line"><span class="comment"># 实际各个目标文件的位置</span></span><br><span class="line">/usr/lib/gcc/x86_64-linux-gnu/7/../../../x86_64-linux-gnu/Scrt1.o</span><br><span class="line">/usr/lib/gcc/x86_64-linux-gnu/7/../../../x86_64-linux-gnu/crti.o</span><br><span class="line">/usr/lib/gcc/x86_64-linux-gnu/7/crtbeginS.o</span><br><span class="line">/tmp/ccF4Bar0.o</span><br><span class="line">/tmp/cc7UmhQl.o</span><br><span class="line">/usr/lib/gcc/x86_64-linux-gnu/7/crtendS.o</span><br><span class="line">/usr/lib/gcc/x86_64-linux-gnu/7/../../../x86_64-linux-gnu/crtn.o</span><br></pre></td></tr></table></figure><p>可以看到Scrt1.o crti.o crtbeginS.o /tmp/ccF4Bar0.o /tmp/cc7UmhQl.o crtendS.o crtn.o被链接入了最终可执行文件</p><p><strong>各个文件的解释</strong>（<a href="https://stackoverflow.com/questions/16436035/whats-the-usage-of-mcrt1-o-and-scrt1-o" target="_blank" rel="noopener">来源</a>）</p></li></ul><table><thead><tr><th>目标文件</th><th>说明</th></tr></thead><tbody><tr><td>crt0.o</td><td>Older style of the initial runtime code ?  Usually not generated anymore  with Linux toolchains, but often found in bare metal toolchains.  Serves  same purpose as crt1.o (see below).</td></tr><tr><td>crt1.o</td><td>Newer style of the initial runtime code.  Contains the _start symbol which  sets up the env with argc/argv/libc _init/libc _fini before jumping to the  libc main.  glibc calls this file ‘start.S’.</td></tr><tr><td>crti.o</td><td>Defines the function prolog; _init in the .init section and _fini in the  .fini section.  glibc calls this ‘initfini.c’.</td></tr><tr><td>crtn.o</td><td>Defines the function epilog.  glibc calls this ‘initfini.c’.</td></tr><tr><td>scrt1.o</td><td>Used in place of crt1.o when generating PIEs.</td></tr><tr><td>gcrt1.o</td><td>Used in place of crt1.o when generating code with profiling information.  Compile with -pg.  Produces output suitable for the gprof util.</td></tr><tr><td>Mcrt1.o</td><td>Like gcrt1.o, but is used with the prof utility.  glibc installs this as  a dummy file as it’s useless on linux systems.</td></tr><tr><td>crtbegin.o</td><td>GCC uses this to find the start of the constructors.</td></tr><tr><td>crtbeginS.o</td><td>Used in place of crtbegin.o when generating shared objects/PIEs.</td></tr><tr><td>crtbeginT.o</td><td>Used in place of crtbegin.o when generating static executables.</td></tr><tr><td>crtend.o</td><td>GCC uses this to find the start of the destructors.</td></tr><tr><td>crtendS.o</td><td>Used in place of crtend.o when generating shared objects/PIEs.</td></tr></tbody></table><p>  <strong>通常链接顺序</strong>：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">crt1.o crti.o crtbegin.o [-L paths] [user objects] [gcc libs] [C libs] [gcc libs] crtend.o crtn.o</span><br></pre></td></tr></table></figure><ul><li><p><strong>链接过程控制</strong>：链接过程需要考虑很多内容：使用哪些目标文件？使用哪些库文件？是否保留调试信息、输出文件格式等等。</p><p><strong>链接器控制链接过程方法</strong>：</p><ul><li>使用命令行来给链接器指定参数</li><li>将链接器指令存放在目标文件里面，编译器通常会使用这种方式向链接器传递指令。</li><li>使用链接控制脚本</li></ul></li></ul><h4 id="3-2-4-BFD库简介"><a href="#3-2-4-BFD库简介" class="headerlink" title="3.2.4 BFD库简介"></a>3.2.4 BFD库简介</h4><ul><li><strong>定义</strong>：由于现代的硬件和软件平台种类繁多，每个平台都有不同的目标文件格式，导致编译器和链接器很难处理不同平台的目标文件。BFD库（Binary File Descriptor library）希望通过统一的接口来处理不同的目标文件格式。</li></ul><p>现代GCC（具体来讲是GNU 汇编器GAS）、链接器、调试器和GDB及binutils的其他工具都是通过BFD库来处理目标文件，而不是直接操作目标文件。</p><h3 id="3-3-装载与动态链接"><a href="#3-3-装载与动态链接" class="headerlink" title="3.3 装载与动态链接"></a>3.3 装载与动态链接</h3><h4 id="3-3-1可执行文件的装载"><a href="#3-3-1可执行文件的装载" class="headerlink" title="3.3.1可执行文件的装载"></a>3.3.1可执行文件的装载</h4><ul><li><p><strong>进程的虚拟地址空间</strong>：每个程序运行起来之后，它将拥有自己独立的虚拟地址空间，这个虚拟地址空间的大小由计算机的硬件平台决定，具体来说是CPU的位数决定（32位平台下的虚拟空间为4G&lt;2^32&gt;，通过<code>cat /proc/cpuinfo</code>可以看到虚拟地址的位数，如本机为<code>address sizes    : 39 bits physical, 48 bits virtual</code>，虚拟地址位数为48位，则虚拟空间为2^48）。</p><ul><li>进程只能使用操作系统分配给进程的地址，否则系统会捕获到这些访问并将其关闭（Window：进程因非法操作需要关闭；Linux：Segment Fault段错误）</li></ul></li><li><p><strong>装载的方式</strong>：程序运行时是有局部性原理的，所以可以将程序最常用的部分驻留在内存中，将不常用的数据存放在磁盘里（动态装入的基本原理）</p><ul><li>覆盖装入（几乎被淘汰）：覆盖装入的方法吧挖掘内存潜力的任务交给了程序员，程序员在编写程序时将程序分为若干块，然后编写一个辅助代码来管理这些这些模块何时应该驻留内存，何时应该被替换掉（在多个模块的情况下，程序员需要手工将它们之间的依赖关系组织成树状结构）</li><li>页映射：页映射不是一下子将指令和数据一下子装入内存，而是将内存和磁盘中的所有数据和指令按照页（Page）为单位划分，之后所有的装载和操作的单位就是页。</li></ul></li><li><p><strong>操作系统角度来看可执行文件的加载</strong>：</p><ol><li><p>创建一个独立的虚拟地址空间：创建映射函数所需要的对应的数据结构</p></li><li><p>读取可执行文件头，建立虚拟空间和可执行文件的映射关系：程序在发生页错误时，操作系统从物理空间分配出来一个物理页，然后将“缺页”从磁盘读取到内存中，并设置缺页的虚拟页与物理页的映射关系，很明显，操作系统捕获到缺页错误时，它应该知道当前所需要的页在可执行文件的哪一个位置。这就是虚拟空间与可执行文件之间的映射关系（这种映射关系只是保存在操作系统内部的一个<strong>数据结构</strong>，Linux中将进程虚拟空间中的一个段叫做虚拟内存区域（VMA））。</p></li><li><p>将CPU的指令寄存器设置成可执行文件的入口地址，启动运行</p><p><em>注：页错误处理：</em></p><ol><li><em>CPU将控制权交给操作系统</em></li><li><em>操作系统查询装载过程 第二部建立起来的数据结构，找到空白页所在的VMA，计算出相应页面在可执行文件中的便宜，然后在物理内存中分配一个物理页面，将进程中该虚拟地页与分配的物理页之间建立映射关系</em></li><li><em>把控制权还给进程</em></li></ol></li></ol></li></ul><h4 id="3-3-2-动态链接"><a href="#3-3-2-动态链接" class="headerlink" title="3.3.2 动态链接"></a>3.3.2 动态链接</h4><ul><li><strong>为什么需要动态链接</strong>：1、静态链接方式对于计算机内存和磁盘空间的浪费非常严重；2、静态链接库对程序的更新部署会带来很多麻烦（如果其中一个依赖进行了更新，那么该程序就要重新链接发布）</li><li><strong>动态链接</strong>：将链接的过程推迟到了运行的时候再进行，通过动态链接器（第二部分GCC编译过程中最后的链接设置了动态链接器参数<code>-dynamic-linker ld-linux-x86-64.so.2</code> ）完成链接工作，通过延迟绑定等来将动态链接损失的性能尽可能的小。<ul><li>动态地选择加载各种程序模块</li><li>加强程序的兼容性：一个程序在不同的平台运行时可以动态地链接到由操作系统提供的动态链接库，这些动态链接库相当于在程序和操作系统之间添加了一个中间层，从而消除程序对不同平台之间依赖的差异性</li></ul></li><li><strong>地址无关代码</strong>：共享对象在编译时不能假设自己在进程虚拟空间中的位置。把指令中那些需要修改的部分分离出来与数据部分放在一起，这样指令部分就可以保持不变，而数据部分可以在每个进程中有一个副本，这种方案就是地址无关代码（PIC，Position-Independent Code）<ul><li>装载时重定位：一旦模块装载地址确定，即目标地址确定，那么系统就对程序中所有的绝对地址进行重定位（静态链接时的重定位叫做链接时重定位；动态链接的重定位叫做装载时重定位 ）</li><li>模块中国各种类型地址类型引用方式：<ul><li>模块内部的函数调用、跳转：采用相对地址调用，不需要重定位</li><li>模块内部的数据访问，比如模块中定义的全局变量，静态变量：采用相对地址访问，获取当前的PC值，加上偏移量就能访问变量了</li><li>模块外部的数据访问，比如其它模块定义的全局变量：ELF的做法是子啊数据段里面建立一个指向这些变量的指针数组，称为全局偏移表（GOT，Global Offset Table）。GOT是放在数据段的，可以在模块装载时被修改，并且每个进程都可以有独立的副本，互相不影响。</li><li>模块外部的函数调用、跳转等：通过GOT中的项进行间接跳转</li></ul></li></ul></li><li><strong>延迟绑定</strong>：当函数第一次被用到才进行绑定（符号查找、重定位等），如果没有用到则不绑定。ELF使用PLT（Procedure Linkage Table）的方式来事先延迟绑定（PLT使解析只会在符号未解析时进行一次）。</li><li>动态链接的步骤<ul><li>动态链接器自举：动态链接器不依赖其它任何共享对象；动态链接器本身所需的全局和静态变量的重定位工作由它本身完成</li><li>装载共享对象：将可执行文件和链接器本身的符号都合并到一个全局符号表中（图的遍历过程），当一个符号需要加入到全局符号表时，如果相同的符号已经存在，则忽略后加入的符号</li><li>重定位与初始化：重新遍历可执行文件和每个共享对象的重定位表，将它们的GOT/PLT中的每个需要重定位的地方进行修正。</li></ul></li></ul><h2 id="四、参考文献"><a href="#四、参考文献" class="headerlink" title="四、参考文献"></a>四、参考文献</h2><p>[0] 程序员的自我修养 ：链接、装载与库 / 俞甲子，石凡，潘爱民著.—北京：电子工业出版社</p><p>[1] GNU ONLINE DOC - collect2 <a href="https://gcc.gnu.org/onlinedocs/gccint/Collect2.html" target="_blank" rel="noopener">https://gcc.gnu.org/onlinedocs/gccint/Collect2.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;编译&quot;&gt;&lt;a href=&quot;#编译&quot; class=&quot;headerlink&quot; title=&quot;编译&quot;&gt;&lt;/a&gt;&lt;a href=&quot;http://39.96.162.190/compile_img/compile.pdf&quot; target=&quot;_blank&quot; rel=&quot;noop
      
    
    </summary>
    
    
      <category term="C/C++" scheme="https://www.delta1037.cn/categories/C-C/"/>
    
    
      <category term="Compile" scheme="https://www.delta1037.cn/tags/Compile/"/>
    
  </entry>
  
  <entry>
    <title>基于NS3的无线链路物理层仿真实验</title>
    <link href="https://www.delta1037.cn/2019/School/%E5%9F%BA%E4%BA%8Ens3%E7%9A%84%E6%97%A0%E7%BA%BF%E9%93%BE%E8%B7%AF%E7%89%A9%E7%90%86%E5%B1%82%E4%BB%BF%E7%9C%9F%E5%AE%9E%E9%AA%8C/"/>
    <id>https://www.delta1037.cn/2019/School/基于ns3的无线链路物理层仿真实验/</id>
    <published>2019-02-11T11:21:59.000Z</published>
    <updated>2019-10-18T08:52:37.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、实验目的"><a href="#一、实验目的" class="headerlink" title="一、实验目的"></a>一、实验目的</h2><ol><li>掌握NS3的基本仿真方法</li><li>熟悉NS3的无线链路模型</li><li>改进NS3的无线链路模型</li></ol><h2 id="二、实验背景"><a href="#二、实验背景" class="headerlink" title="二、实验背景"></a>二、实验背景</h2><p>在原有的NS3的无线模型中,很难去控制链路的速率，延迟和错误等属性，例如在原有的模型中，错误率是不随距离变化的，即只要在可以传输的范围之内，错误率都是一样的，但是在实际中，随着距离的增加，错误率应该逐渐上升，而不是保持不变，因此我们在现有的模型中做出了一些改进，引入随着距离增加错误率逐渐增加的错误模型，并且引入丢头队列和丢尾队列来模拟不同队列的场景下传输速率的变化，同时加入定向网络的模型，实现定向传输的功能并且支持固定争用模型，即在冲突范围内，随着用户数量的增加，收包率逐渐下降。</p><h2 id="三、实验原理"><a href="#三、实验原理" class="headerlink" title="三、实验原理"></a>三、实验原理</h2><h4 id="1-错误模型"><a href="#1-错误模型" class="headerlink" title="1.错误模型"></a>1.错误模型</h4><p><img src="http://39.96.162.190//hexo_image/基于NS3的无线链路物理层仿真实验/图一_节点分布图.png" alt></p><p>图一:节点分布图</p><p>上图是基于NS3的错误模型节点分布图，如图所示，节点0分布在半径为100的圆的中心，其余100个节点以节点0为中心半径为100的圆内随机分布，同时节点0向周围节点发送数据，传输距离为100. ​ 在NS3原有的错误模型中，节点0向各个节点发送数据的丢包率是一样的，但是实际场景中随着距离的增加，丢包率会逐渐上升，经过研究和调查，我们所构建的丢包率曲线如下图<br><img src="https://blog-hexo-1255731105.cos.ap-chengdu.myqcloud.com/hexo-blog/%E5%9F%BA%E4%BA%8ENS3%E7%9A%84%E6%97%A0%E7%BA%BF%E9%93%BE%E8%B7%AF%E7%89%A9%E7%90%86%E5%B1%82%E4%BB%BF%E7%9C%9F%E5%AE%9E%E9%AA%8C/%E5%9B%BE%E4%BA%8C%3A%E4%B8%A2%E5%8C%85%E7%8E%87%E6%9B%B2%E7%BA%BF.png?q-sign-algorithm=sha1&amp;q-ak=AKID2ZxBF5aJlyztjLk5yhHcpnZAUaWEtxyj&amp;q-sign-time=1561772970;1561773870&amp;q-key-time=1561772970;1561773870&amp;q-header-list=&amp;q-url-param-list=&amp;q-signature=4dd5ceb5eac5f8ae797f434a098ad32244a9be7a" alt></p><p>图二:丢包率曲线</p><h4 id="2-队列模型"><a href="#2-队列模型" class="headerlink" title="2.队列模型"></a>2.队列模型</h4><p>​ 在NS3的原有队列模型中使用的是丢尾队列，当发送数据包的队列已满时，丢尾队列会丢弃队列的最后的数据包，以控制数据包的发送率，我们引入了丢头队列，即当队列已满时，主动丢弃队列的头部的数据包，因为当队列已满时，表明队列的头部数据包非常的大，导致发送时间过长，使得后面的数据包处于等待过程中。因此丢头队列机制也会使得数据包的发送速率提升。</p><h4 id="3-定向网络"><a href="#3-定向网络" class="headerlink" title="3.定向网络"></a>3.定向网络</h4><p>​ 在NS3现有的模型中,无线网络采用的时广播的方式，中心节点发送数据之后，其余的节点都会收到数据包，我们引入了定向网路的模型，即在显示场景中，通过摆放天线的朝向，可以定向的向部分节点发送数据，两者对比如图：<br><img src="https://blog-hexo-1255731105.cos.ap-chengdu.myqcloud.com/hexo-blog/%E5%9F%BA%E4%BA%8ENS3%E7%9A%84%E6%97%A0%E7%BA%BF%E9%93%BE%E8%B7%AF%E7%89%A9%E7%90%86%E5%B1%82%E4%BB%BF%E7%9C%9F%E5%AE%9E%E9%AA%8C/%E5%9B%BE%E4%B8%89%3A%E5%AE%9A%E5%90%91%E7%BD%91%E7%BB%9C%E5%92%8C%E9%9D%9E%E5%AE%9A%E5%90%91%E7%BD%91%E7%BB%9C%E5%AF%B9%E6%AF%94.png?q-sign-algorithm=sha1&amp;q-ak=AKID2ZxBF5aJlyztjLk5yhHcpnZAUaWEtxyj&amp;q-sign-time=1561772993;1561773893&amp;q-key-time=1561772993;1561773893&amp;q-header-list=&amp;q-url-param-list=&amp;q-signature=ef8123e56b6c0a5ea6a4d967281b645cdfa6ea4a" alt></p><p>图三：定向网络和非定向网络对比</p><p>​ 在NS3中构造如上图所示的场景，在定向网络中只有定向的节点才会收到数据包，其余节点则不回收到数据包，而在非定向网络中，则是全部节点都会收到数据包，因此在两种场景下统计各个节点收到的数据包的数量就可以对比两者的特性。</p><h4 id="4-固定争用"><a href="#4-固定争用" class="headerlink" title="4.固定争用"></a>4.固定争用</h4><p>​ 实际场景中，在可传输的范围内，随着用户数量的增多，用户之间发生冲突的几率会逐渐增加，网络的性能将会逐渐下降，吞吐量逐渐下降，丢包率逐渐上升。<br><img src="https://blog-hexo-1255731105.cos.ap-chengdu.myqcloud.com/hexo-blog/%E5%9F%BA%E4%BA%8ENS3%E7%9A%84%E6%97%A0%E7%BA%BF%E9%93%BE%E8%B7%AF%E7%89%A9%E7%90%86%E5%B1%82%E4%BB%BF%E7%9C%9F%E5%AE%9E%E9%AA%8C/%E5%9B%BE%E5%9B%9B%EF%BC%9A%E5%9B%BA%E5%AE%9A%E4%BA%89%E7%94%A8.png?q-sign-algorithm=sha1&amp;q-ak=AKID2ZxBF5aJlyztjLk5yhHcpnZAUaWEtxyj&amp;q-sign-time=1561773022;1561773922&amp;q-key-time=1561773022;1561773922&amp;q-header-list=&amp;q-url-param-list=&amp;q-signature=5969c778b78211878062f42da4a3aed07a86de8b" alt></p><p>图四：固定争用</p><p>​ 如图所示，仍然采用错误模型中的节点分布，中心节点向周围节点发送数据，同时不断扩大冲突范围，随着冲突范围的不断扩大，覆盖的用户数量就会不断的增加，吞吐量应该会逐渐下降，因此统计各个节点的丢包率应该会观察到随着冲突范围的增加，丢包率在逐渐上升。</p><h2 id="四、实验过程"><a href="#四、实验过程" class="headerlink" title="四、实验过程"></a>四、实验过程</h2><h4 id="1-错误模型测试"><a href="#1-错误模型测试" class="headerlink" title="1.错误模型测试"></a>1.错误模型测试</h4><p><img src="https://blog-hexo-1255731105.cos.ap-chengdu.myqcloud.com/hexo-blog/%E5%9F%BA%E4%BA%8ENS3%E7%9A%84%E6%97%A0%E7%BA%BF%E9%93%BE%E8%B7%AF%E7%89%A9%E7%90%86%E5%B1%82%E4%BB%BF%E7%9C%9F%E5%AE%9E%E9%AA%8C/%E5%9B%BE%E4%B8%80%3A%E8%8A%82%E7%82%B9%E5%88%86%E5%B8%83%E5%9B%BE.png?q-sign-algorithm=sha1&amp;q-ak=AKID2ZxBF5aJlyztjLk5yhHcpnZAUaWEtxyj&amp;q-sign-time=1561773052;1561773952&amp;q-key-time=1561773052;1561773952&amp;q-header-list=&amp;q-url-param-list=&amp;q-signature=67483c515bf112a8658688b22f1d64c75e4f71ba" alt></p><p>图五：节点分布图</p><p>​ 采用如图五中的节点分布，一共有101个节点，节点0在中心，另外一百个节点随机分布在半径为100的圆内，令中心节点向周围节点发送数据，统计各个节点收到的数据包。<br><img src="https://blog-hexo-1255731105.cos.ap-chengdu.myqcloud.com/hexo-blog/%E5%9F%BA%E4%BA%8ENS3%E7%9A%84%E6%97%A0%E7%BA%BF%E9%93%BE%E8%B7%AF%E7%89%A9%E7%90%86%E5%B1%82%E4%BB%BF%E7%9C%9F%E5%AE%9E%E9%AA%8C/%E5%9B%BE%E4%BA%8C%3A%E4%B8%A2%E5%8C%85%E7%8E%87%E6%9B%B2%E7%BA%BF.png?q-sign-algorithm=sha1&amp;q-ak=AKID2ZxBF5aJlyztjLk5yhHcpnZAUaWEtxyj&amp;q-sign-time=1561773081;1561773981&amp;q-key-time=1561773081;1561773981&amp;q-header-list=&amp;q-url-param-list=&amp;q-signature=1a676b7a6a2b73e1018229aed5ddad8cbf332653" alt></p><p>图六:测试所得丢包率曲线</p><p>​ 采用所构造的错误模型曲线，统计丢包率，测试结果如图六所示，测试结果显示随着距离的增加，丢包率在逐渐的上升，因此符合预期要求。<br><img src="https://blog-hexo-1255731105.cos.ap-chengdu.myqcloud.com/hexo-blog/%E5%9F%BA%E4%BA%8ENS3%E7%9A%84%E6%97%A0%E7%BA%BF%E9%93%BE%E8%B7%AF%E7%89%A9%E7%90%86%E5%B1%82%E4%BB%BF%E7%9C%9F%E5%AE%9E%E9%AA%8C/%E5%9B%BE%E4%B8%83%3A%E6%B5%8B%E8%AF%95%E6%89%80%E5%BE%97%E4%B8%A2%E5%8C%85%E7%8E%87%E6%9B%B2%E7%BA%BF.png?q-sign-algorithm=sha1&amp;q-ak=AKID2ZxBF5aJlyztjLk5yhHcpnZAUaWEtxyj&amp;q-sign-time=1561773102;1561774002&amp;q-key-time=1561773102;1561774002&amp;q-header-list=&amp;q-url-param-list=&amp;q-signature=8d20304c36e3a619fa1fd7e0d751461cd456ade1" alt></p><p>图七:测试所得丢包率曲线</p><p>​ 另一方面，减少节点数量为21个，统计统计节点的收包特性图，如图七所示，图中绿色的部分表明节点正在收到数据包，其余表示因发生错误导致节点处于空闲状态，结果表明由于节点所处的距离不同，任何两个节点的收包特性是不一样的，因此也从另一方面验证了所构造的模型的合理性和正确性。</p><h4 id="2-数据包队列测试"><a href="#2-数据包队列测试" class="headerlink" title="2.数据包队列测试"></a>2.数据包队列测试</h4><p><img src="https://blog-hexo-1255731105.cos.ap-chengdu.myqcloud.com/hexo-blog/%E5%9F%BA%E4%BA%8ENS3%E7%9A%84%E6%97%A0%E7%BA%BF%E9%93%BE%E8%B7%AF%E7%89%A9%E7%90%86%E5%B1%82%E4%BB%BF%E7%9C%9F%E5%AE%9E%E9%AA%8C/%E5%9B%BE%E5%85%AB%3A%E4%B8%A2%E5%A4%B4%E9%98%9F%E5%88%97%E5%92%8C%E4%B8%A2%E4%B8%BA%E9%98%9F%E5%88%97.png?q-sign-algorithm=sha1&amp;q-ak=AKID2ZxBF5aJlyztjLk5yhHcpnZAUaWEtxyj&amp;q-sign-time=1561773119;1561774019&amp;q-key-time=1561773119;1561774019&amp;q-header-list=&amp;q-url-param-list=&amp;q-signature=b65b2c4ae9bd2a1889aee9a6971113583bb818b6" alt> ​</p><p>图八:丢头队列和丢为队列</p><p>​ 采用两种类型的队列机制:丢头队列和丢为队列，测试的机制如图八所示，一共有两个节点，节点0向节点1发送数据包，并分别采用两种队列机制，然后统计节点1的收包特性。<br><img src="https://blog-hexo-1255731105.cos.ap-chengdu.myqcloud.com/hexo-blog/%E5%9F%BA%E4%BA%8ENS3%E7%9A%84%E6%97%A0%E7%BA%BF%E9%93%BE%E8%B7%AF%E7%89%A9%E7%90%86%E5%B1%82%E4%BB%BF%E7%9C%9F%E5%AE%9E%E9%AA%8C/%E5%9B%BE%E4%B9%9D%3A%E6%B5%8B%E8%AF%95%E6%89%80%E5%BE%97%E4%B8%A2%E5%8C%85%E7%8E%87%E6%9B%B2%E7%BA%BF.png?q-sign-algorithm=sha1&amp;q-ak=AKID2ZxBF5aJlyztjLk5yhHcpnZAUaWEtxyj&amp;q-sign-time=1561773138;1561774038&amp;q-key-time=1561773138;1561774038&amp;q-header-list=&amp;q-url-param-list=&amp;q-signature=f74d92547eb2dfc0c596a80895ac233cea5d4c17" alt> ​</p><p>图九:测试所得丢包率曲线</p><p>​ 如图所示为测试结果，测试结果表明，丢头队列和丢尾队列都可以改变丢包率，并且可以看出丢头队列的延迟比丢尾队列的延迟更小。<br><img src="https://blog-hexo-1255731105.cos.ap-chengdu.myqcloud.com/hexo-blog/%E5%9F%BA%E4%BA%8ENS3%E7%9A%84%E6%97%A0%E7%BA%BF%E9%93%BE%E8%B7%AF%E7%89%A9%E7%90%86%E5%B1%82%E4%BB%BF%E7%9C%9F%E5%AE%9E%E9%AA%8C/%E5%9B%BE%E5%8D%81%3A%E9%98%9F%E5%88%97%E4%BC%98%E5%85%88%E7%BA%A7%E6%B5%8B%E8%AF%95%E6%9B%B2%E7%BA%BF.png?q-sign-algorithm=sha1&amp;q-ak=AKID2ZxBF5aJlyztjLk5yhHcpnZAUaWEtxyj&amp;q-sign-time=1561773161;1561774061&amp;q-key-time=1561773161;1561774061&amp;q-header-list=&amp;q-url-param-list=&amp;q-signature=19f928c233f5ea136b61df567f5d8f7b26227a56" alt> ​</p><p>图十:队列优先级测试曲线</p><p>​ 如图所示曲线为队列有限级的测试曲线，所发送的数据包分为数据包和控制包</p><h4 id="3-定向传输测试"><a href="#3-定向传输测试" class="headerlink" title="3.定向传输测试"></a>3.定向传输测试</h4><p><img src="https://blog-hexo-1255731105.cos.ap-chengdu.myqcloud.com/hexo-blog/%E5%9F%BA%E4%BA%8ENS3%E7%9A%84%E6%97%A0%E7%BA%BF%E9%93%BE%E8%B7%AF%E7%89%A9%E7%90%86%E5%B1%82%E4%BB%BF%E7%9C%9F%E5%AE%9E%E9%AA%8C/%E5%9B%BE%E5%8D%81%E4%B8%80%3A%E5%AE%9A%E5%90%91%E4%BC%A0%E8%BE%93%E6%B5%8B%E8%AF%95%E6%A8%A1%E5%9E%8B.png?q-sign-algorithm=sha1&amp;q-ak=AKID2ZxBF5aJlyztjLk5yhHcpnZAUaWEtxyj&amp;q-sign-time=1561773176;1561774076&amp;q-key-time=1561773176;1561774076&amp;q-header-list=&amp;q-url-param-list=&amp;q-signature=2e6410e7cc09d275460bd3a256bdaedc442b73ea" alt></p><p>图十一:定向传输测试模型</p><p>​ 上图为测试定向网络时的节点分布图，其中节点1，3，4，7，10，11为定向网络节点，当使用定向网络传输模式时，中心节点0向这些节点定向传输数据，其余节点则应不能收到数据包，而当使用非定向网络传输模式时，所有节点都应该可以收到数据包。<br><img src="https://blog-hexo-1255731105.cos.ap-chengdu.myqcloud.com/hexo-blog/%E5%9F%BA%E4%BA%8ENS3%E7%9A%84%E6%97%A0%E7%BA%BF%E9%93%BE%E8%B7%AF%E7%89%A9%E7%90%86%E5%B1%82%E4%BB%BF%E7%9C%9F%E5%AE%9E%E9%AA%8C/%E5%9B%BE%E4%B8%89%3A%E5%AE%9A%E5%90%91%E7%BD%91%E7%BB%9C%E5%92%8C%E9%9D%9E%E5%AE%9A%E5%90%91%E7%BD%91%E7%BB%9C%E5%AF%B9%E6%AF%94.png?q-sign-algorithm=sha1&amp;q-ak=AKID2ZxBF5aJlyztjLk5yhHcpnZAUaWEtxyj&amp;q-sign-time=1561773216;1561774116&amp;q-key-time=1561773216;1561774116&amp;q-header-list=&amp;q-url-param-list=&amp;q-signature=b2618e3bfedb0deae10ee6fc2a95f93edb3aabf7" alt></p><p>图十二:定向传输测试结果</p><p>​ 测试结果如上图，蓝色为非定向网络，黄色为定向网络，结果表明，当使用非定向网络时，全部节点都可以收到数据包，当使用定向网络时，只有定向网络节点才可以收到数据包，非定向网络节点无法收到数据包。</p><h4 id="4-固定争用测试"><a href="#4-固定争用测试" class="headerlink" title="4.固定争用测试"></a>4.固定争用测试</h4><p><img src="https://blog-hexo-1255731105.cos.ap-chengdu.myqcloud.com/hexo-blog/%E5%9F%BA%E4%BA%8ENS3%E7%9A%84%E6%97%A0%E7%BA%BF%E9%93%BE%E8%B7%AF%E7%89%A9%E7%90%86%E5%B1%82%E4%BB%BF%E7%9C%9F%E5%AE%9E%E9%AA%8C/%E5%9B%BE%E5%9B%9B%EF%BC%9A%E5%9B%BA%E5%AE%9A%E4%BA%89%E7%94%A8.png?q-sign-algorithm=sha1&amp;q-ak=AKID2ZxBF5aJlyztjLk5yhHcpnZAUaWEtxyj&amp;q-sign-time=1561773227;1561774127&amp;q-key-time=1561773227;1561774127&amp;q-header-list=&amp;q-url-param-list=&amp;q-signature=c484b0f432ec6ab915e2c1bb86cb8086c6a53111" alt></p><p>图十三：固定争用测试结果</p><p>​ 如图所示，横轴为冲突范围所覆盖的用户数量，测试结果表明：随着冲突范围的不断扩大，覆盖的用户数量逐渐增多，因此导致的冲突逐渐增多，丢包率逐渐上升，收包率逐渐下降。</p><h2 id="五、实验小结"><a href="#五、实验小结" class="headerlink" title="五、实验小结"></a>五、实验小结</h2><p>​ 实验过程中，我们遇到了很多的问题，首先在实验环境的搭建过程中，刚开始搭建的是基于NS3-dev的环境，在代码测试的过程中遇到了很多的问题，之后又搭建了NS3-dce的环境进行测试。同时，在测试代码的时候也有很多的问题，由于机器的处理速度有限，仿真测试结果往往需要很长时间才会出来，也花费了我们很多的精力。 ​ 在之后的过程中，我们将继续改进这个模型，构建宏基站和微基站的体系架构，并在此架构上面探索单小区模型和大规模网络场景模型下的基站调度策略。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、实验目的&quot;&gt;&lt;a href=&quot;#一、实验目的&quot; class=&quot;headerlink&quot; title=&quot;一、实验目的&quot;&gt;&lt;/a&gt;一、实验目的&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;掌握NS3的基本仿真方法&lt;/li&gt;
&lt;li&gt;熟悉NS3的无线链路模型&lt;/li&gt;
&lt;li&gt;改进NS
      
    
    </summary>
    
    
      <category term="课设" scheme="https://www.delta1037.cn/categories/%E8%AF%BE%E8%AE%BE/"/>
    
    
      <category term="NS-3" scheme="https://www.delta1037.cn/tags/NS-3/"/>
    
  </entry>
  
  <entry>
    <title>chrome起始页修改</title>
    <link href="https://www.delta1037.cn/2018/Bugsfix/chrome%E8%B5%B7%E5%A7%8B%E9%A1%B5/"/>
    <id>https://www.delta1037.cn/2018/Bugsfix/chrome起始页/</id>
    <published>2018-12-31T14:11:02.000Z</published>
    <updated>2019-10-18T08:35:20.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="修改chrome起始页面"><a href="#修改chrome起始页面" class="headerlink" title="修改chrome起始页面"></a>修改chrome起始页面</h1><p>window上的chrome一进去就是2345什么鬼的乱七八糟的，看着贼难看</p><h2 id="改名字"><a href="#改名字" class="headerlink" title="改名字"></a>改名字</h2><p>修改C:\Program Files (x86)\Google\Chrome\Application下的chrome.exe为其它名字，比如geniusrabbit.exe ，重新建立快捷方式到桌面就行了，同时也可以固定到底部</p><h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p><img src="https://blog-hexo-1255731105.cos.ap-chengdu.myqcloud.com/hexo-blog/%E5%9F%BA%E4%BA%8ENS3%E7%9A%84%E6%97%A0%E7%BA%BF%E9%93%BE%E8%B7%AF%E7%89%A9%E7%90%86%E5%B1%82%E4%BB%BF%E7%9C%9F%E5%AE%9E%E9%AA%8C/%E5%9B%BE%E5%9B%9B%EF%BC%9A%E5%9B%BA%E5%AE%9A%E4%BA%89%E7%94%A8.png?q-sign-algorithm=sha1&amp;q-ak=AKID2ZxBF5aJlyztjLk5yhHcpnZAUaWEtxyj&amp;q-sign-time=1561773227;1561774127&amp;q-key-time=1561773227;1561774127&amp;q-header-list=&amp;q-url-param-list=&amp;q-signature=c484b0f432ec6ab915e2c1bb86cb8086c6a53111" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;修改chrome起始页面&quot;&gt;&lt;a href=&quot;#修改chrome起始页面&quot; class=&quot;headerlink&quot; title=&quot;修改chrome起始页面&quot;&gt;&lt;/a&gt;修改chrome起始页面&lt;/h1&gt;&lt;p&gt;window上的chrome一进去就是2345什么鬼的乱七八
      
    
    </summary>
    
    
      <category term="Bug" scheme="https://www.delta1037.cn/categories/Bug/"/>
    
    
      <category term="chrome" scheme="https://www.delta1037.cn/tags/chrome/"/>
    
  </entry>
  
  <entry>
    <title>敏捷开发小记</title>
    <link href="https://www.delta1037.cn/2018/School/%E6%95%8F%E6%8D%B7%E5%BC%80%E5%8F%91%E5%B0%8F%E8%AE%B0/"/>
    <id>https://www.delta1037.cn/2018/School/敏捷开发小记/</id>
    <published>2018-11-12T14:48:33.000Z</published>
    <updated>2019-10-18T08:56:01.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="敏捷知识基础"><a href="#敏捷知识基础" class="headerlink" title="敏捷知识基础"></a>敏捷知识基础</h3><ul><li>迭代计划会议、迭代验收会议、每日站立会议、迭代回顾会议</li><li>聚焦客户价值，激发团队潜能、适应变化</li><li>自动化、变化的需求</li></ul><h1 id="story"><a href="#story" class="headerlink" title="story"></a>story</h1><ul><li>故事描述了对于系统或软件的客户或用户有价值的一个功能点</li><li>组成<ul><li>简短描述</li><li>针对故事描述交流，澄清细节</li><li>记录和传递故事细节的测试信息，用来确定故事是否开发完成</li></ul></li><li>格式：<ul><li>作为X（什么用户角色</li><li>为了Y（目的</li><li>希望得到什么（系统提供什么功能</li></ul></li><li>3-3-4<ul><li>三个角色：PO、master、开发人员</li><li>三个工件：</li><li>产品清单</li><li>迭代清单</li><li>燃尽图</li><li>四个会议</li></ul></li><li>收集story<ul><li>价值分析</li><li>识别用户角色</li><li>编写story</li><li>确定优先级</li><li>估计</li></ul></li><li>分解Story<ul><li>分解原则：每个格式提供相对完整的功能</li></ul></li><li>好的story<ul><li>独立</li><li>便于沟通</li><li>有价值</li><li>易于估计</li><li>可测试</li></ul></li></ul><h2 id="持续集成"><a href="#持续集成" class="headerlink" title="持续集成"></a>持续集成</h2><ul><li>持续集成工作产品，一天集成多次，每次集成有自动化的测试环境（包含测试）</li></ul><h2 id="测试驱动开发"><a href="#测试驱动开发" class="headerlink" title="测试驱动开发"></a>测试驱动开发</h2><ul><li>快速新增测试</li><li>运行所有测试</li><li>做改动</li><li>所有测试通过</li><li>重构，消除重复设计，设计优化结构</li></ul><h2 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h2><ul><li>快速：测试运行够快</li><li>独立用例之间互相独立</li><li>可重复：任何环境、可重复</li><li>自足验证：足够的自动化测试验证逻辑</li><li>及时：及时写测试用例</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;敏捷知识基础&quot;&gt;&lt;a href=&quot;#敏捷知识基础&quot; class=&quot;headerlink&quot; title=&quot;敏捷知识基础&quot;&gt;&lt;/a&gt;敏捷知识基础&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;迭代计划会议、迭代验收会议、每日站立会议、迭代回顾会议&lt;/li&gt;
&lt;li&gt;聚焦客户价值，激发团队
      
    
    </summary>
    
    
      <category term="敏捷开发" scheme="https://www.delta1037.cn/categories/%E6%95%8F%E6%8D%B7%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="敏捷开发" scheme="https://www.delta1037.cn/tags/%E6%95%8F%E6%8D%B7%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>自动化测试与shell总结</title>
    <link href="https://www.delta1037.cn/2018/School/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E4%B8%8Eshell%E6%80%BB%E7%BB%93/"/>
    <id>https://www.delta1037.cn/2018/School/自动化测试与shell总结/</id>
    <published>2018-11-12T14:17:09.000Z</published>
    <updated>2019-11-12T07:18:27.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="自动化测试-amp-amp-shell总结"><a href="#自动化测试-amp-amp-shell总结" class="headerlink" title="自动化测试&amp;&amp;shell总结"></a>自动化测试&amp;&amp;shell总结</h1><p><em>学习软件工程,小有所成</em></p><h2 id="自动化测试"><a href="#自动化测试" class="headerlink" title="自动化测试"></a>自动化测试</h2><p>自动化测试,使用自动化工具(脚本等&lt;应该可以这么理解?&gt;),自动测试工程</p><h3 id="关于测试"><a href="#关于测试" class="headerlink" title="关于测试"></a>关于测试</h3><p>测试即为测试代码,但是测试代码的方式又有很多,在没有学习软件工程之前,我自己以为的测试就是写一个函数,调用所写的函数,传入参数,然后根据传出的参数来判断函数的功能是否正确;学习软件工程之后,测试是传入测试的指令,预制工程的状态,然后由原工程进行代码的运行之后,最后导出运行之后的状态,与正确的状态对比,判断工程运行是否正确</p><h4 id="1-单元测试"><a href="#1-单元测试" class="headerlink" title="1.单元测试"></a>1.单元测试</h4><p>单元测试就是学习软件工程之前的测试方法,即:写测试函数,调用工程中的某一个功能函数,根据调用该函数之后的返回值,来判断该功能函数实现的是否正确. 这就是单元测试(测试诸多功能中的一个)</p><h4 id="2-集成测试"><a href="#2-集成测试" class="headerlink" title="2.集成测试"></a>2.集成测试</h4><p>集成测试就是学习软件工程之后的测试方法,即:在工程中留有接口,准备接收预置工程状态的命令,和导出工程状态的指令,根据导出的状态,来与正确的状态进行比较,来判断整个工程是否正确. 这就是集成测试(测试整个工程)</p><h3 id="关于自动化测试"><a href="#关于自动化测试" class="headerlink" title="关于自动化测试"></a>关于自动化测试</h3><p>测试实现自动化, 就是将导入工程状态和比较程序状态的过程由工具实现,比如可以写一个脚本,自动导入要预置的工程的状态,然后对比导出的状态与正确的状态是否一致 心得: 1. 将预置的状态的命令写入表格中,便于管理测试用例 2. 将正确的状态写入表格,便于管理 3. 将表格内容生成文件</p><h2 id="Shell"><a href="#Shell" class="headerlink" title="Shell"></a>Shell</h2><p>这次软件工程实践,在自动化测试这一块采用的shell脚本来实现测试的自动化</p><ul><li><p>关于文件的对比: 对比肯定是需要两个文件的,但是两个文件又在不同的文件夹中, 若采用for循环遍历文件夹,则只能遍历其中一个文件夹 ,并且shell中没有同时遍历两个文件夹的for循环&lt;解决思路: 先用一个for循环遍历其中一个文件夹,将遍历到的文件路径存于数组中, 然后再去遍历另外一个文件夹,并且依次读取数组中的内容,便实现了同时遍历的效果&gt;</p></li><li><p>关于操作对象的确定性: 本来使用的for循环遍历文件夹是使用的for m in $(ls someFilePath)的形式,然后m就是其中的一个文件,但是使用这种形式操作下,我们并不清楚m是什么,(ls的顺序虽然是按照一定的顺序排列的,但是对于m的未知性,这种操作也有一定的危险性&lt;解决思路,对文件命名采用数字标识,加前缀表明文件类型,例如:dump1,dump2….right1,right2…. for循环的时候就可以循环坐标&gt;</p></li><li><p>脚本风格:在微机原理课上学到,所有的变量及其赋值应该放置在一处以便于管理的思想, 所以所有的可见的字符都应该用变量名字标识,然后在后边的脚本中只对变量名字操作,这样,如果想修改变量的值,只在统一的地方修改就可以,不用修改使用变量的诸多地方(类似于c语言中的宏)</p></li><li><p>精确浮点数计算:”scale=2;算术表达式” | bc</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;自动化测试-amp-amp-shell总结&quot;&gt;&lt;a href=&quot;#自动化测试-amp-amp-shell总结&quot; class=&quot;headerlink&quot; title=&quot;自动化测试&amp;amp;&amp;amp;shell总结&quot;&gt;&lt;/a&gt;自动化测试&amp;amp;&amp;amp;shell总结
      
    
    </summary>
    
    
      <category term="测试" scheme="https://www.delta1037.cn/categories/%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="Shell" scheme="https://www.delta1037.cn/tags/Shell/"/>
    
      <category term="测试" scheme="https://www.delta1037.cn/tags/%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Linux小系统（一）-小系统制作</title>
    <link href="https://www.delta1037.cn/2018/Linux/linux%E5%B0%8F%E7%B3%BB%E7%BB%9F-%E5%B0%8F%E7%B3%BB%E7%BB%9F%E5%88%B6%E4%BD%9C/"/>
    <id>https://www.delta1037.cn/2018/Linux/linux小系统-小系统制作/</id>
    <published>2018-10-06T15:05:57.000Z</published>
    <updated>2019-11-12T07:17:12.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="制作Linux小系统-外围文件系统定制"><a href="#制作Linux小系统-外围文件系统定制" class="headerlink" title="制作Linux小系统-外围文件系统定制"></a>制作Linux小系统-外围文件系统定制</h1><blockquote><p>环境： - window10 - <a href="https://my.vmware.com/en/web/vmware/info/slug/desktop_end_user_computing/vmware_workstation_pro/14_0" target="_blank" rel="noopener">vmvare pro 14</a> - <a href="http://mirrors.huaweicloud.com/centos/6.10/isos/x86_64/" target="_blank" rel="noopener">centos6.10-mini</a></p></blockquote><hr><hr><h2 id="一、Linux启动过程分析"><a href="#一、Linux启动过程分析" class="headerlink" title="一、Linux启动过程分析"></a>一、Linux启动过程分析</h2><ol><li>BIOS</li><li>MBR/GPT<ul><li>Master Boot Record and Disk partitions</li><li>Globally Unique Identifier Parttion Table Format</li></ul></li><li>OS Loader<ul><li>Window:NTLDR/BootMgr</li><li>Linux:GRUB/GRUB2</li></ul></li><li>OS Kernel<ul><li>DOS:IO.SYS MSDOS.SYS</li><li>Window:ntoskrnl.exe</li><li>Linux:vmlinuz</li></ul></li><li>Application Manager<ul><li>DOS:command.com</li><li>Window:explorer.exe</li><li>Linux:init</li></ul></li><li>Applications…</li></ol><h2 id="二、启动bash"><a href="#二、启动bash" class="headerlink" title="二、启动bash"></a>二、启动bash</h2><h3 id="boot中的init-img文件"><a href="#boot中的init-img文件" class="headerlink" title="/boot中的init*.img文件"></a>/boot中的init*.img文件</h3><ul><li>一个由OS loader载入的镜像文件</li><li><p>临时“根文件系统”</p><h1 id="boot-grub-grub-conf文件"><a href="#boot-grub-grub-conf文件" class="headerlink" title="/boot/grub/grub.conf文件"></a>/boot/grub/grub.conf文件</h1><p>title Linux 2.4</p><pre><code>root (hd0,1)kernel /boot/vmlinuz ramdisk_size=8192 root=LABEL=/initrd /boot/initrd.img</code></pre></li></ul><h3 id="制作根文件系统"><a href="#制作根文件系统" class="headerlink" title="制作根文件系统"></a>制作根文件系统</h3><blockquote><p>使用原来的kernel，initd自己的init*.img</p></blockquote><ul><li><p>如何生成img文件</p><h1 id="表示当前目录"><a href="#表示当前目录" class="headerlink" title=". 表示当前目录"></a>. 表示当前目录</h1><p>$ find . | cpio -H newc -o | gzip &gt; /boot/initrd.img</p></li></ul><ul><li><p>解压生成的img(不小心删掉了自己的系统文件夹，可以用这个方法恢复)</p><p>$ mv initramfs.img  initramfs.img.gz # 添加gz后缀<br>$ gunzip initramfs.img.gz # 解压<br>$ mkdir temp # 创建目录并将解压后的文件丢进去<br>$ cpio -i -F ../initramfs.img # 解压刚刚丢进temp的文件</p></li></ul><h3 id="制作init"><a href="#制作init" class="headerlink" title="制作init"></a>制作init</h3><blockquote><p>Application Manager</p></blockquote><p>init是开机后grub引导进入系统后执行的，所以想要开机进去之后得到一个bash，就得在这个里面定制过程 bash是一个命令，所以只要执行这个命令，就可以得到一个bash，</p><pre><code># 查找命令find，可使用通配符*$ find / -name &quot;bash&quot;</code></pre><h3 id="可执行文件-amp-动态库"><a href="#可执行文件-amp-动态库" class="headerlink" title="可执行文件&amp;动态库"></a>可执行文件&amp;动态库</h3><blockquote><p>随意创建一个目录作为我们小系统的根目录，创建必要的文件夹（拷入小系统的路径与大系统路径一致，例如bash在bin目录中，就要在小系统根目录下创建bin目录然后将bash拷入）</p></blockquote><p>bash执行还需要有其依赖的动态库，我们的小系统启动起来是独立于大系统的，所以我们要将其依赖的动态库也拷进我们的小系统</p><pre><code># 查新指令依赖的动态库$ ldd /可执行文件路径$ ldd /bin/bash</code></pre><ul><li><p>拷贝可执行文件依赖动态库脚本</p><p>#!/bin/bash</p><h1 id="use-script-sh-可执行文件-动态库目录"><a href="#use-script-sh-可执行文件-动态库目录" class="headerlink" title="use : ./script.sh /可执行文件  /动态库目录"></a>use : ./script.sh /可执行文件  /动态库目录</h1><p>dependList=$( ldd $1 | awk ‘{if (match($3,”/“)){ print $3}}’ )<br>echo $dependList<br>cp $dependList $2</p></li></ul><ul><li><p>拷贝目录下的所有可执行文件依赖的动态库脚本</p><p>#!/bin/bash</p><h1 id="use-script-sh-可执行文件目录-动态库目录"><a href="#use-script-sh-可执行文件目录-动态库目录" class="headerlink" title="use : ./script.sh /可执行文件目录  /动态库目录"></a>use : ./script.sh /可执行文件目录  /动态库目录</h1><p>for m in $(ls $1)<br>do</p><pre><code>dependList=$( ldd $1/$m | awk &apos;{if (match($3,&quot;/&quot;)){ print $3}}&apos; )cp $dependList $2</code></pre><p>done</p></li></ul><h2 id="三、管理设备"><a href="#三、管理设备" class="headerlink" title="三、管理设备"></a>三、管理设备</h2><ul><li>udev : 管理、监控主机设备的服务程序<ul><li>依赖与sysfs文件系统（挂载于/sys）</li><li>规则文件/lib/udev</li><li>配置文件/etc/udev</li><li>自动在/dev目录下创建设备节点</li></ul></li><li><p>/proc目录：通过 /proc 文件系统，在运行时访问内核内部数据结构、改变内核设置的机制</p></li><li><p>/sys目录：硬件设备的驱动程序信息</p></li></ul><p>通过执行/sbin/start_udev，就可以检测到所有的设备</p><pre><code># 查看当前机器所有设备$ ls /dev</code></pre><h2 id="四、挂载磁盘"><a href="#四、挂载磁盘" class="headerlink" title="四、挂载磁盘"></a>四、挂载磁盘</h2><blockquote><p>磁盘也是一种设备</p></blockquote><p>在linux上挂载磁盘，磁盘一般是在dev目录里的，但是在上面的管理设备部分，当列出当前机器设备时，并没有看到有关sd*之类的，这是因为<strong>缺少驱动程序</strong> Linux的驱动在/lib/modules目录，可以看到有不同的版本号</p><pre><code>$ lsmod # 列出当前机器所使用的所有驱动$ modinfo # 查看驱动具体介绍，包括驱动依赖关系$ insmod # 加载指定的驱动$ modprobe # 载入制定模块或者载入一组相依的模块，需要有依赖关系moudules.dep</code></pre><ul><li>磁盘所需驱动<ul><li>scsi_transport_spi.ko</li><li>mptbase.ko</li><li>mptscsih.ko</li><li>mptspi.ko</li><li>crc-t10dif.ko</li><li>sd_mod.ko</li></ul></li><li>etx4文件系统驱动<ul><li>mbcache.ko</li><li>jbd2.ko</li><li>ext4.ko</li></ul></li></ul><p>当加载完磁盘和文件系统驱动，就可以挂载和读写原来的文件系统了</p><h2 id="五、登录login"><a href="#五、登录login" class="headerlink" title="五、登录login"></a>五、登录login</h2><ul><li>login认证体系（PAM）<ul><li>/etc/pam.d</li><li>/lib/security</li></ul></li></ul><h2 id="六、使用-sbin-init启动系统"><a href="#六、使用-sbin-init启动系统" class="headerlink" title="六、使用/sbin/init启动系统"></a>六、使用/sbin/init启动系统</h2><p>/sbin/init的工作：</p><ul><li>/etc/rc.sysinit<ul><li>probe devices:udevd</li><li>fsck</li><li>remount</li></ul></li><li>/etc/rc<ul><li>service</li></ul></li><li>/sbin/mingetty<ul><li>login prompt = mingetty+/bin/login</li></ul></li></ul><h2 id="七、联网"><a href="#七、联网" class="headerlink" title="七、联网"></a>七、联网</h2><ul><li>网卡驱动：<ul><li>e1000.ko</li></ul></li><li><p>ping：查看网络是否连通</p></li><li><p>ethtool：查看网卡信息</p></li><li>ifup、ifdown：启动，关闭网卡</li><li>mentohust：连接校园网的工具</li><li>ssh：连接到远程主机，或者被远程主机连接</li><li>scp：基于ssh在两台主机之间拷贝文件</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;制作Linux小系统-外围文件系统定制&quot;&gt;&lt;a href=&quot;#制作Linux小系统-外围文件系统定制&quot; class=&quot;headerlink&quot; title=&quot;制作Linux小系统-外围文件系统定制&quot;&gt;&lt;/a&gt;制作Linux小系统-外围文件系统定制&lt;/h1&gt;&lt;bloc
      
    
    </summary>
    
    
      <category term="课设" scheme="https://www.delta1037.cn/categories/%E8%AF%BE%E8%AE%BE/"/>
    
    
      <category term="Linux小系统" scheme="https://www.delta1037.cn/tags/Linux%E5%B0%8F%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>Linux小系统（二）-内核编译</title>
    <link href="https://www.delta1037.cn/2018/Linux/linux%E5%86%85%E6%A0%B8%E7%BC%96%E8%AF%91/"/>
    <id>https://www.delta1037.cn/2018/Linux/linux内核编译/</id>
    <published>2018-10-04T11:16:31.000Z</published>
    <updated>2019-11-12T07:17:40.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux内核编译"><a href="#Linux内核编译" class="headerlink" title="Linux内核编译"></a>Linux内核编译</h1><h2 id="内核下载与解压"><a href="#内核下载与解压" class="headerlink" title="内核下载与解压"></a>内核下载与解压</h2><h3 id="内核下载"><a href="#内核下载" class="headerlink" title="内核下载"></a>内核下载</h3><p><a href="https://www.kernel.org/" target="_blank" rel="noopener">内核下载地址</a></p><h3 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h3><pre><code>$ tar -xvf linux-*.tar.xz</code></pre><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><h3 id="安装开发环境"><a href="#安装开发环境" class="headerlink" title="安装开发环境"></a>安装开发环境</h3><pre><code>$ yum groupinstall &apos;Development Tools&apos;$ yum install ncurses-devel$ yum install elfutils-libelf-devel$ yum install bc</code></pre><h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><p><a href="http://www.jinbuguo.com/kernel/longterm-linux-kernel-options.html" target="_blank" rel="noopener">Linux-4.4-x86_64 内核配置选项简介-作者：金步国</a> <a href="https://wizardforcel.gitbooks.io/vbird-linux-basic-4e/content/208.html" target="_blank" rel="noopener">Linux 核心编译与管理-鸟哥</a></p><h3 id="TIPS"><a href="#TIPS" class="headerlink" title="TIPS"></a>TIPS</h3><h4 id="小系统需要实现的功能、"><a href="#小系统需要实现的功能、" class="headerlink" title="小系统需要实现的功能、"></a>小系统需要实现的功能、</h4><ul><li>CPU</li><li>硬盘控制器</li><li>网络控制器</li><li>USB控制器<ul><li>HID、Mass Storage</li></ul></li><li>声卡控制器(可选)</li></ul><h4 id="个人总结"><a href="#个人总结" class="headerlink" title="个人总结"></a>个人总结</h4><ul><li>网络控制器：联网需要网卡驱动，在设备管理器里可以看到自己网卡是什么型号的，然后在设备驱动-&gt;网络设备支持-&gt;以太网设备支持里将自己网卡那一类勾上，其它可以不要（因为没有这类网卡）</li><li>能编译成模块的尽量编译成模块，这样内核会变小很多</li></ul><h3 id="编译过程"><a href="#编译过程" class="headerlink" title="编译过程"></a>编译过程</h3><pre><code>$ make mrproper # 删除之前的核心功能配置文件,配置文件！！！$ make clean # 清理编译过程中的中间文件，不删除配置文件$ make menuconfig #选择模块$ make clean #清除$ make -j 4   #多线程编译$ make modules_install #安葬模块$ make install #一键安装</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Linux内核编译&quot;&gt;&lt;a href=&quot;#Linux内核编译&quot; class=&quot;headerlink&quot; title=&quot;Linux内核编译&quot;&gt;&lt;/a&gt;Linux内核编译&lt;/h1&gt;&lt;h2 id=&quot;内核下载与解压&quot;&gt;&lt;a href=&quot;#内核下载与解压&quot; class=&quot;he
      
    
    </summary>
    
    
      <category term="课设" scheme="https://www.delta1037.cn/categories/%E8%AF%BE%E8%AE%BE/"/>
    
    
      <category term="Linux小系统" scheme="https://www.delta1037.cn/tags/Linux%E5%B0%8F%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>Linux小系统（三）-U盘启动</title>
    <link href="https://www.delta1037.cn/2018/Linux/linux%E5%B0%8F%E7%B3%BB%E7%BB%9F-u%E7%9B%98%E5%90%AF%E5%8A%A8/"/>
    <id>https://www.delta1037.cn/2018/Linux/linux小系统-u盘启动/</id>
    <published>2018-10-04T11:05:01.000Z</published>
    <updated>2019-11-12T07:17:22.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="U盘启动小系统"><a href="#U盘启动小系统" class="headerlink" title="U盘启动小系统"></a>U盘启动小系统</h1><blockquote><p>环境： Window10 CentOs虚拟机</p></blockquote><h2 id="制作启动盘"><a href="#制作启动盘" class="headerlink" title="制作启动盘"></a>制作启动盘</h2><ol><li>找一个不常用的U盘，分出来一小部分作为启动分区，剩余的作为日常使用（最好在window上分盘。。。）</li><li><p>在虚拟机上挂载U盘，启动分区格式化</p><p>$ mkfs.ext4 /dev/uBootPart</p></li></ol><ol start="3"><li><p>将分出来的启动分区添加上启动标志</p><p>$ fdisk /dev/uBootPart -a </p></li></ol><p>再次fdisk -l 之后看到U盘的启动分区的boot下有个* <img src="https://www.geniusrabbit.top/wp-content/uploads/2018/10/linu_boot1.png" alt> 4.向启动分区中安装grub,/mnt是挂载位置</p><pre><code>$ grub-install --root-directory=/mnt   /dev/uBootPart</code></pre><h2 id="必要文件拷贝"><a href="#必要文件拷贝" class="headerlink" title="必要文件拷贝"></a>必要文件拷贝</h2><ul><li>/boot/grub/grub.conf (内容做适当修改)</li><li>boot/vmlinuz*</li><li>boot/initramfs.img</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;U盘启动小系统&quot;&gt;&lt;a href=&quot;#U盘启动小系统&quot; class=&quot;headerlink&quot; title=&quot;U盘启动小系统&quot;&gt;&lt;/a&gt;U盘启动小系统&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;环境： Window10 CentOs虚拟机&lt;/p&gt;
&lt;/blockquo
      
    
    </summary>
    
    
      <category term="课设" scheme="https://www.delta1037.cn/categories/%E8%AF%BE%E8%AE%BE/"/>
    
    
      <category term="Linux小系统" scheme="https://www.delta1037.cn/tags/Linux%E5%B0%8F%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>计网笔记</title>
    <link href="https://www.delta1037.cn/2018/School/%E8%AE%A1%E7%BD%91%E7%AC%94%E8%AE%B0/"/>
    <id>https://www.delta1037.cn/2018/School/计网笔记/</id>
    <published>2018-09-11T11:25:10.000Z</published>
    <updated>2019-10-18T08:54:13.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计网笔记"><a href="#计网笔记" class="headerlink" title="计网笔记"></a>计网笔记</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul><li>路由：根据目的节点地址确定如何将消息转发到目的节点的过程</li><li>常用的两种交换方式：电路交换、分组交换<ul><li>电路交换：建立一条专用电路，允许源节点通过这条链路将比特流发送到目的节点</li><li>电路交换存在原因：对网络容量需求的不断增加</li><li>分组交换：使用存储转发机制，每个节点先通过某条链路接收一个完整的分组，将分组存储到内存中，然后将整个分组发送到下一个节点，节点彼此之间发送离散的数据块</li><li>分组交换特点：分组交换效率高</li></ul></li><li>分层和协议<ul><li>分层优点：1.将建造网络这个问题分解为多个可处理的部分；2.提供模块化的设计</li><li>协议：协议为另一台机器上的对等实体定义一个对等接口</li></ul></li><li>中间节点：（由处理的层分类）<ul><li>repeater/中继：直接在物理层处理，转发数据包</li><li>bridge/网桥：在数据链路层处理，将网络中的多个网段在数据链路层中转发</li><li>router/路由：在网络层处理，根据目的节点地址确定如何将消息转发到目的节点的过程</li><li>gateway/网关：在传输层及以上处理，按照网段转发数据</li></ul></li><li><p>时延 = 光速传播延迟+发送数据单元时间+排队延迟</p></li><li><p>带宽：在一段特定的时间内网络所能传输的比特数</p></li><li><p>延迟带宽积：相当于第一个比特到达接收者之前，发送者必须发送的比特数</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;计网笔记&quot;&gt;&lt;a href=&quot;#计网笔记&quot; class=&quot;headerlink&quot; title=&quot;计网笔记&quot;&gt;&lt;/a&gt;计网笔记&lt;/h1&gt;&lt;h2 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a
      
    
    </summary>
    
    
      <category term="计算机网络" scheme="https://www.delta1037.cn/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
  </entry>
  
  <entry>
    <title>visdom&amp;tensorBoardX可视化</title>
    <link href="https://www.delta1037.cn/2018/Deploy/visdomtensorboard%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    <id>https://www.delta1037.cn/2018/Deploy/visdomtensorboard可视化/</id>
    <published>2018-08-16T09:50:31.000Z</published>
    <updated>2019-10-18T08:50:17.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="acc-loss曲线的可视化"><a href="#acc-loss曲线的可视化" class="headerlink" title="acc,loss曲线的可视化"></a>acc,loss曲线的可视化</h1><hr><h2 id="visdom"><a href="#visdom" class="headerlink" title="visdom"></a>visdom</h2><ul><li><p>安装</p><p>$ pip install visdom</p></li></ul><ul><li><p>启用</p><p>$ python -m visdom.server</p></li></ul><ul><li><p>使用</p><p>import visdom<br>vis = visdom.Visdom(env=’model_env’)</p></li></ul><h3 id="多曲线可视化-loss-acc"><a href="#多曲线可视化-loss-acc" class="headerlink" title="多曲线可视化(loss,acc)"></a>多曲线可视化(loss,acc)</h3><pre><code>vis.line(Y=np.column_stack(np.array([train_loss, train_acc,test_acc])),            X=np.column_stack(np.array([epoch + 1, epoch + 1, epoch + 1])),            win=&apos;main&apos;,            update=&apos;append&apos;)</code></pre><h2 id="tensorboardX"><a href="#tensorboardX" class="headerlink" title="tensorboardX"></a>tensorboardX</h2><ul><li><p>安装</p><p>$ pip install tensorboardX</p></li></ul><ul><li><p>使用</p><p>from tensorboardX import SummaryWriter<br>writer = SummaryWriter(‘/path/to/log’)</p></li></ul><h3 id="多曲线可视化-loss-acc-1"><a href="#多曲线可视化-loss-acc-1" class="headerlink" title="多曲线可视化(loss, acc)"></a>多曲线可视化(loss, acc)</h3><pre><code>writer.add_scalars(&apos;data/group&apos;, {&apos;test_loss&apos;:loss_vue, &apos;test_acc&apos;:acc_vue}, train_step)</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;acc-loss曲线的可视化&quot;&gt;&lt;a href=&quot;#acc-loss曲线的可视化&quot; class=&quot;headerlink&quot; title=&quot;acc,loss曲线的可视化&quot;&gt;&lt;/a&gt;acc,loss曲线的可视化&lt;/h1&gt;&lt;hr&gt;
&lt;h2 id=&quot;visdom&quot;&gt;&lt;a h
      
    
    </summary>
    
    
      <category term="机器学习" scheme="https://www.delta1037.cn/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="tensorboard" scheme="https://www.delta1037.cn/tags/tensorboard/"/>
    
      <category term="visdom" scheme="https://www.delta1037.cn/tags/visdom/"/>
    
  </entry>
  
  <entry>
    <title>CodeStyle</title>
    <link href="https://www.delta1037.cn/2018/C_C++/codestyle/"/>
    <id>https://www.delta1037.cn/2018/C_C++/codestyle/</id>
    <published>2018-07-31T15:09:46.000Z</published>
    <updated>2019-10-18T08:36:41.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CodeStyle-待续…"><a href="#CodeStyle-待续…" class="headerlink" title="CodeStyle(待续…)"></a>CodeStyle(待续…)</h1><p><strong>!我最讨厌不写注释的人和让我写注释的人…</strong> <strong>写好代码,人人有责</strong> 共勉~</p><h2 id="一-CODE-COMPLETE-NOTE"><a href="#一-CODE-COMPLETE-NOTE" class="headerlink" title="一.CODE COMPLETE NOTE"></a>一.CODE COMPLETE NOTE</h2><h3 id="1-变量"><a href="#1-变量" class="headerlink" title="1.变量"></a>1.变量</h3><ul><li>变量定义尽量靠近使用该变量的地方</li><li>使用同一变量的代码尽量集中到一起,减轻大脑负担</li><li>尽量减小变量的作用域,更有利于debug,又不会对远处的变量误操作</li></ul><h2 id="二-Leetcode踩坑指南"><a href="#二-Leetcode踩坑指南" class="headerlink" title="二.Leetcode踩坑指南"></a>二.Leetcode踩坑指南</h2><h3 id="1-要考虑所有的情况"><a href="#1-要考虑所有的情况" class="headerlink" title="1.要考虑所有的情况"></a>1.要考虑所有的情况</h3><ul><li>传入为空的情况:例如传入了一个数组但是里面有0个值,传入了一个链表但是头结点就为NULL</li><li>传入二维数组:在判断列数是否为0的时候,提前判断行数是否是0,否则无法得到列数</li></ul><h3 id="2-返回二维数组操作"><a href="#2-返回二维数组操作" class="headerlink" title="2.返回二维数组操作"></a>2.返回二维数组操作</h3><h4 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h4><pre><code>int** function(int* array, int arraySize, int** columnSizes, int* returnSize) {    //some operation}</code></pre><h4 id="Explanation"><a href="#Explanation" class="headerlink" title="Explanation"></a>Explanation</h4><ul><li>the array is what you have to operate</li><li>returnSize is the rowSize that you have to return</li><li><p>columnSizes is the col size of every row，malloc format is</p><p>int <em>col=(int</em>)malloc(rowSize*sizeof(int));</p><pre><code>*columnSizes=col;</code></pre></li></ul><h3 id="计算中间值-防止溢出"><a href="#计算中间值-防止溢出" class="headerlink" title="计算中间值(防止溢出)"></a>计算中间值(防止溢出)</h3><ul><li><p>给定first和last，计算mid：</p><p>mid=first+(last-first)/2;  //若直接相加除二可能会溢出</p></li></ul><h3 id="Run-time-error问题"><a href="#Run-time-error问题" class="headerlink" title="Run time error问题"></a>Run time error问题</h3><ul><li>Run time error :数组越界（maybe…）</li><li>存在死循环:数组的index更新或者链表的循环有问题</li></ul><h2 id="三-个人总结"><a href="#三-个人总结" class="headerlink" title="三.个人总结"></a>三.个人总结</h2><ul><li><p>1 函数注释</p><p>/**</p><ul><li>function: 函数功能</li><li>@param: 函数参数,简介</li><li>@return: 返回值简介</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;CodeStyle-待续…&quot;&gt;&lt;a href=&quot;#CodeStyle-待续…&quot; class=&quot;headerlink&quot; title=&quot;CodeStyle(待续…)&quot;&gt;&lt;/a&gt;CodeStyle(待续…)&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;!我最讨厌不写注释的人和让我写注
      
    
    </summary>
    
    
      <category term="C/C++" scheme="https://www.delta1037.cn/categories/C-C/"/>
    
    
      <category term="CodeStyle" scheme="https://www.delta1037.cn/tags/CodeStyle/"/>
    
  </entry>
  
  <entry>
    <title>Apache配置ssl</title>
    <link href="https://www.delta1037.cn/2018/Deploy/apache%E9%85%8D%E7%BD%AEssl/"/>
    <id>https://www.delta1037.cn/2018/Deploy/apache配置ssl/</id>
    <published>2018-07-31T11:55:45.000Z</published>
    <updated>2019-10-18T08:35:38.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="阿里云申请的ssl证书配置-Apache"><a href="#阿里云申请的ssl证书配置-Apache" class="headerlink" title="阿里云申请的ssl证书配置(Apache)"></a>阿里云申请的ssl证书配置(Apache)</h1><h2 id="下载证书"><a href="#下载证书" class="headerlink" title="下载证书"></a>下载证书</h2><ul><li>下载证书</li><li>上传到服务器</li><li>解压到 /etc/apache2/ssl (不存在则创建)</li></ul><h2 id="配置Apache"><a href="#配置Apache" class="headerlink" title="配置Apache"></a>配置Apache</h2><ul><li><p>打开SSL模块</p><p>$ a2enmod ssl</p></li></ul><ul><li><p>配置conf 编辑apache2配置文件</p><p>$ vim /etc/apache2/apache2.conf</p></li></ul><p>apache2配置文件</p><pre><code>&lt;Directory /var/www/&gt;        Options Indexes FollowSymLinks        #把none改为all        AllowOverride all         Require all granted&lt;/Directory&gt;</code></pre><p>编辑port.conf文件</p><pre><code>$ vim ports.conf</code></pre><p>port.conf配置</p><pre><code>#添加监听443端口&lt;IfModule ssl_module&gt;        Listen 443&lt;/IfModule&gt;</code></pre><p>配置default-ssl.conf</p><pre><code>#添加servernameServerName example.com#修改sslengineSSLEngine on#添加证书文件，按照阿里云给出的示例添加即可#证书的文件位置就是刚刚上传的位置SSLCertificateFile      /etc/apache2/ssl/public.pem SSLCertificateKeyFile /etc/apache2/ssl/2146003231320408.keySSLCertificateChainFile /etc/apache2/ssl/chain.pem</code></pre><h2 id="启用"><a href="#启用" class="headerlink" title="启用"></a>启用</h2><p>启用刚刚的ssl配置</p><pre><code>$ a2ensite default-ssl</code></pre><p>重启apache服务器</p><pre><code>$ service apache2 restart</code></pre><p>OK~</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;阿里云申请的ssl证书配置-Apache&quot;&gt;&lt;a href=&quot;#阿里云申请的ssl证书配置-Apache&quot; class=&quot;headerlink&quot; title=&quot;阿里云申请的ssl证书配置(Apache)&quot;&gt;&lt;/a&gt;阿里云申请的ssl证书配置(Apache)&lt;/h1
      
    
    </summary>
    
    
      <category term="服务器" scheme="https://www.delta1037.cn/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
      <category term="SSL" scheme="https://www.delta1037.cn/tags/SSL/"/>
    
  </entry>
  
  <entry>
    <title>神经网络Note</title>
    <link href="https://www.delta1037.cn/2018/School/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9Cnote/"/>
    <id>https://www.delta1037.cn/2018/School/神经网络note/</id>
    <published>2018-07-30T09:56:33.000Z</published>
    <updated>2019-10-18T08:56:17.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="神经网络笔记"><a href="#神经网络笔记" class="headerlink" title="神经网络笔记"></a>神经网络笔记</h1><ul><li>代码链接<a href="https://github.com/genius-rabbit/dianStudy/tree/master/naturalNetWork" target="_blank" rel="noopener">github</a> :wink:</li></ul><h2 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h2><h5 id="数据处理"><a href="#数据处理" class="headerlink" title="数据处理"></a>数据处理</h5><pre><code>train_data = torchvision.datasets.CIFAR10(    root=&apos;Datadir&apos;, train=True, transform=transforms.ToTensor(),download=True)</code></pre><ul><li>torchvision.datasets.CIFAR10:代表这是cifar10数据集,若为torchvision.datasets.MNIST则为mnist数据集</li><li>root:数据集的存放位置</li><li>train=True:代表这是训练集</li><li><p>download=True:如果数据不存在就会自行下载</p><p>train_loader = Data.DataLoader(dataset=train_data, batch_size=4, shuffle=True, num_workers=2)</p></li></ul><ul><li>dataset=train_data:代表从train_data加载数据</li><li>batch_size: 批训练的数据个数</li><li>shuffle: 是否要打乱数据(打乱比较好)</li><li>num_workers: 多线程读取数据</li></ul><h5 id="训练模型"><a href="#训练模型" class="headerlink" title="训练模型"></a>训练模型</h5><pre><code>optimizer = optim.SGD(net.parameters(), lr=0.03)</code></pre><ul><li><p>定义优化器</p><ul><li>lr=0.03: 学习率为0.03</li><li>SGD: 使用SGD优化器</li></ul><p>loss_func = nn.CrossEntropyLoss()</p></li></ul><ul><li><p>定义损失函数</p><ul><li>CrossEntropyLoss:交叉熵损失</li></ul><h1 id="循环使用数据训练50次"><a href="#循环使用数据训练50次" class="headerlink" title="循环使用数据训练50次"></a>循环使用数据训练50次</h1><p>for epoch in range(50):</p><pre><code># 训练# 每次训练之前的初始化loss&amp;acctrain_loss = 0train_acc = 0for i, data in enumerate(train_loader, 0):    # 得到数据    inputs, lables = data    # 包装数据    inputs, lables = Variable(inputs), Variable(lables)    # 梯度清零    optimizer.zero_grad()    # 将输入输进网络&amp;forward    out = net(inputs)    # 计算损失    loss = loss_func(out, lables)    train_loss += loss.item()    # 计算正确率    pred = torch.max(out, 1)[1]    train_acc += (pred == lables).sum().item()    # backward&amp;optimize    loss.backward()    optimizer.step()    train_loss += loss.data.item()    if i % 2000 == 1999:        # 格式化输出loss&amp;acc        print(&apos;[%d,%5d] loss:%.6f&apos; % (epoch+1, i+1, train_loss/2000))        print(&apos;[%d,%5d] acc: %.6f&apos; % (epoch + 1, i + 1, train_acc / (2000 * lables.size(0))))        # 训练2000组数据打印数据之后的初始化        train_acc = 0        train_loss = 0        torch.save(net, &apos;Alex0.03.pkl&apos;)# 测试# 正确率初始化train_acc1 = 0for i, data in enumerate(test_loader, 0):    # 得到数据并包装数据    inputs, lables = data    inputs, lables = Variable(inputs), Variable(lables)    # 计算正确率    out = net(inputs)    pred = torch.max(out, 1)[1]    train_acc1 += (pred == lables).sum().item()    # 阶段性输出    if i % 1000 == 999:        print(&apos;testDataAcc:[%d,%5d] acc: %.6f&apos; % (epoch + 1, i + 1, train_acc1 / (1000 * lables.size(0))))        train_acc1 = 0</code></pre></li></ul><h2 id="全连接神经网络"><a href="#全连接神经网络" class="headerlink" title="全连接神经网络"></a>全连接神经网络</h2><h3 id="note"><a href="#note" class="headerlink" title="note"></a>note</h3><ul><li>每层的节点数和层数可自己随意定义</li></ul><h3 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h3><ul><li><a href="https://github.com/genius-rabbit/dianStudy/blob/master/naturalNetWork/mnist.py" target="_blank" rel="noopener">mnist全连接参考代码</a></li><li><a href="https://github.com/genius-rabbit/dianStudy/blob/master/naturalNetWork/cifar10.py" target="_blank" rel="noopener">cifar10全连接参考代码</a></li></ul><h2 id="卷积神经网络"><a href="#卷积神经网络" class="headerlink" title="卷积神经网络"></a>卷积神经网络</h2><h3 id="参数计算"><a href="#参数计算" class="headerlink" title="参数计算"></a>参数计算</h3><ul><li>输入矩阵的格式:四个维度(样本数,图像高度,图像宽度,图像通道数)</li><li>卷积核(权重矩阵):四个维度(卷积核高,卷积核宽,输入通道数,输出通道数)<ul><li>卷积核输入的通道数由输入矩阵的通道数决定</li><li>输出矩阵的通道数由卷积核的输出通道数决定</li><li>输出矩阵的高和宽由输入矩阵,卷积核,扫描方式(padding,stride)所决定</li></ul></li><li>卷积之后的图像大小计算:outputSize = (inputSize + 2*padding - kernelSize)/stride + 1</li></ul><h3 id="LeNet-AlexNet-VGG-ResNet-GoogLeNet"><a href="#LeNet-AlexNet-VGG-ResNet-GoogLeNet" class="headerlink" title="LeNet AlexNet VGG ResNet GoogLeNet"></a>LeNet AlexNet VGG ResNet GoogLeNet</h3><h4 id="leNet"><a href="#leNet" class="headerlink" title="leNet"></a>leNet</h4><ul><li><a href="https://github.com/genius-rabbit/dianStudy/blob/master/naturalNetWork/leNet.py" target="_blank" rel="noopener">cifar10数据集参考代码</a> <img src="https://www.geniusrabbit.top/wp-content/uploads/2018/08/LeNet.png" alt></li><li>输入是32x32的图像</li><li>C1是一个卷积层,卷积核为5x5,步长为1,没有填充,由(32-2*0-5)/1+1=28,得输出图像为28x28</li><li>S2是一个降采样层,kernelSize等于2,步长为2,没有填充,得到输出为14x14</li><li>C3是一个卷积层,卷积核大小为5x5,步长为1,没有填充,得输出图像为10x10</li><li>S4是一个降采样层,kernelSize等于2,步长为2,没有填充,得到输出为5x5</li><li>C5是一个卷积层,卷积核大小为5x5,步长为1,没有填充,得输出图像为1x1</li><li>F6是一个全连接层</li><li>输出有十个参数</li></ul><h4 id="AlexNet"><a href="#AlexNet" class="headerlink" title="AlexNet"></a>AlexNet</h4><p>-<a href="https://github.com/genius-rabbit/dianStudy/blob/master/naturalNetWork/AlexNet.py" target="_blank" rel="noopener">cifar10数据集参考代码</a> <strong>代码做了简化,使用单个运算核心运行的</strong> <img src="https://www.geniusrabbit.top/wp-content/uploads/2018/08/AlexNet.png" alt> note未跟随代码 - 卷积部分分为上下两块,卷积使用数据要看连接的虚线 - LRN层:对当前层的输出结果做平滑处理</p><h4 id="VGG"><a href="#VGG" class="headerlink" title="VGG"></a>VGG</h4><ul><li><a href="https://github.com/genius-rabbit/dianStudy/blob/master/naturalNetWork/VGG.py" target="_blank" rel="noopener">cifar10数据集参考代码</a></li><li>连续conv较多,计算量巨大</li></ul><h4 id="ResNet"><a href="#ResNet" class="headerlink" title="ResNet"></a>ResNet</h4><ul><li><a href="https://github.com/genius-rabbit/dianStudy/blob/master/naturalNetWork/ResNet.py" target="_blank" rel="noopener">cifar10数据集参考代码</a></li></ul><h6 id="深度网络的退化问题"><a href="#深度网络的退化问题" class="headerlink" title="深度网络的退化问题"></a>深度网络的退化问题</h6><pre><code>网络深度增加时,网络准确度出现饱和甚至开始下降</code></pre><h6 id="使用残差学习解决退化问题"><a href="#使用残差学习解决退化问题" class="headerlink" title="使用残差学习解决退化问题"></a>使用残差学习解决退化问题</h6><p>残差学习相比原始特征直接学习更容易,当残差为0时,此时堆积层仅仅做了恒等映射.至少网络性能不会下降,实际上残差不会为0,也会使得堆积层在输入特征基础上学习到新的特征,从而有更好的性能 - 残差学习相当于一种短路机制</p><pre><code>残差学习单元</code></pre><p><img src="https://www.geniusrabbit.top/wp-content/uploads/2018/08/ResNet.png" alt></p><pre><code>不同深度的ResNet网络</code></pre><p><img src="https://www.geniusrabbit.top/wp-content/uploads/2018/08/ResNetAll.png" alt></p><h4 id="googLeNet"><a href="#googLeNet" class="headerlink" title="googLeNet"></a>googLeNet</h4><ul><li><a href="http://noahsnail.com/2017/07/21/2017-7-21-GoogleNet%E8%AE%BA%E6%96%87%E7%BF%BB%E8%AF%91%E2%80%94%E2%80%94%E4%B8%AD%E6%96%87%E7%89%88/" target="_blank" rel="noopener">论文翻译中文版</a></li><li><a href="https://github.com/kuangliu/pytorch-cifar/blob/master/models/googlenet.py" target="_blank" rel="noopener">cifar10数据集参考代码</a> GoogLeNet 与传统神经网络相比提出了Inception结构,用于增加神经网络的宽度和深度,Inception模型主要考虑多个不同的卷积核能够增强网络的适应能力,4个分支在最后通过一个聚合操作合并</li></ul><h6 id="Inception"><a href="#Inception" class="headerlink" title="Inception"></a>Inception</h6><p><a href="https://blog.csdn.net/hejin_some/article/details/78636586" target="_blank" rel="noopener">参考博客</a></p><ul><li><p>v1 版本1: <img src="https://www.geniusrabbit.top/wp-content/uploads/2018/08/v10.png" alt> 随后文章指出这种 naive 结构存在着<strong>问题</strong>：每一层 Inception module 的 filters 参数量为所有分支上的总数和，多层 Inception 最终将导致 model 的参数数量庞大，对计算资源有更大的依赖 版本2: <img src="https://www.geniusrabbit.top/wp-content/uploads/2018/08/v11.png" alt> <strong>改进</strong>:Inception module with dimension reduction,在不损失模型特征表示能力的前提下，尽量减少 filters 的数量，达到降低模型复杂度的目的</p></li><li><p>v2 <img src="https://www.geniusrabbit.top/wp-content/uploads/2018/08/v2.jpeg" alt> 使用两个3*3的卷积核代替一个5*5的卷积核,在降低参数的同时,增加了更多的非线性变换</p></li><li><p>v3 <img src="https://www.geniusrabbit.top/wp-content/uploads/2018/08/v31.png" alt> <img src="https://www.geniusrabbit.top/wp-content/uploads/2018/08/v32.png" alt> <img src="https://www.geniusrabbit.top/wp-content/uploads/2018/08/v33.png" alt> 将一个3*3的卷积核拆解成3*1和1*3的卷积核 引入了 Factorization into small convolutions 的思想,将一个较大的二维卷积拆解为两个较小的一维卷积,加速了运算并减轻了过拟合</p></li><li><p>v4 <img src="https://www.geniusrabbit.top/wp-content/uploads/2018/08/v41.png" alt> <img src="https://www.geniusrabbit.top/wp-content/uploads/2018/08/v42.png" alt> <img src="https://www.geniusrabbit.top/wp-content/uploads/2018/08/v43.png" alt></p><p>V4 相比 V3 主要是结合了微软的 ResNet</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;神经网络笔记&quot;&gt;&lt;a href=&quot;#神经网络笔记&quot; class=&quot;headerlink&quot; title=&quot;神经网络笔记&quot;&gt;&lt;/a&gt;神经网络笔记&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;代码链接&lt;a href=&quot;https://github.com/genius-rabbit/di
      
    
    </summary>
    
    
      <category term="机器学习" scheme="https://www.delta1037.cn/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="神经网络" scheme="https://www.delta1037.cn/tags/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
</feed>
